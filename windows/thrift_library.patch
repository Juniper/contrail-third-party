1,326c1,330
< <?xml version="1.0" encoding="utf-8"?>
< <Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
<   <ItemGroup Label="ProjectConfigurations">
<     <ProjectConfiguration Include="Debug|Win32">
<       <Configuration>Debug</Configuration>
<       <Platform>Win32</Platform>
<     </ProjectConfiguration>
<     <ProjectConfiguration Include="Debug|x64">
<       <Configuration>Debug</Configuration>
<       <Platform>x64</Platform>
<     </ProjectConfiguration>
<     <ProjectConfiguration Include="Release|Win32">
<       <Configuration>Release</Configuration>
<       <Platform>Win32</Platform>
<     </ProjectConfiguration>
<     <ProjectConfiguration Include="Release|x64">
<       <Configuration>Release</Configuration>
<       <Platform>x64</Platform>
<     </ProjectConfiguration>
<   </ItemGroup>
<   <ItemGroup>
<     <ClCompile Include="src\async\TAsyncChannel.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\concurrency\BoostMonitor.cpp" />
<     <ClCompile Include="src\concurrency\BoostMutex.cpp" />
<     <ClCompile Include="src\concurrency\BoostThreadFactory.cpp" />
<     <ClCompile Include="src\concurrency\ThreadManager.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\concurrency\TimerManager.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\concurrency\Util.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\processor\PeekProcessor.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\protocol\TBase64Utils.cpp" />
<     <ClCompile Include="src\protocol\TDebugProtocol.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\protocol\TDenseProtocol.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\protocol\TJSONProtocol.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\server\TSimpleServer.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\server\TThreadPoolServer.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\TApplicationException.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\Thrift.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\transport\TBufferTransports.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\transport\TFDTransport.cpp" />
<     <ClCompile Include="src\transport\TFileTransport.cpp">
<       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
<       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
<     </ClCompile>
<     <ClCompile Include="src\transport\THttpClient.cpp" />
<     <ClCompile Include="src\transport\THttpServer.cpp" />
<     <ClCompile Include="src\transport\THttpTransport.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\transport\TServerSocket.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\transport\TSimpleFileTransport.cpp" />
<     <ClCompile Include="src\transport\TSocket.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\transport\TSSLSocket.cpp">
<       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
<       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
<       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
<       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
<     </ClCompile>
<     <ClCompile Include="src\transport\TTransportException.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\transport\TTransportUtils.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\windows\GetTimeOfDay.cpp" />
<     <ClCompile Include="src\windows\SocketPair.cpp" />
<     <ClCompile Include="src\windows\StdAfx.cpp">
<       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
<       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
<       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
<       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
<     </ClCompile>
<     <ClCompile Include="src\windows\TWinsockSingleton.cpp" />
<     <ClCompile Include="src\windows\WinFcntl.cpp" />
<   </ItemGroup>
<   <ItemGroup>
<     <ClInclude Include="src\async\TAsyncChannel.h" />
<     <ClInclude Include="src\concurrency\BoostThreadFactory.h" />
<     <ClInclude Include="src\concurrency\Exception.h" />
<     <ClInclude Include="src\concurrency\PlatformThreadFactory.h" />
<     <ClInclude Include="src\processor\PeekProcessor.h" />
<     <ClInclude Include="src\protocol\TBinaryProtocol.h" />
<     <ClInclude Include="src\protocol\TDebugProtocol.h" />
<     <ClInclude Include="src\protocol\TDenseProtocol.h" />
<     <ClInclude Include="src\protocol\TJSONProtocol.h" />
<     <ClInclude Include="src\protocol\TProtocol.h" />
<     <ClInclude Include="src\protocol\TVirtualProtocol.h" />
<     <ClInclude Include="src\server\TServer.h" />
<     <ClInclude Include="src\server\TSimpleServer.h" />
<     <ClInclude Include="src\server\TThreadPoolServer.h" />
<     <ClInclude Include="src\TApplicationException.h" />
<     <ClInclude Include="src\Thrift.h" />
<     <ClInclude Include="src\TProcessor.h" />
<     <ClInclude Include="src\transport\TBufferTransports.h" />
<     <ClInclude Include="src\transport\TFDTransport.h" />
<     <ClInclude Include="src\transport\TFileTransport.h" />
<     <ClInclude Include="src\transport\THttpClient.h" />
<     <ClInclude Include="src\transport\THttpServer.h" />
<     <ClInclude Include="src\transport\TServerSocket.h" />
<     <ClInclude Include="src\transport\TServerTransport.h" />
<     <ClInclude Include="src\transport\TSimpleFileTransport.h" />
<     <ClInclude Include="src\transport\TSocket.h" />
<     <ClInclude Include="src\transport\TSSLSocket.h" />
<     <ClInclude Include="src\transport\TTransport.h" />
<     <ClInclude Include="src\transport\TTransportException.h" />
<     <ClInclude Include="src\transport\TTransportUtils.h" />
<     <ClInclude Include="src\transport\TVirtualTransport.h" />
<     <ClInclude Include="src\windows\config.h" />
<     <ClInclude Include="src\windows\force_inc.h" />
<     <ClInclude Include="src\windows\GetTimeOfDay.h" />
<     <ClInclude Include="src\windows\Operators.h" />
<     <ClInclude Include="src\windows\SocketPair.h" />
<     <ClInclude Include="src\windows\StdAfx.h" />
<     <ClInclude Include="src\windows\TargetVersion.h" />
<     <ClInclude Include="src\windows\TWinsockSingleton.h" />
<     <ClInclude Include="src\windows\WinFcntl.h" />
<   </ItemGroup>
<   <ItemGroup>
<     <None Include="src\protocol\TBinaryProtocol.tcc" />
<     <None Include="src\windows\tr1\functional" />
<   </ItemGroup>
<   <PropertyGroup Label="Globals">
<     <ProjectGuid>{DD26F57E-60F2-4F37-A616-D219A9BF338F}</ProjectGuid>
<     <Keyword>Win32Proj</Keyword>
<     <RootNamespace>thrift</RootNamespace>
<     <ProjectName>libthrift</ProjectName>
<   </PropertyGroup>
<   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
<   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
<     <ConfigurationType>StaticLibrary</ConfigurationType>
<     <UseDebugLibraries>true</UseDebugLibraries>
<     <CharacterSet>MultiByte</CharacterSet>
<   </PropertyGroup>
<   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
<     <ConfigurationType>StaticLibrary</ConfigurationType>
<     <UseDebugLibraries>true</UseDebugLibraries>
<     <CharacterSet>MultiByte</CharacterSet>
<   </PropertyGroup>
<   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
<     <ConfigurationType>StaticLibrary</ConfigurationType>
<     <UseDebugLibraries>false</UseDebugLibraries>
<     <WholeProgramOptimization>true</WholeProgramOptimization>
<     <CharacterSet>MultiByte</CharacterSet>
<   </PropertyGroup>
<   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
<     <ConfigurationType>StaticLibrary</ConfigurationType>
<     <UseDebugLibraries>false</UseDebugLibraries>
<     <WholeProgramOptimization>true</WholeProgramOptimization>
<     <CharacterSet>MultiByte</CharacterSet>
<   </PropertyGroup>
<   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
<   <ImportGroup Label="ExtensionSettings">
<   </ImportGroup>
<   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
<     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
<   </ImportGroup>
<   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
<     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
<   </ImportGroup>
<   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
<     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
<   </ImportGroup>
<   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
<     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
<   </ImportGroup>
<   <PropertyGroup Label="UserMacros" />
<   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
<     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(ProjectDir)\src\transport\;$(THIRD_PARTY)\boost\boost_1_47_0\include;$(THIRD_PARTY)\boost\boost_1_47_0\;$(THIRD_PARTY)\openssl\OpenSSL-Win32\include\;$(IncludePath)</IncludePath>
<   </PropertyGroup>
<   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
<     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(ProjectDir)\src\transport\;$(THIRD_PARTY)\boost\boost_1_47_0\include;$(THIRD_PARTY)\boost\boost_1_47_0\;$(THIRD_PARTY)\openssl\OpenSSL-Win32\include\;$(IncludePath)</IncludePath>
<   </PropertyGroup>
<   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
<     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(ProjectDir)\src\transport\;$(THIRD_PARTY)\boost\boost_1_47_0\include;$(THIRD_PARTY)\boost\boost_1_47_0\;$(THIRD_PARTY)\openssl\OpenSSL-Win32\include\;$(IncludePath)</IncludePath>
<   </PropertyGroup>
<   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
<     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(ProjectDir)\src\transport\;$(THIRD_PARTY)\boost\boost_1_47_0\include;$(THIRD_PARTY)\boost\boost_1_47_0\;$(THIRD_PARTY)\openssl\OpenSSL-Win32\include\;$(IncludePath)</IncludePath>
<   </PropertyGroup>
<   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
<     <ClCompile>
<       <PrecompiledHeader>NotUsing</PrecompiledHeader>
<       <WarningLevel>Level3</WarningLevel>
<       <Optimization>Disabled</Optimization>
<       <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <ForcedIncludeFiles>force_inc.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
<       <ProgramDataBaseFileName>$(IntDir)libthrift.pdb</ProgramDataBaseFileName>
<     </ClCompile>
<     <Link>
<       <SubSystem>Windows</SubSystem>
<       <GenerateDebugInformation>true</GenerateDebugInformation>
<     </Link>
<   </ItemDefinitionGroup>
<   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
<     <ClCompile>
<       <PrecompiledHeader>NotUsing</PrecompiledHeader>
<       <WarningLevel>Level3</WarningLevel>
<       <Optimization>Disabled</Optimization>
<       <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <ForcedIncludeFiles>force_inc.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
<     </ClCompile>
<     <Link>
<       <SubSystem>Windows</SubSystem>
<       <GenerateDebugInformation>true</GenerateDebugInformation>
<     </Link>
<   </ItemDefinitionGroup>
<   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
<     <ClCompile>
<       <WarningLevel>Level3</WarningLevel>
<       <PrecompiledHeader>NotUsing</PrecompiledHeader>
<       <Optimization>MaxSpeed</Optimization>
<       <FunctionLevelLinking>true</FunctionLevelLinking>
<       <IntrinsicFunctions>true</IntrinsicFunctions>
<       <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <ForcedIncludeFiles>force_inc.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
<       <ProgramDataBaseFileName>$(IntDir)libthrift.pdb</ProgramDataBaseFileName>
<     </ClCompile>
<     <Link>
<       <SubSystem>Windows</SubSystem>
<       <GenerateDebugInformation>true</GenerateDebugInformation>
<       <EnableCOMDATFolding>true</EnableCOMDATFolding>
<       <OptimizeReferences>true</OptimizeReferences>
<     </Link>
<   </ItemDefinitionGroup>
<   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
<     <ClCompile>
<       <WarningLevel>Level3</WarningLevel>
<       <PrecompiledHeader>NotUsing</PrecompiledHeader>
<       <Optimization>MaxSpeed</Optimization>
<       <FunctionLevelLinking>true</FunctionLevelLinking>
<       <IntrinsicFunctions>true</IntrinsicFunctions>
<       <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <ForcedIncludeFiles>force_inc.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
<     </ClCompile>
<     <Link>
<       <SubSystem>Windows</SubSystem>
<       <GenerateDebugInformation>true</GenerateDebugInformation>
<       <EnableCOMDATFolding>true</EnableCOMDATFolding>
<       <OptimizeReferences>true</OptimizeReferences>
<     </Link>
<   </ItemDefinitionGroup>
<   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
<   <ImportGroup Label="ExtensionTargets">
<   </ImportGroup>
---
> <?xml version="1.0" encoding="utf-8"?>
> <Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
>   <ItemGroup Label="ProjectConfigurations">
>     <ProjectConfiguration Include="Debug|Win32">
>       <Configuration>Debug</Configuration>
>       <Platform>Win32</Platform>
>     </ProjectConfiguration>
>     <ProjectConfiguration Include="Debug|x64">
>       <Configuration>Debug</Configuration>
>       <Platform>x64</Platform>
>     </ProjectConfiguration>
>     <ProjectConfiguration Include="Release|Win32">
>       <Configuration>Release</Configuration>
>       <Platform>Win32</Platform>
>     </ProjectConfiguration>
>     <ProjectConfiguration Include="Release|x64">
>       <Configuration>Release</Configuration>
>       <Platform>x64</Platform>
>     </ProjectConfiguration>
>   </ItemGroup>
>   <ItemGroup>
>     <ClCompile Include="src\async\TAsyncChannel.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\concurrency\BoostMonitor.cpp" />
>     <ClCompile Include="src\concurrency\BoostMutex.cpp" />
>     <ClCompile Include="src\concurrency\BoostThreadFactory.cpp" />
>     <ClCompile Include="src\concurrency\ThreadManager.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\concurrency\TimerManager.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\concurrency\Util.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\processor\PeekProcessor.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\protocol\TBase64Utils.cpp" />
>     <ClCompile Include="src\protocol\TDebugProtocol.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\protocol\TDenseProtocol.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\protocol\TJSONProtocol.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\server\TSimpleServer.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\server\TThreadPoolServer.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\TApplicationException.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\Thrift.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\transport\TBufferTransports.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\transport\TFDTransport.cpp" />
>     <ClCompile Include="src\transport\TFileTransport.cpp">
>       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
>       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
>     </ClCompile>
>     <ClCompile Include="src\transport\THttpClient.cpp" />
>     <ClCompile Include="src\transport\THttpServer.cpp" />
>     <ClCompile Include="src\transport\THttpTransport.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\transport\TServerSocket.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\transport\TSimpleFileTransport.cpp" />
>     <ClCompile Include="src\transport\TSocket.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\transport\TSSLSocket.cpp">
>       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
>       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
>       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
>       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
>     </ClCompile>
>     <ClCompile Include="src\transport\TTransportException.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\transport\TTransportUtils.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\windows\GetTimeOfDay.cpp" />
>     <ClCompile Include="src\windows\SocketPair.cpp" />
>     <ClCompile Include="src\windows\StdAfx.cpp">
>       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
>       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
>       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
>       <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
>     </ClCompile>
>     <ClCompile Include="src\windows\TWinsockSingleton.cpp" />
>     <ClCompile Include="src\windows\WinFcntl.cpp" />
>   </ItemGroup>
>   <ItemGroup>
>     <ClInclude Include="src\async\TAsyncChannel.h" />
>     <ClInclude Include="src\concurrency\BoostThreadFactory.h" />
>     <ClInclude Include="src\concurrency\Exception.h" />
>     <ClInclude Include="src\concurrency\PlatformThreadFactory.h" />
>     <ClInclude Include="src\processor\PeekProcessor.h" />
>     <ClInclude Include="src\protocol\TBinaryProtocol.h" />
>     <ClInclude Include="src\protocol\TDebugProtocol.h" />
>     <ClInclude Include="src\protocol\TDenseProtocol.h" />
>     <ClInclude Include="src\protocol\TJSONProtocol.h" />
>     <ClInclude Include="src\protocol\TProtocol.h" />
>     <ClInclude Include="src\protocol\TVirtualProtocol.h" />
>     <ClInclude Include="src\server\TServer.h" />
>     <ClInclude Include="src\server\TSimpleServer.h" />
>     <ClInclude Include="src\server\TThreadPoolServer.h" />
>     <ClInclude Include="src\TApplicationException.h" />
>     <ClInclude Include="src\Thrift.h" />
>     <ClInclude Include="src\TProcessor.h" />
>     <ClInclude Include="src\transport\TBufferTransports.h" />
>     <ClInclude Include="src\transport\TFDTransport.h" />
>     <ClInclude Include="src\transport\TFileTransport.h" />
>     <ClInclude Include="src\transport\THttpClient.h" />
>     <ClInclude Include="src\transport\THttpServer.h" />
>     <ClInclude Include="src\transport\TServerSocket.h" />
>     <ClInclude Include="src\transport\TServerTransport.h" />
>     <ClInclude Include="src\transport\TSimpleFileTransport.h" />
>     <ClInclude Include="src\transport\TSocket.h" />
>     <ClInclude Include="src\transport\TSSLSocket.h" />
>     <ClInclude Include="src\transport\TTransport.h" />
>     <ClInclude Include="src\transport\TTransportException.h" />
>     <ClInclude Include="src\transport\TTransportUtils.h" />
>     <ClInclude Include="src\transport\TVirtualTransport.h" />
>     <ClInclude Include="src\windows\config.h" />
>     <ClInclude Include="src\windows\force_inc.h" />
>     <ClInclude Include="src\windows\GetTimeOfDay.h" />
>     <ClInclude Include="src\windows\Operators.h" />
>     <ClInclude Include="src\windows\SocketPair.h" />
>     <ClInclude Include="src\windows\StdAfx.h" />
>     <ClInclude Include="src\windows\TargetVersion.h" />
>     <ClInclude Include="src\windows\TWinsockSingleton.h" />
>     <ClInclude Include="src\windows\WinFcntl.h" />
>   </ItemGroup>
>   <ItemGroup>
>     <None Include="src\protocol\TBinaryProtocol.tcc" />
>     <None Include="src\windows\tr1\functional" />
>   </ItemGroup>
>   <PropertyGroup Label="Globals">
>     <ProjectGuid>{DD26F57E-60F2-4F37-A616-D219A9BF338F}</ProjectGuid>
>     <Keyword>Win32Proj</Keyword>
>     <RootNamespace>thrift</RootNamespace>
>     <ProjectName>libthrift</ProjectName>
>   </PropertyGroup>
>   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
>     <ConfigurationType>StaticLibrary</ConfigurationType>
>     <UseDebugLibraries>true</UseDebugLibraries>
>     <CharacterSet>MultiByte</CharacterSet>
>     <PlatformToolset>v140</PlatformToolset>
>   </PropertyGroup>
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
>     <ConfigurationType>StaticLibrary</ConfigurationType>
>     <UseDebugLibraries>true</UseDebugLibraries>
>     <CharacterSet>MultiByte</CharacterSet>
>     <PlatformToolset>v140</PlatformToolset>
>   </PropertyGroup>
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
>     <ConfigurationType>StaticLibrary</ConfigurationType>
>     <UseDebugLibraries>false</UseDebugLibraries>
>     <WholeProgramOptimization>true</WholeProgramOptimization>
>     <CharacterSet>MultiByte</CharacterSet>
>     <PlatformToolset>v140</PlatformToolset>
>   </PropertyGroup>
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
>     <ConfigurationType>StaticLibrary</ConfigurationType>
>     <UseDebugLibraries>false</UseDebugLibraries>
>     <WholeProgramOptimization>true</WholeProgramOptimization>
>     <CharacterSet>MultiByte</CharacterSet>
>     <PlatformToolset>v140</PlatformToolset>
>   </PropertyGroup>
>   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
>   <ImportGroup Label="ExtensionSettings">
>   </ImportGroup>
>   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
>     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
>   </ImportGroup>
>   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
>     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
>   </ImportGroup>
>   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
>     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
>   </ImportGroup>
>   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
>     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
>   </ImportGroup>
>   <PropertyGroup Label="UserMacros" />
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
>     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(ProjectDir)\src\transport\;$(ProjectDir)..\..\..\boost_1_62_0\;$(ProjectDir)..\..\..\boost_1_62_0\include;$(THIRD_PARTY)\openssl\OpenSSL-Win32\include\;$(IncludePath)</IncludePath>
>   </PropertyGroup>
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
>     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(ProjectDir)\src\transport\;$(ProjectDir)..\..\..\boost_1_62_0\;$(ProjectDir)..\..\..\boost_1_62_0\include;$(THIRD_PARTY)\openssl\OpenSSL-Win32\include\;$(IncludePath)</IncludePath>
>   </PropertyGroup>
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
>     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(ProjectDir)\src\transport\;$(ProjectDir)..\..\..\boost_1_62_0\;$(ProjectDir)..\..\..\boost_1_62_0\include;$(THIRD_PARTY)\openssl\OpenSSL-Win32\include\;$(IncludePath)</IncludePath>
>   </PropertyGroup>
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
>     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(ProjectDir)\src\transport\;$(ProjectDir)..\..\..\boost_1_62_0\;$(ProjectDir)..\..\..\boost_1_62_0\include;$(THIRD_PARTY)\openssl\OpenSSL-Win32\include\;$(IncludePath)</IncludePath>
>   </PropertyGroup>
>   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
>     <ClCompile>
>       <PrecompiledHeader>NotUsing</PrecompiledHeader>
>       <WarningLevel>Level3</WarningLevel>
>       <Optimization>Disabled</Optimization>
>       <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;_LIB;%(PreprocessorDefinitions);_WINDOWS;HAVE_STRUCT_TIMESPEC</PreprocessorDefinitions>
>       <ForcedIncludeFiles>force_inc.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
>       <ProgramDataBaseFileName>$(IntDir)libthrift.pdb</ProgramDataBaseFileName>
>     </ClCompile>
>     <Link>
>       <SubSystem>Windows</SubSystem>
>       <GenerateDebugInformation>true</GenerateDebugInformation>
>     </Link>
>   </ItemDefinitionGroup>
>   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
>     <ClCompile>
>       <PrecompiledHeader>NotUsing</PrecompiledHeader>
>       <WarningLevel>Level3</WarningLevel>
>       <Optimization>Disabled</Optimization>
>       <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;_LIB;%(PreprocessorDefinitions);_WINDOWS;HAVE_STRUCT_TIMESPEC</PreprocessorDefinitions>
>       <ForcedIncludeFiles>force_inc.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
>     </ClCompile>
>     <Link>
>       <SubSystem>Windows</SubSystem>
>       <GenerateDebugInformation>true</GenerateDebugInformation>
>     </Link>
>   </ItemDefinitionGroup>
>   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
>     <ClCompile>
>       <WarningLevel>Level3</WarningLevel>
>       <PrecompiledHeader>NotUsing</PrecompiledHeader>
>       <Optimization>MaxSpeed</Optimization>
>       <FunctionLevelLinking>true</FunctionLevelLinking>
>       <IntrinsicFunctions>true</IntrinsicFunctions>
>       <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;_LIB;%(PreprocessorDefinitions);_WINDOWS;HAVE_STRUCT_TIMESPEC</PreprocessorDefinitions>
>       <ForcedIncludeFiles>force_inc.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
>       <ProgramDataBaseFileName>$(IntDir)libthrift.pdb</ProgramDataBaseFileName>
>     </ClCompile>
>     <Link>
>       <SubSystem>Windows</SubSystem>
>       <GenerateDebugInformation>true</GenerateDebugInformation>
>       <EnableCOMDATFolding>true</EnableCOMDATFolding>
>       <OptimizeReferences>true</OptimizeReferences>
>     </Link>
>   </ItemDefinitionGroup>
>   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
>     <ClCompile>
>       <WarningLevel>Level3</WarningLevel>
>       <PrecompiledHeader>NotUsing</PrecompiledHeader>
>       <Optimization>MaxSpeed</Optimization>
>       <FunctionLevelLinking>true</FunctionLevelLinking>
>       <IntrinsicFunctions>true</IntrinsicFunctions>
>       <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;_LIB;%(PreprocessorDefinitions);_WINDOWS;HAVE_STRUCT_TIMESPEC</PreprocessorDefinitions>
>       <ForcedIncludeFiles>force_inc.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
>     </ClCompile>
>     <Link>
>       <SubSystem>Windows</SubSystem>
>       <GenerateDebugInformation>true</GenerateDebugInformation>
>       <EnableCOMDATFolding>true</EnableCOMDATFolding>
>       <OptimizeReferences>true</OptimizeReferences>
>     </Link>
>   </ItemDefinitionGroup>
>   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
>   <ImportGroup Label="ExtensionTargets">
>   </ImportGroup>
1,182c1,182
< <?xml version="1.0" encoding="utf-8"?>
< <Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
<   <ItemGroup Label="ProjectConfigurations">
<     <ProjectConfiguration Include="Debug|Win32">
<       <Configuration>Debug</Configuration>
<       <Platform>Win32</Platform>
<     </ProjectConfiguration>
<     <ProjectConfiguration Include="Debug|x64">
<       <Configuration>Debug</Configuration>
<       <Platform>x64</Platform>
<     </ProjectConfiguration>
<     <ProjectConfiguration Include="Release|Win32">
<       <Configuration>Release</Configuration>
<       <Platform>Win32</Platform>
<     </ProjectConfiguration>
<     <ProjectConfiguration Include="Release|x64">
<       <Configuration>Release</Configuration>
<       <Platform>x64</Platform>
<     </ProjectConfiguration>
<   </ItemGroup>
<   <ItemGroup>
<     <ClCompile Include="src\async\TAsyncProtocolProcessor.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\async\TEvhttpClientChannel.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\async\TEvhttpServer.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\server\TNonblockingServer.cpp">
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<     </ClCompile>
<     <ClCompile Include="src\windows\StdAfx.cpp" />
<   </ItemGroup>
<   <ItemGroup>
<     <ClInclude Include="src\async\TAsyncProtocolProcessor.h" />
<     <ClInclude Include="src\async\TEvhttpClientChannel.h" />
<     <ClInclude Include="src\async\TEvhttpServer.h" />
<     <ClInclude Include="src\server\TNonblockingServer.h" />
<     <ClInclude Include="src\windows\config.h" />
<     <ClInclude Include="src\windows\force_inc.h" />
<     <ClInclude Include="src\windows\StdAfx.h" />
<     <ClInclude Include="src\windows\TargetVersion.h" />
<   </ItemGroup>
<   <PropertyGroup Label="Globals">
<     <ProjectGuid>{D8696CCE-7D46-4659-B432-91754A41DEB0}</ProjectGuid>
<     <Keyword>Win32Proj</Keyword>
<     <RootNamespace>libthriftnb</RootNamespace>
<   </PropertyGroup>
<   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
<   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
<     <ConfigurationType>StaticLibrary</ConfigurationType>
<     <UseDebugLibraries>true</UseDebugLibraries>
<     <CharacterSet>MultiByte</CharacterSet>
<   </PropertyGroup>
<   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
<     <ConfigurationType>StaticLibrary</ConfigurationType>
<     <UseDebugLibraries>true</UseDebugLibraries>
<     <CharacterSet>MultiByte</CharacterSet>
<   </PropertyGroup>
<   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
<     <ConfigurationType>StaticLibrary</ConfigurationType>
<     <UseDebugLibraries>false</UseDebugLibraries>
<     <WholeProgramOptimization>true</WholeProgramOptimization>
<     <CharacterSet>MultiByte</CharacterSet>
<   </PropertyGroup>
<   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
<     <ConfigurationType>StaticLibrary</ConfigurationType>
<     <UseDebugLibraries>false</UseDebugLibraries>
<     <WholeProgramOptimization>true</WholeProgramOptimization>
<     <CharacterSet>MultiByte</CharacterSet>
<   </PropertyGroup>
<   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
<   <ImportGroup Label="ExtensionSettings">
<   </ImportGroup>
<   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
<     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
<   </ImportGroup>
<   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
<     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
<   </ImportGroup>
<   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
<     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
<   </ImportGroup>
<   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
<     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
<   </ImportGroup>
<   <PropertyGroup Label="UserMacros" />
<   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
<     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(THIRD_PARTY)\boost\boost_1_47_0\include;$(THIRD_PARTY)\boost\boost_1_47_0\;$(THIRD_PARTY)\libevent\libevent-2.0.13-stable\WIN32-Code\;$(THIRD_PARTY)\libevent\libevent-2.0.13-stable\include;$(THIRD_PARTY)\libevent\libevent-2.0.13-stable\;$(IncludePath)</IncludePath>
<   </PropertyGroup>
<   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
<     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(THIRD_PARTY)\boost\boost_1_47_0\include;$(THIRD_PARTY)\boost\boost_1_47_0\;$(THIRD_PARTY)\libevent\libevent-2.0.13-stable\WIN32-Code\;$(THIRD_PARTY)\libevent\libevent-2.0.13-stable\include;$(THIRD_PARTY)\libevent\libevent-2.0.13-stable\;$(IncludePath)</IncludePath>
<   </PropertyGroup>
<   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
<     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(THIRD_PARTY)\boost\boost_1_47_0\include;$(THIRD_PARTY)\boost\boost_1_47_0\;$(THIRD_PARTY)\libevent\libevent-2.0.13-stable\WIN32-Code\;$(THIRD_PARTY)\libevent\libevent-2.0.13-stable\include;$(THIRD_PARTY)\libevent\libevent-2.0.13-stable\;$(IncludePath)</IncludePath>
<   </PropertyGroup>
<   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
<     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(THIRD_PARTY)\boost\boost_1_47_0\include;$(THIRD_PARTY)\boost\boost_1_47_0\;$(THIRD_PARTY)\libevent\libevent-2.0.13-stable\WIN32-Code\;$(THIRD_PARTY)\libevent\libevent-2.0.13-stable\include;$(THIRD_PARTY)\libevent\libevent-2.0.13-stable\;$(IncludePath)</IncludePath>
<   </PropertyGroup>
<   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
<     <ClCompile>
<       <PrecompiledHeader>
<       </PrecompiledHeader>
<       <WarningLevel>Level3</WarningLevel>
<       <Optimization>Disabled</Optimization>
<       <PreprocessorDefinitions>WIN32;HAVE_CONFIG_H;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <ForcedIncludeFiles>force_inc.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
<       <ProgramDataBaseFileName>$(IntDir)libthriftnb.pdb</ProgramDataBaseFileName>
<     </ClCompile>
<     <Link>
<       <SubSystem>Windows</SubSystem>
<       <GenerateDebugInformation>true</GenerateDebugInformation>
<     </Link>
<   </ItemDefinitionGroup>
<   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
<     <ClCompile>
<       <PrecompiledHeader>
<       </PrecompiledHeader>
<       <WarningLevel>Level3</WarningLevel>
<       <Optimization>Disabled</Optimization>
<       <PreprocessorDefinitions>WIN32;HAVE_CONFIG_H;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <ForcedIncludeFiles>force_inc.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
<     </ClCompile>
<     <Link>
<       <SubSystem>Windows</SubSystem>
<       <GenerateDebugInformation>true</GenerateDebugInformation>
<     </Link>
<   </ItemDefinitionGroup>
<   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
<     <ClCompile>
<       <WarningLevel>Level3</WarningLevel>
<       <PrecompiledHeader>
<       </PrecompiledHeader>
<       <Optimization>MaxSpeed</Optimization>
<       <FunctionLevelLinking>true</FunctionLevelLinking>
<       <IntrinsicFunctions>true</IntrinsicFunctions>
<       <PreprocessorDefinitions>WIN32;HAVE_CONFIG_H;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <ForcedIncludeFiles>force_inc.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
<       <ProgramDataBaseFileName>$(IntDir)libthriftnb.pdb</ProgramDataBaseFileName>
<     </ClCompile>
<     <Link>
<       <SubSystem>Windows</SubSystem>
<       <GenerateDebugInformation>true</GenerateDebugInformation>
<       <EnableCOMDATFolding>true</EnableCOMDATFolding>
<       <OptimizeReferences>true</OptimizeReferences>
<     </Link>
<   </ItemDefinitionGroup>
<   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
<     <ClCompile>
<       <WarningLevel>Level3</WarningLevel>
<       <PrecompiledHeader>
<       </PrecompiledHeader>
<       <Optimization>MaxSpeed</Optimization>
<       <FunctionLevelLinking>true</FunctionLevelLinking>
<       <IntrinsicFunctions>true</IntrinsicFunctions>
<       <PreprocessorDefinitions>WIN32;HAVE_CONFIG_H;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <ForcedIncludeFiles>force_inc.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
<     </ClCompile>
<     <Link>
<       <SubSystem>Windows</SubSystem>
<       <GenerateDebugInformation>true</GenerateDebugInformation>
<       <EnableCOMDATFolding>true</EnableCOMDATFolding>
<       <OptimizeReferences>true</OptimizeReferences>
<     </Link>
<   </ItemDefinitionGroup>
<   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
<   <ImportGroup Label="ExtensionTargets">
<   </ImportGroup>
---
> <?xml version="1.0" encoding="utf-8"?>
> <Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
>   <ItemGroup Label="ProjectConfigurations">
>     <ProjectConfiguration Include="Debug|Win32">
>       <Configuration>Debug</Configuration>
>       <Platform>Win32</Platform>
>     </ProjectConfiguration>
>     <ProjectConfiguration Include="Debug|x64">
>       <Configuration>Debug</Configuration>
>       <Platform>x64</Platform>
>     </ProjectConfiguration>
>     <ProjectConfiguration Include="Release|Win32">
>       <Configuration>Release</Configuration>
>       <Platform>Win32</Platform>
>     </ProjectConfiguration>
>     <ProjectConfiguration Include="Release|x64">
>       <Configuration>Release</Configuration>
>       <Platform>x64</Platform>
>     </ProjectConfiguration>
>   </ItemGroup>
>   <ItemGroup>
>     <ClCompile Include="src\async\TAsioAsync.cpp" />
>     <ClCompile Include="src\async\TAsyncProtocolProcessor.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\async\TEvhttpClientChannel.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\async\TEvhttpServer.cpp">
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>     </ClCompile>
>     <ClCompile Include="src\server\TNonblockingServer.cpp" />
>     <ClCompile Include="src\windows\StdAfx.cpp" />
>   </ItemGroup>
>   <ItemGroup>
>     <ClInclude Include="src\async\TAsyncProtocolProcessor.h" />
>     <ClInclude Include="src\async\TEvhttpClientChannel.h" />
>     <ClInclude Include="src\async\TEvhttpServer.h" />
>     <ClInclude Include="src\server\TNonblockingServer.h" />
>     <ClInclude Include="src\windows\config.h" />
>     <ClInclude Include="src\windows\force_inc.h" />
>     <ClInclude Include="src\windows\StdAfx.h" />
>     <ClInclude Include="src\windows\TargetVersion.h" />
>   </ItemGroup>
>   <PropertyGroup Label="Globals">
>     <ProjectGuid>{D8696CCE-7D46-4659-B432-91754A41DEB0}</ProjectGuid>
>     <Keyword>Win32Proj</Keyword>
>     <RootNamespace>libthriftnb</RootNamespace>
>   </PropertyGroup>
>   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
>     <ConfigurationType>StaticLibrary</ConfigurationType>
>     <UseDebugLibraries>true</UseDebugLibraries>
>     <CharacterSet>MultiByte</CharacterSet>
>     <PlatformToolset>v140</PlatformToolset>
>   </PropertyGroup>
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
>     <ConfigurationType>StaticLibrary</ConfigurationType>
>     <UseDebugLibraries>true</UseDebugLibraries>
>     <CharacterSet>MultiByte</CharacterSet>
>     <PlatformToolset>v140</PlatformToolset>
>   </PropertyGroup>
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
>     <ConfigurationType>StaticLibrary</ConfigurationType>
>     <UseDebugLibraries>false</UseDebugLibraries>
>     <WholeProgramOptimization>true</WholeProgramOptimization>
>     <CharacterSet>MultiByte</CharacterSet>
>     <PlatformToolset>v140</PlatformToolset>
>   </PropertyGroup>
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
>     <ConfigurationType>StaticLibrary</ConfigurationType>
>     <UseDebugLibraries>false</UseDebugLibraries>
>     <WholeProgramOptimization>true</WholeProgramOptimization>
>     <CharacterSet>MultiByte</CharacterSet>
>     <PlatformToolset>v140</PlatformToolset>
>   </PropertyGroup>
>   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
>   <ImportGroup Label="ExtensionSettings">
>   </ImportGroup>
>   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
>     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
>   </ImportGroup>
>   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
>     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
>   </ImportGroup>
>   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
>     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
>   </ImportGroup>
>   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
>     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
>   </ImportGroup>
>   <PropertyGroup Label="UserMacros" />
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
>     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(ProjectDir)..\..\..\boost_1_62_0\include\;$(ProjectDir)..\..\..\boost_1_62_0\;$(ProjectDir)..\..\..\libevent-2.0.22\;$(ProjectDir)..\..\..\libevent-2.0.22\include\;$(ProjectDir)..\..\..\libevent-2.0.22\WIN32-Code\;$(IncludePath)</IncludePath>
>   </PropertyGroup>
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
>     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(ProjectDir)..\..\..\boost_1_62_0\include\;$(ProjectDir)..\..\..\boost_1_62_0\;$(ProjectDir)..\..\..\libevent-2.0.22\;$(ProjectDir)..\..\..\libevent-2.0.22\include\;$(ProjectDir)..\..\..\libevent-2.0.22\WIN32-Code\;$(IncludePath)</IncludePath>
>   </PropertyGroup>
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
>     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(ProjectDir)..\..\..\boost_1_62_0\include\;$(ProjectDir)..\..\..\boost_1_62_0\;$(ProjectDir)..\..\..\libevent-2.0.22\;$(ProjectDir)..\..\..\libevent-2.0.22\include\;$(ProjectDir)..\..\..\libevent-2.0.22\WIN32-Code\;$(IncludePath)</IncludePath>
>   </PropertyGroup>
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
>     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(ProjectDir)..\..\..\boost_1_62_0\include\;$(ProjectDir)..\..\..\boost_1_62_0\;$(ProjectDir)..\..\..\libevent-2.0.22\;$(ProjectDir)..\..\..\libevent-2.0.22\include\;$(ProjectDir)..\..\..\libevent-2.0.22\WIN32-Code\;$(IncludePath)</IncludePath>
>   </PropertyGroup>
>   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
>     <ClCompile>
>       <PrecompiledHeader>
>       </PrecompiledHeader>
>       <WarningLevel>Level3</WarningLevel>
>       <Optimization>Disabled</Optimization>
>       <PreprocessorDefinitions>WIN32;HAVE_CONFIG_H;_WINDOWS;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <ForcedIncludeFiles>force_inc.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
>       <ProgramDataBaseFileName>$(IntDir)libthriftnb.pdb</ProgramDataBaseFileName>
>     </ClCompile>
>     <Link>
>       <SubSystem>Windows</SubSystem>
>       <GenerateDebugInformation>true</GenerateDebugInformation>
>     </Link>
>   </ItemDefinitionGroup>
>   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
>     <ClCompile>
>       <PrecompiledHeader>
>       </PrecompiledHeader>
>       <WarningLevel>Level3</WarningLevel>
>       <Optimization>Disabled</Optimization>
>       <PreprocessorDefinitions>WIN32;HAVE_CONFIG_H;_WINDOWS;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <ForcedIncludeFiles>force_inc.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
>     </ClCompile>
>     <Link>
>       <SubSystem>Windows</SubSystem>
>       <GenerateDebugInformation>true</GenerateDebugInformation>
>     </Link>
>   </ItemDefinitionGroup>
>   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
>     <ClCompile>
>       <WarningLevel>Level3</WarningLevel>
>       <PrecompiledHeader>
>       </PrecompiledHeader>
>       <Optimization>MaxSpeed</Optimization>
>       <FunctionLevelLinking>true</FunctionLevelLinking>
>       <IntrinsicFunctions>true</IntrinsicFunctions>
>       <PreprocessorDefinitions>WIN32;HAVE_CONFIG_H;_WINDOWS;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <ForcedIncludeFiles>force_inc.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
>       <ProgramDataBaseFileName>$(IntDir)libthriftnb.pdb</ProgramDataBaseFileName>
>     </ClCompile>
>     <Link>
>       <SubSystem>Windows</SubSystem>
>       <GenerateDebugInformation>true</GenerateDebugInformation>
>       <EnableCOMDATFolding>true</EnableCOMDATFolding>
>       <OptimizeReferences>true</OptimizeReferences>
>     </Link>
>   </ItemDefinitionGroup>
>   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
>     <ClCompile>
>       <WarningLevel>Level3</WarningLevel>
>       <PrecompiledHeader>
>       </PrecompiledHeader>
>       <Optimization>MaxSpeed</Optimization>
>       <FunctionLevelLinking>true</FunctionLevelLinking>
>       <IntrinsicFunctions>true</IntrinsicFunctions>
>       <PreprocessorDefinitions>WIN32;HAVE_CONFIG_H;_WINDOWS;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <ForcedIncludeFiles>force_inc.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
>     </ClCompile>
>     <Link>
>       <SubSystem>Windows</SubSystem>
>       <GenerateDebugInformation>true</GenerateDebugInformation>
>       <EnableCOMDATFolding>true</EnableCOMDATFolding>
>       <OptimizeReferences>true</OptimizeReferences>
>     </Link>
>   </ItemDefinitionGroup>
>   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
>   <ImportGroup Label="ExtensionTargets">
>   </ImportGroup>
1,217c1,220
< /*
<  * Licensed to the Apache Software Foundation (ASF) under one
<  * or more contributor license agreements. See the NOTICE file
<  * distributed with this work for additional information
<  * regarding copyright ownership. The ASF licenses this file
<  * to you under the Apache License, Version 2.0 (the
<  * "License"); you may not use this file except in compliance
<  * with the License. You may obtain a copy of the License at
<  *
<  *   http://www.apache.org/licenses/LICENSE-2.0
<  *
<  * Unless required by applicable law or agreed to in writing,
<  * software distributed under the License is distributed on an
<  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
<  * KIND, either express or implied. See the License for the
<  * specific language governing permissions and limitations
<  * under the License.
<  */
< 
< #ifndef _THRIFT_THRIFT_H_
< #define _THRIFT_THRIFT_H_ 1
< 
< #ifdef _WIN32
< #include "windows/config.h"
< #endif
< 
< #ifdef HAVE_CONFIG_H
< #include "config.h"
< #endif
< #include <stdio.h>
< #include <assert.h>
< 
< #include <sys/types.h>
< #ifdef HAVE_NETINET_IN_H
< #include <netinet/in.h>
< #endif
< #ifdef HAVE_INTTYPES_H
< #include <inttypes.h>
< #endif
< 
< /**
<  * CONTRAIL-CUSTOM
<  */
< #include <netinet/in.h>
< #include <sys/socket.h>
< 
< #include <string>
< #include <map>
< #include <list>
< #include <set>
< #include <vector>
< #include <exception>
< #include <typeinfo>
< 
< #include <boost/utility/enable_if.hpp>
< #include <boost/type_traits/is_convertible.hpp>
< 
< #include "TLogging.h"
< 
< /**
<  * Helper macros to allow function overloading even when using
<  * boost::shared_ptr.
<  *
<  * shared_ptr makes overloading really annoying, since shared_ptr defines
<  * constructor methods to allow one shared_ptr type to be constructed from any
<  * other shared_ptr type.  (Even if it would be a compile error to actually try
<  * to instantiate the constructor.)  These macros add an extra argument to the
<  * function to cause it to only be instantiated if a pointer of type T is
<  * convertible to a pointer of type U.
<  *
<  * THRIFT_OVERLOAD_IF should be used in function declarations.
<  * THRIFT_OVERLOAD_IF_DEFN should be used in the function definition, if it is
<  * defined separately from where it is declared.
<  */
< #define THRIFT_OVERLOAD_IF_DEFN(T, Y) \
<   typename ::boost::enable_if<typename ::boost::is_convertible<T*, Y*>::type, \
<                               void*>::type
< 
< #define THRIFT_OVERLOAD_IF(T, Y) \
<   THRIFT_OVERLOAD_IF_DEFN(T, Y) = NULL
< 
< namespace apache { namespace thrift {
< 
< class TEnumIterator : public std::iterator<std::forward_iterator_tag, std::pair<int, const char*> > {
<  public:
<   TEnumIterator(int n,
<                 int* enums,
<                 const char** names) :
<       ii_(0), n_(n), enums_(enums), names_(names) {
<   }
< 
<   int operator ++() {
<     return ++ii_;
<   }
< 
<   bool operator !=(const TEnumIterator& end) {
<     assert(end.n_ == -1);
<     return (ii_ != n_);
<   }
< 
<   std::pair<int, const char*> operator*() const {
<     return std::make_pair(enums_[ii_], names_[ii_]);
<   }
< 
<  private:
<   int ii_;
<   const int n_;
<   int* enums_;
<   const char** names_;
< };
< 
< class TOutput {
<  public:
<   TOutput() : f_(&errorTimeWrapper) {}
< 
<   inline void setOutputFunction(void (*function)(const char *)){
<     f_ = function;
<   }
< 
<   inline void operator()(const char *message){
<     f_(message);
<   }
< 
<   // It is important to have a const char* overload here instead of
<   // just the string version, otherwise errno could be corrupted
<   // if there is some problem allocating memory when constructing
<   // the string.
<   void perror(const char *message, int errno_copy);
<   inline void perror(const std::string &message, int errno_copy) {
<     perror(message.c_str(), errno_copy);
<   }
< 
<   void printf(const char *message, ...);
< 
<   inline static void errorTimeWrapper(const char* msg) {
<     time_t now;
<     char dbgtime[26];
<     time(&now);
<     ctime_r(&now, dbgtime);
<     dbgtime[24] = 0;
<     fprintf(stderr, "Thrift: %s %s\n", dbgtime, msg);
<   }
< 
<   /** Just like strerror_r but returns a C++ string object. */
<   static std::string strerror_s(int errno_copy);
< 
<  private:
<   void (*f_)(const char *);
< };
< 
< extern TOutput GlobalOutput;
< 
< class TException : public std::exception {
<  public:
<   TException():
<     message_() {}
< 
<   TException(const std::string& message) :
<     message_(message) {}
< 
<   virtual ~TException() throw() {}
< 
<   virtual const char* what() const throw() {
<     if (message_.empty()) {
<       return "Default TException.";
<     } else {
<       return message_.c_str();
<     }
<   }
< 
<  protected:
<   std::string message_;
< 
< };
< 
< 
< // Forward declare this structure used by TDenseProtocol
< namespace reflection { namespace local {
< struct TypeSpec;
< }}
< 
< class TDelayedException {
<  public:
<   template <class E> static TDelayedException* delayException(const E& e);
<   virtual void throw_it() = 0;
<   virtual ~TDelayedException() {};
< };
< 
< template <class E> class TExceptionWrapper : public TDelayedException {
<  public:
<   TExceptionWrapper(const E& e) : e_(e) {}
<   virtual void throw_it() {
<     E temp(e_);
<     delete this;
<     throw temp;
<   }
<  private:
<   E e_;
< };
< 
< template <class E>
< TDelayedException* TDelayedException::delayException(const E& e) {
<   return new TExceptionWrapper<E>(e);
< }
< 
< #if T_GLOBAL_DEBUG_VIRTUAL > 1
< void profile_virtual_call(const std::type_info& info);
< void profile_generic_protocol(const std::type_info& template_type,
<                               const std::type_info& prot_type);
< void profile_print_info(FILE *f);
< void profile_print_info();
< void profile_write_pprof(FILE* gen_calls_f, FILE* virtual_calls_f);
< #endif
< 
< }} // apache::thrift
< 
< #endif // #ifndef _THRIFT_THRIFT_H_
---
> /*
>  * Licensed to the Apache Software Foundation (ASF) under one
>  * or more contributor license agreements. See the NOTICE file
>  * distributed with this work for additional information
>  * regarding copyright ownership. The ASF licenses this file
>  * to you under the Apache License, Version 2.0 (the
>  * "License"); you may not use this file except in compliance
>  * with the License. You may obtain a copy of the License at
>  *
>  *   http://www.apache.org/licenses/LICENSE-2.0
>  *
>  * Unless required by applicable law or agreed to in writing,
>  * software distributed under the License is distributed on an
>  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
>  * KIND, either express or implied. See the License for the
>  * specific language governing permissions and limitations
>  * under the License.
>  */
> 
> #ifndef _THRIFT_THRIFT_H_
> #define _THRIFT_THRIFT_H_ 1
> 
> #ifdef _WIN32
> #include "windows/config.h"
> #endif
> 
> #ifdef HAVE_CONFIG_H
> #include "config.h"
> #endif
> #include <stdio.h>
> #include <assert.h>
> 
> #include <sys/types.h>
> #ifdef HAVE_NETINET_IN_H
> #include <netinet/in.h>
> #endif
> #ifdef HAVE_INTTYPES_H
> #include <inttypes.h>
> #endif
> 
> /**
>  * CONTRAIL-CUSTOM
>  */
> 
> #ifndef _WINDOWS
> #include <netinet/in.h>
> #include <sys/socket.h>
> #endif
> 
> #include <string>
> #include <map>
> #include <list>
> #include <set>
> #include <vector>
> #include <exception>
> #include <typeinfo>
> 
> #include <boost/utility/enable_if.hpp>
> #include <boost/type_traits/is_convertible.hpp>
> 
> #include "TLogging.h"
> 
> /**
>  * Helper macros to allow function overloading even when using
>  * boost::shared_ptr.
>  *
>  * shared_ptr makes overloading really annoying, since shared_ptr defines
>  * constructor methods to allow one shared_ptr type to be constructed from any
>  * other shared_ptr type.  (Even if it would be a compile error to actually try
>  * to instantiate the constructor.)  These macros add an extra argument to the
>  * function to cause it to only be instantiated if a pointer of type T is
>  * convertible to a pointer of type U.
>  *
>  * THRIFT_OVERLOAD_IF should be used in function declarations.
>  * THRIFT_OVERLOAD_IF_DEFN should be used in the function definition, if it is
>  * defined separately from where it is declared.
>  */
> #define THRIFT_OVERLOAD_IF_DEFN(T, Y) \
>   typename ::boost::enable_if<typename ::boost::is_convertible<T*, Y*>::type, \
>                               void*>::type
> 
> #define THRIFT_OVERLOAD_IF(T, Y) \
>   THRIFT_OVERLOAD_IF_DEFN(T, Y) = NULL
> 
> namespace apache { namespace thrift {
> 
> class TEnumIterator : public std::iterator<std::forward_iterator_tag, std::pair<int, const char*> > {
>  public:
>   TEnumIterator(int n,
>                 int* enums,
>                 const char** names) :
>       ii_(0), n_(n), enums_(enums), names_(names) {
>   }
> 
>   int operator ++() {
>     return ++ii_;
>   }
> 
>   bool operator !=(const TEnumIterator& end) {
>     assert(end.n_ == -1);
>     return (ii_ != n_);
>   }
> 
>   std::pair<int, const char*> operator*() const {
>     return std::make_pair(enums_[ii_], names_[ii_]);
>   }
> 
>  private:
>   int ii_;
>   const int n_;
>   int* enums_;
>   const char** names_;
> };
> 
> class TOutput {
>  public:
>   TOutput() : f_(&errorTimeWrapper) {}
> 
>   inline void setOutputFunction(void (*function)(const char *)){
>     f_ = function;
>   }
> 
>   inline void operator()(const char *message){
>     f_(message);
>   }
> 
>   // It is important to have a const char* overload here instead of
>   // just the string version, otherwise errno could be corrupted
>   // if there is some problem allocating memory when constructing
>   // the string.
>   void perror(const char *message, int errno_copy);
>   inline void perror(const std::string &message, int errno_copy) {
>     perror(message.c_str(), errno_copy);
>   }
> 
>   void printf(const char *message, ...);
> 
>   inline static void errorTimeWrapper(const char* msg) {
>     time_t now;
>     char dbgtime[26];
>     time(&now);
>     ctime_r(&now, dbgtime);
>     dbgtime[24] = 0;
>     fprintf(stderr, "Thrift: %s %s\n", dbgtime, msg);
>   }
> 
>   /** Just like strerror_r but returns a C++ string object. */
>   static std::string strerror_s(int errno_copy);
> 
>  private:
>   void (*f_)(const char *);
> };
> 
> extern TOutput GlobalOutput;
> 
> class TException : public std::exception {
>  public:
>   TException():
>     message_() {}
> 
>   TException(const std::string& message) :
>     message_(message) {}
> 
>   virtual ~TException() throw() {}
> 
>   virtual const char* what() const throw() {
>     if (message_.empty()) {
>       return "Default TException.";
>     } else {
>       return message_.c_str();
>     }
>   }
> 
>  protected:
>   std::string message_;
> 
> };
> 
> 
> // Forward declare this structure used by TDenseProtocol
> namespace reflection { namespace local {
> struct TypeSpec;
> }}
> 
> class TDelayedException {
>  public:
>   template <class E> static TDelayedException* delayException(const E& e);
>   virtual void throw_it() = 0;
>   virtual ~TDelayedException() {};
> };
> 
> template <class E> class TExceptionWrapper : public TDelayedException {
>  public:
>   TExceptionWrapper(const E& e) : e_(e) {}
>   virtual void throw_it() {
>     E temp(e_);
>     delete this;
>     throw temp;
>   }
>  private:
>   E e_;
> };
> 
> template <class E>
> TDelayedException* TDelayedException::delayException(const E& e) {
>   return new TExceptionWrapper<E>(e);
> }
> 
> #if T_GLOBAL_DEBUG_VIRTUAL > 1
> void profile_virtual_call(const std::type_info& info);
> void profile_generic_protocol(const std::type_info& template_type,
>                               const std::type_info& prot_type);
> void profile_print_info(FILE *f);
> void profile_print_info();
> void profile_write_pprof(FILE* gen_calls_f, FILE* virtual_calls_f);
> #endif
> 
> }} // apache::thrift
> 
> #endif // #ifndef _THRIFT_THRIFT_H_
1,102c1,102
< /*
<  * Licensed to the Apache Software Foundation (ASF) under one
<  * or more contributor license agreements. See the NOTICE file
<  * distributed with this work for additional information
<  * regarding copyright ownership. The ASF licenses this file
<  * to you under the Apache License, Version 2.0 (the
<  * "License"); you may not use this file except in compliance
<  * with the License. You may obtain a copy of the License at
<  *
<  *   http://www.apache.org/licenses/LICENSE-2.0
<  *
<  * Unless required by applicable law or agreed to in writing,
<  * software distributed under the License is distributed on an
<  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
<  * KIND, either express or implied. See the License for the
<  * specific language governing permissions and limitations
<  * under the License.
<  */
< 
< #ifndef _THRIFT_CONCURRENCY_FUNCTION_RUNNER_H
< #define _THRIFT_CONCURRENCY_FUNCTION_RUNNER_H 1
< 
< #include <tr1/functional>
< #include "thrift/lib/cpp/concurrency/Thread.h"
< 
< namespace apache { namespace thrift { namespace concurrency {
< 
< /**
<  * Convenient implementation of Runnable that will execute arbitrary callbacks.
<  * Interfaces are provided to accept both a generic 'void(void)' callback, and
<  * a 'void* (void*)' pthread_create-style callback.
<  *
<  * Example use:
<  *  void* my_thread_main(void* arg);
<  *  shared_ptr<ThreadFactory> factory = ...;
<  *  // To create a thread that executes my_thread_main once:
<  *  shared_ptr<Thread> thread =
<  *    factory->newThread(shared_ptr<FunctionRunner>(
<  *      new FunctionRunner(my_thread_main, some_argument)));
<  *  thread->start();
<  *
<  *  bool A::foo();
<  *  A* a = new A();
<  *  // To create a thread that executes a.foo() every 100 milliseconds:
<  *  factory->newThread(shared_ptr<FunctionRunner>(
<  *    new FunctionRunner(std::tr1::bind(&A::foo, a), 100)))->start();
<  *
<  */
< 
< class FunctionRunner : public Runnable {
<  public:
<   // This is the type of callback 'pthread_create()' expects.
<   typedef void* (*PthreadFuncPtr)(void *arg);
<   // This a fully-generic void(void) callback for custom bindings.
<   typedef std::tr1::function<void()> VoidFunc;
< 
<   typedef std::tr1::function<bool()> BoolFunc;
< 
<   /**
<    * Given a 'pthread_create' style callback, this FunctionRunner will
<    * execute the given callback.  Note that the 'void*' return value is ignored.
<    */
<   FunctionRunner(PthreadFuncPtr func, void* arg)
<    : func_(std::tr1::bind(func, arg)), repFunc_(0)
<   { }
< 
<   /**
<    * Given a generic callback, this FunctionRunner will execute it.
<    */
<   FunctionRunner(const VoidFunc& cob)
<    : func_(cob), repFunc_(0)
<   { }
< 
<   /**
<    * Given a bool foo(...) type callback, FunctionRunner will execute
<    * the callback repeatedly with 'intervalMs' milliseconds between the calls,
<    * until it returns false. Note that the actual interval between calls will
<    * be intervalMs plus execution time of the callback.
<    */
<   FunctionRunner(const BoolFunc& cob, int intervalMs)
<    : func_(0), repFunc_(cob), intervalMs_(intervalMs)
<   { }
< 
<   void run() {
<     if (repFunc_) {
<       while(repFunc_()) {
<         usleep(intervalMs_*1000);
<       }
<     } else {
<       func_();
<     }
<   }
< 
<  private:
<   VoidFunc func_;
<   BoolFunc repFunc_;
<   int intervalMs_;
< };
< 
< }}} // apache::thrift::concurrency
< 
< #endif // #ifndef _THRIFT_CONCURRENCY_FUNCTION_RUNNER_H
---
> /*
>  * Licensed to the Apache Software Foundation (ASF) under one
>  * or more contributor license agreements. See the NOTICE file
>  * distributed with this work for additional information
>  * regarding copyright ownership. The ASF licenses this file
>  * to you under the Apache License, Version 2.0 (the
>  * "License"); you may not use this file except in compliance
>  * with the License. You may obtain a copy of the License at
>  *
>  *   http://www.apache.org/licenses/LICENSE-2.0
>  *
>  * Unless required by applicable law or agreed to in writing,
>  * software distributed under the License is distributed on an
>  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
>  * KIND, either express or implied. See the License for the
>  * specific language governing permissions and limitations
>  * under the License.
>  */
> 
> #ifndef _THRIFT_CONCURRENCY_FUNCTION_RUNNER_H
> #define _THRIFT_CONCURRENCY_FUNCTION_RUNNER_H 1
> 
> #include <tr1/functional>
> #include "thrift/lib/cpp/concurrency/Thread.h"
> 
> namespace apache { namespace thrift { namespace concurrency {
> 
> /**
>  * Convenient implementation of Runnable that will execute arbitrary callbacks.
>  * Interfaces are provided to accept both a generic 'void(void)' callback, and
>  * a 'void* (void*)' pthread_create-style callback.
>  *
>  * Example use:
>  *  void* my_thread_main(void* arg);
>  *  shared_ptr<ThreadFactory> factory = ...;
>  *  // To create a thread that executes my_thread_main once:
>  *  shared_ptr<Thread> thread =
>  *    factory->newThread(shared_ptr<FunctionRunner>(
>  *      new FunctionRunner(my_thread_main, some_argument)));
>  *  thread->start();
>  *
>  *  bool A::foo();
>  *  A* a = new A();
>  *  // To create a thread that executes a.foo() every 100 milliseconds:
>  *  factory->newThread(shared_ptr<FunctionRunner>(
>  *    new FunctionRunner(std::tr1::bind(&A::foo, a), 100)))->start();
>  *
>  */
> 
> class FunctionRunner : public Runnable {
>  public:
>   // This is the type of callback 'pthread_create()' expects.
>   typedef void* (*PthreadFuncPtr)(void *arg);
>   // This a fully-generic void(void) callback for custom bindings.
>   typedef std::tr1::function<void()> VoidFunc;
> 
>   typedef std::tr1::function<bool()> BoolFunc;
> 
>   /**
>    * Given a 'pthread_create' style callback, this FunctionRunner will
>    * execute the given callback.  Note that the 'void*' return value is ignored.
>    */
>   FunctionRunner(PthreadFuncPtr func, void* arg)
>    : func_(std::tr1::bind(func, arg)), repFunc_(0)
>   { }
> 
>   /**
>    * Given a generic callback, this FunctionRunner will execute it.
>    */
>   FunctionRunner(const VoidFunc& cob)
>    : func_(cob), repFunc_(0)
>   { }
> 
>   /**
>    * Given a bool foo(...) type callback, FunctionRunner will execute
>    * the callback repeatedly with 'intervalMs' milliseconds between the calls,
>    * until it returns false. Note that the actual interval between calls will
>    * be intervalMs plus execution time of the callback.
>    */
>   FunctionRunner(const BoolFunc& cob, int intervalMs)
>    : func_(0), repFunc_(cob), intervalMs_(intervalMs)
>   { }
> 
>   void run() {
>     if (repFunc_) {
>       while(repFunc_()) {
>         thrift_usleep(intervalMs_*1000);
>       }
>     } else {
>       func_();
>     }
>   }
> 
>  private:
>   VoidFunc func_;
>   BoolFunc repFunc_;
>   int intervalMs_;
> };
> 
> }}} // apache::thrift::concurrency
> 
> #endif // #ifndef _THRIFT_CONCURRENCY_FUNCTION_RUNNER_H
1,1122c1,1122
< /*
<  * Licensed to the Apache Software Foundation (ASF) under one
<  * or more contributor license agreements. See the NOTICE file
<  * distributed with this work for additional information
<  * regarding copyright ownership. The ASF licenses this file
<  * to you under the Apache License, Version 2.0 (the
<  * "License"); you may not use this file except in compliance
<  * with the License. You may obtain a copy of the License at
<  *
<  *   http://www.apache.org/licenses/LICENSE-2.0
<  *
<  * Unless required by applicable law or agreed to in writing,
<  * software distributed under the License is distributed on an
<  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
<  * KIND, either express or implied. See the License for the
<  * specific language governing permissions and limitations
<  * under the License.
<  */
< 
< #ifdef HAVE_CONFIG_H
< #include "config.h"
< #endif
< 
< #include "TFileTransport.h"
< #include "TTransportUtils.h"
< 
< #ifdef HAVE_PTHREAD_H
< #include <pthread.h>
< #endif
< #ifdef HAVE_SYS_TIME_H
< #include <sys/time.h>
< #else
< #include <time.h>
< #endif
< #include <fcntl.h>
< #include <errno.h>
< #ifdef HAVE_UNISTD_H
< #include <unistd.h>
< #endif
< #ifdef HAVE_STRINGS_H
< #include <strings.h>
< #endif
< #include <cstdlib>
< #include <cstring>
< #include <iostream>
< #ifdef HAVE_SYS_STAT_H
< #include <sys/stat.h>
< #endif
< 
< #ifdef _WIN32
< #include <io.h>
< #endif
< 
< namespace apache { namespace thrift { namespace transport {
< 
< using boost::scoped_ptr;
< using boost::shared_ptr;
< using namespace std;
< using namespace apache::thrift::protocol;
< using namespace apache::thrift::concurrency;
< 
< #ifndef HAVE_CLOCK_GETTIME
< 
< /**
<  * Fake clock_gettime for systems like darwin
<  *
<  */
< #define CLOCK_REALTIME 0
< static int clock_gettime(int clk_id /*ignored*/, struct timespec *tp) {
<   struct timeval now;
< 
<   int rv = gettimeofday(&now, NULL);
<   if (rv != 0) {
<     return rv;
<   }
< 
<   tp->tv_sec = now.tv_sec;
<   tp->tv_nsec = now.tv_usec * 1000;
<   return 0;
< }
< #endif
< 
< TFileTransport::TFileTransport(string path, bool readOnly)
<   : readState_()
<   , readBuff_(NULL)
<   , currentEvent_(NULL)
<   , readBuffSize_(DEFAULT_READ_BUFF_SIZE)
<   , readTimeout_(NO_TAIL_READ_TIMEOUT)
<   , chunkSize_(DEFAULT_CHUNK_SIZE)
<   , eventBufferSize_(DEFAULT_EVENT_BUFFER_SIZE)
<   , flushMaxUs_(DEFAULT_FLUSH_MAX_US)
<   , flushMaxBytes_(DEFAULT_FLUSH_MAX_BYTES)
<   , maxEventSize_(DEFAULT_MAX_EVENT_SIZE)
<   , maxCorruptedEvents_(DEFAULT_MAX_CORRUPTED_EVENTS)
<   , eofSleepTime_(DEFAULT_EOF_SLEEP_TIME_US)
<   , corruptedEventSleepTime_(DEFAULT_CORRUPTED_SLEEP_TIME_US)
<   , writerThreadIOErrorSleepTime_(DEFAULT_WRITER_THREAD_SLEEP_TIME_US)
<   , writerThreadId_(0)
<   , dequeueBuffer_(NULL)
<   , enqueueBuffer_(NULL)
<   , notFull_(&mutex_)
<   , notEmpty_(&mutex_)
<   , closing_(false)
<   , flushed_(&mutex_)
<   , forceFlush_(false)
<   , filename_(path)
<   , fd_(0)
<   , bufferAndThreadInitialized_(false)
<   , offset_(0)
<   , lastBadChunk_(0)
<   , numCorruptedEventsInChunk_(0)
<   , readOnly_(readOnly)
< {
<   openLogFile();
< }
< 
< void TFileTransport::resetOutputFile(int fd, string filename, int64_t offset) {
<   filename_ = filename;
<   offset_ = offset;
< 
<   // check if current file is still open
<   if (fd_ > 0) {
<     // flush any events in the queue
<     flush();
<     GlobalOutput.printf("error, current file (%s) not closed", filename_.c_str());
<     if (-1 == ::close(fd_)) {
<       int errno_copy = errno;
<       GlobalOutput.perror("TFileTransport: resetOutputFile() ::close() ", errno_copy);
<       throw TTransportException(TTransportException::UNKNOWN, "TFileTransport: error in file close", errno_copy);
<     } else {
<       //successfully closed fd
<       fd_ = 0;
<     }
<   }
< 
<   if (fd) {
<     fd_ = fd;
<   } else {
<     // open file if the input fd is 0
<     openLogFile();
<   }
< }
< 
< 
< TFileTransport::~TFileTransport() {
<   // flush the buffer if a writer thread is active
< #ifdef USE_BOOST_THREAD
<   if(writerThreadId_.get()) {
< #else
<   if (writerThreadId_ > 0) {
< #endif
<     // set state to closing
<     closing_ = true;
< 
<     // wake up the writer thread
<     // Since closing_ is true, it will attempt to flush all data, then exit.
< 	notEmpty_.notify();
< 
< #ifdef USE_BOOST_THREAD
<     writerThreadId_->join();
< 	writerThreadId_.reset();
< #else
<     pthread_join(writerThreadId_, NULL);
<     writerThreadId_ = 0;
< #endif
<   }
< 
<   if (dequeueBuffer_) {
<     delete dequeueBuffer_;
<     dequeueBuffer_ = NULL;
<   }
< 
<   if (enqueueBuffer_) {
<     delete enqueueBuffer_;
<     enqueueBuffer_ = NULL;
<   }
< 
<   if (readBuff_) {
<     delete[] readBuff_;
<     readBuff_ = NULL;
<   }
< 
<   if (currentEvent_) {
<     delete currentEvent_;
<     currentEvent_ = NULL;
<   }
< 
<   // close logfile
<   if (fd_ > 0) {
<     if(-1 == ::close(fd_)) {
<       GlobalOutput.perror("TFileTransport: ~TFileTransport() ::close() ", errno);
<     } else {
<       //successfully closed fd
<       fd_ = 0;
<     }
<   }
< }
< 
< bool TFileTransport::initBufferAndWriteThread() {
<   if (bufferAndThreadInitialized_) {
<     T_ERROR("%s", "Trying to double-init TFileTransport");
<     return false;
<   }
< 
< #ifdef USE_BOOST_THREAD
<   if(!writerThreadId_.get()) {
<     writerThreadId_ = std::auto_ptr<boost::thread>(new boost::thread(boost::bind(startWriterThread, (void *)this)));
<   }
< #else
<   if (writerThreadId_ == 0) {
<     if (pthread_create(&writerThreadId_, NULL, startWriterThread, (void *)this) != 0) {
<       T_ERROR("%s", "Could not create writer thread");
<       return false;
<     }
<   }
< #endif
< 
<   dequeueBuffer_ = new TFileTransportBuffer(eventBufferSize_);
<   enqueueBuffer_ = new TFileTransportBuffer(eventBufferSize_);
<   bufferAndThreadInitialized_ = true;
< 
<   return true;
< }
< 
< void TFileTransport::write(const uint8_t* buf, uint32_t len) {
<   if (readOnly_) {
<     throw TTransportException("TFileTransport: attempting to write to file opened readonly");
<   }
< 
<   enqueueEvent(buf, len);
< }
< 
< void TFileTransport::enqueueEvent(const uint8_t* buf, uint32_t eventLen) {
<   // can't enqueue more events if file is going to close
<   if (closing_) {
<     return;
<   }
< 
<   // make sure that event size is valid
<   if ( (maxEventSize_ > 0) && (eventLen > maxEventSize_) ) {
<     T_ERROR("msg size is greater than max event size: %u > %u\n", eventLen, maxEventSize_);
<     return;
<   }
< 
<   if (eventLen == 0) {
<     T_ERROR("%s", "cannot enqueue an empty event");
<     return;
<   }
< 
<   eventInfo* toEnqueue = new eventInfo();
<   toEnqueue->eventBuff_ = (uint8_t *)std::malloc((sizeof(uint8_t) * eventLen) + 4);
<   if (toEnqueue->eventBuff_ == NULL) {
<     delete toEnqueue;
<     throw std::bad_alloc();
<   }
<   // first 4 bytes is the event length
<   memcpy(toEnqueue->eventBuff_, (void*)(&eventLen), 4);
<   // actual event contents
<   memcpy(toEnqueue->eventBuff_ + 4, buf, eventLen);
<   toEnqueue->eventSize_ = eventLen + 4;
< 
<   // lock mutex
<   Guard g(mutex_);
< 
<   // make sure that enqueue buffer is initialized and writer thread is running
<   if (!bufferAndThreadInitialized_) {
<     if (!initBufferAndWriteThread()) {
<       delete toEnqueue;
<       return;
<     }
<   }
< 
<   // Can't enqueue while buffer is full
<   while (enqueueBuffer_->isFull()) {
< 	  notFull_.wait();
<   }
< 
<   // We shouldn't be trying to enqueue new data while a forced flush is
<   // requested.  (Otherwise the writer thread might not ever be able to finish
<   // the flush if more data keeps being enqueued.)
<   assert(!forceFlush_);
< 
<   // add to the buffer
<   if (!enqueueBuffer_->addEvent(toEnqueue)) {
<     delete toEnqueue;
<     return;
<   }
< 
<   // signal anybody who's waiting for the buffer to be non-empty
<   notEmpty_.notify();
< 
<   // this really should be a loop where it makes sure it got flushed
<   // because condition variables can get triggered by the os for no reason
<   // it is probably a non-factor for the time being
< }
< 
< bool TFileTransport::swapEventBuffers(struct timespec* deadline) {
<   bool swap;
<   Guard g(mutex_);
< 
<   if (!enqueueBuffer_->isEmpty()) {
<     swap = true;
<   } else if (closing_) {
<     // even though there is no data to write,
<     // return immediately if the transport is closing
<     swap = false;
<   } else {
<     if (deadline != NULL) {
<       // if we were handed a deadline time struct, do a timed wait
<       notEmpty_.waitForTime(deadline);
<     } else {
<       // just wait until the buffer gets an item
<       notEmpty_.wait();
<     }
< 
<     // could be empty if we timed out
<     swap = enqueueBuffer_->isEmpty();
<   }
< 
<   if (swap) {
<     TFileTransportBuffer *temp = enqueueBuffer_;
<     enqueueBuffer_ = dequeueBuffer_;
<     dequeueBuffer_ = temp;
<   }
< 
< 
<   if (swap) {
< 	  notFull_.notify();
<   }
< 
<   return swap;
< }
< 
< 
< void TFileTransport::writerThread() {
<   bool hasIOError = false;
< 
<   // open file if it is not open
<   if(!fd_) {
<     try {
<       openLogFile();
<     } catch (...) {
<       int errno_copy = errno;
<       GlobalOutput.perror("TFileTransport: writerThread() openLogFile() ", errno_copy);
<       fd_ = 0;
<       hasIOError = true;
<     }
<   }
< 
<   // set the offset to the correct value (EOF)
<   if (!hasIOError) {
<     try {
<       seekToEnd();
<       // throw away any partial events
<       offset_ += readState_.lastDispatchPtr_;
< #ifndef _WIN32
<       ftruncate(fd_, offset_);
< #else
<       _chsize_s(fd_, offset_);
< #endif
<       readState_.resetAllValues();
<     } catch (...) {
<       int errno_copy = errno;
<       GlobalOutput.perror("TFileTransport: writerThread() initialization ", errno_copy);
<       hasIOError = true;
<     }
<   }
< 
<   // Figure out the next time by which a flush must take place
<   struct timespec ts_next_flush;
<   getNextFlushTime(&ts_next_flush);
<   uint32_t unflushed = 0;
< 
<   while (1) {
<     // this will only be true when the destructor is being invoked
<     if (closing_) {
<       if (hasIOError) {
< #ifndef USE_BOOST_THREAD
< 		  pthread_exit(NULL);
< #else
< 		  return;
< #endif
<       }
< 
<       // Try to empty buffers before exit
<       if (enqueueBuffer_->isEmpty() && dequeueBuffer_->isEmpty()) {
< #ifndef _WIN32
<         fsync(fd_);
< #endif
<         if (-1 == ::close(fd_)) {
<           int errno_copy = errno;
<           GlobalOutput.perror("TFileTransport: writerThread() ::close() ", errno_copy);
<         } else {
<           //fd successfully closed
<           fd_ = 0;
<         }
< #ifndef USE_BOOST_THREAD
<         pthread_exit(NULL);
< #else
<         return;
< #endif
< 	  }
<     }
< 
<     if (swapEventBuffers(&ts_next_flush)) {
<       eventInfo* outEvent;
<       while (NULL != (outEvent = dequeueBuffer_->getNext())) {
<         // Remove an event from the buffer and write it out to disk. If there is any IO error, for instance,
<         // the output file is unmounted or deleted, then this event is dropped. However, the writer thread
<         // will: (1) sleep for a short while; (2) try to reopen the file; (3) if successful then start writing
<         // from the end.
< 
<         while (hasIOError) {
<           T_ERROR("TFileTransport: writer thread going to sleep for %d microseconds due to IO errors", writerThreadIOErrorSleepTime_);
<           usleep(writerThreadIOErrorSleepTime_);
<           if (closing_) {
< #ifndef USE_BOOST_THREAD
<             pthread_exit(NULL);
< #else
<             return;
< #endif
<           }
<           if (!fd_) {
<             ::close(fd_);
<             fd_ = 0;
<           }
<           try {
<             openLogFile();
<             seekToEnd();
<             unflushed = 0;
<             hasIOError = false;
<             T_LOG_OPER("TFileTransport: log file %s reopened by writer thread during error recovery", filename_.c_str());
<           } catch (...) {
<             T_ERROR("TFileTransport: unable to reopen log file %s during error recovery", filename_.c_str());
<           }
<         }
< 
<         // sanity check on event
<         if ((maxEventSize_ > 0) && (outEvent->eventSize_ > maxEventSize_)) {
<           T_ERROR("msg size is greater than max event size: %u > %u\n", outEvent->eventSize_, maxEventSize_);
<           continue;
<         }
< 
<         // If chunking is required, then make sure that msg does not cross chunk boundary
<         if ((outEvent->eventSize_ > 0) && (chunkSize_ != 0)) {
<           // event size must be less than chunk size
<           if (outEvent->eventSize_ > chunkSize_) {
<             T_ERROR("TFileTransport: event size(%u) > chunk size(%u): skipping event", outEvent->eventSize_, chunkSize_);
<             continue;
<           }
< 
<           int64_t chunk1 = offset_/chunkSize_;
<           int64_t chunk2 = (offset_ + outEvent->eventSize_ - 1)/chunkSize_;
< 
<           // if adding this event will cross a chunk boundary, pad the chunk with zeros
<           if (chunk1 != chunk2) {
<             // refetch the offset to keep in sync
<             offset_ = lseek(fd_, 0, SEEK_CUR);
<             int32_t padding = (int32_t)((offset_ / chunkSize_ + 1) * chunkSize_ - offset_);
< 
<             uint8_t* zeros = new uint8_t[padding];
<             memset(zeros, '\0', padding);
<             boost::scoped_array<uint8_t> array(zeros);
<             if (-1 == ::write(fd_, zeros, padding)) {
<               int errno_copy = errno;
<               GlobalOutput.perror("TFileTransport: writerThread() error while padding zeros ", errno_copy);
<               hasIOError = true;
<               continue;
<             }
<             unflushed += padding;
<             offset_ += padding;
<           }
<         }
< 
<         // write the dequeued event to the file
<         if (outEvent->eventSize_ > 0) {
<           if (-1 == ::write(fd_, outEvent->eventBuff_, outEvent->eventSize_)) {
<             int errno_copy = errno;
<             GlobalOutput.perror("TFileTransport: error while writing event ", errno_copy);
<             hasIOError = true;
<             continue;
<           }
<           unflushed += outEvent->eventSize_;
<           offset_ += outEvent->eventSize_;
<         }
<       }
<       dequeueBuffer_->reset();
<     }
< 
<     if (hasIOError) {
<       continue;
<     }
< 
<     // Local variable to cache the state of forceFlush_.
<     //
<     // We only want to check the value of forceFlush_ once each time around the
<     // loop.  If we check it more than once without holding the lock the entire
<     // time, it could have changed state in between.  This will result in us
<     // making inconsistent decisions.
<     bool forced_flush = false;
< 	{
<     Guard g(mutex_);
<     if (forceFlush_) {
<       if (!enqueueBuffer_->isEmpty()) {
<         // If forceFlush_ is true, we need to flush all available data.
<         // If enqueueBuffer_ is not empty, go back to the start of the loop to
<         // write it out.
<         //
<         // We know the main thread is waiting on forceFlush_ to be cleared,
<         // so no new events will be added to enqueueBuffer_ until we clear
<         // forceFlush_.  Therefore the next time around the loop enqueueBuffer_
<         // is guaranteed to be empty.  (I.e., we're guaranteed to make progress
<         // and clear forceFlush_ the next time around the loop.)
<         continue;
<       }
<       forced_flush = true;
< 	}
< 	}
< 
<     // determine if we need to perform an fsync
<     bool flush = false;
<     if (forced_flush || unflushed > flushMaxBytes_) {
<       flush = true;
<     } else {
<       struct timespec current_time;
<       clock_gettime(CLOCK_REALTIME, &current_time);
<       if (current_time.tv_sec > ts_next_flush.tv_sec ||
<           (current_time.tv_sec == ts_next_flush.tv_sec &&
<            current_time.tv_nsec > ts_next_flush.tv_nsec)) {
<         if (unflushed > 0) {
<           flush = true;
<         } else {
<           // If there is no new data since the last fsync,
<           // don't perform the fsync, but do reset the timer.
<           getNextFlushTime(&ts_next_flush);
<         }
<       }
<     }
< 
<     if (flush) {
<       // sync (force flush) file to disk
< #ifndef _WIN32
<       fsync(fd_);
< #endif
<       unflushed = 0;
<       getNextFlushTime(&ts_next_flush);
< 
<       // notify anybody waiting for flush completion
<       if (forced_flush) {
<         Guard g(mutex_);
<         forceFlush_ = false;
<         assert(enqueueBuffer_->isEmpty());
<         assert(dequeueBuffer_->isEmpty());
< 		flushed_.notifyAll();
<       }
<     }
<   }
< }
< 
< void TFileTransport::flush() {
<   // file must be open for writing for any flushing to take place
< #ifdef USE_BOOST_THREAD
<   if (!writerThreadId_.get()) {
<     return;
<   }
< #else
<   if (writerThreadId_ <= 0) {
<     return;
<   }
< #endif
<   // wait for flush to take place
<   Guard g(mutex_);
< 
<   // Indicate that we are requesting a flush
<   forceFlush_ = true;
<   // Wake up the writer thread so it will perform the flush immediately
<   notEmpty_.notify();
< 
<   while (forceFlush_) {
<     flushed_.wait();
<   }
< }
< 
< 
< uint32_t TFileTransport::readAll(uint8_t* buf, uint32_t len) {
<   uint32_t have = 0;
<   uint32_t get = 0;
< 
<   while (have < len) {
<     get = read(buf+have, len-have);
<     if (get <= 0) {
<       throw TEOFException();
<     }
<     have += get;
<   }
< 
<   return have;
< }
< 
< bool TFileTransport::peek() {
<   // check if there is an event ready to be read
<   if (!currentEvent_) {
<     currentEvent_ = readEvent();
<   }
< 
<   // did not manage to read an event from the file. This could have happened
<   // if the timeout expired or there was some other error
<   if (!currentEvent_) {
<     return false;
<   }
< 
<   // check if there is anything to read
<   return (currentEvent_->eventSize_ - currentEvent_->eventBuffPos_) > 0;
< }
< 
< uint32_t TFileTransport::read(uint8_t* buf, uint32_t len) {
<   // check if there an event is ready to be read
<   if (!currentEvent_) {
<     currentEvent_ = readEvent();
<   }
< 
<   // did not manage to read an event from the file. This could have happened
<   // if the timeout expired or there was some other error
<   if (!currentEvent_) {
<     return 0;
<   }
< 
<   // read as much of the current event as possible
<   int32_t remaining = currentEvent_->eventSize_ - currentEvent_->eventBuffPos_;
<   if (remaining <= (int32_t)len) {
<     // copy over anything thats remaining
<     if (remaining > 0) {
<       memcpy(buf,
<              currentEvent_->eventBuff_ + currentEvent_->eventBuffPos_,
<              remaining);
<     }
<     delete(currentEvent_);
<     currentEvent_ = NULL;
<     return remaining;
<   }
< 
<   // read as much as possible
<   memcpy(buf, currentEvent_->eventBuff_ + currentEvent_->eventBuffPos_, len);
<   currentEvent_->eventBuffPos_ += len;
<   return len;
< }
< 
< // note caller is responsible for freeing returned events
< eventInfo* TFileTransport::readEvent() {
<   int readTries = 0;
< 
<   if (!readBuff_) {
<     readBuff_ = new uint8_t[readBuffSize_];
<   }
< 
<   while (1) {
<     // read from the file if read buffer is exhausted
<     if (readState_.bufferPtr_ == readState_.bufferLen_) {
<       // advance the offset pointer
<       offset_ += readState_.bufferLen_;
<       readState_.bufferLen_ = ::read(fd_, readBuff_, readBuffSize_);
<       //       if (readState_.bufferLen_) {
<       //         T_DEBUG_L(1, "Amount read: %u (offset: %lu)", readState_.bufferLen_, offset_);
<       //       }
<       readState_.bufferPtr_ = 0;
<       readState_.lastDispatchPtr_ = 0;
< 
<       // read error
<       if (readState_.bufferLen_ == -1) {
<         readState_.resetAllValues();
<         GlobalOutput("TFileTransport: error while reading from file");
<         throw TTransportException("TFileTransport: error while reading from file");
<       } else if (readState_.bufferLen_ == 0) {  // EOF
<         // wait indefinitely if there is no timeout
<         if (readTimeout_ == TAIL_READ_TIMEOUT) {
<           usleep(eofSleepTime_);
<           continue;
<         } else if (readTimeout_ == NO_TAIL_READ_TIMEOUT) {
<           // reset state
<           readState_.resetState(0);
<           return NULL;
<         } else if (readTimeout_ > 0) {
<           // timeout already expired once
<           if (readTries > 0) {
<             readState_.resetState(0);
<             return NULL;
<           } else {
<             usleep(readTimeout_ * 1000);
<             readTries++;
<             continue;
<           }
<         }
<       }
<     }
< 
<     readTries = 0;
< 
<     // attempt to read an event from the buffer
<     while(readState_.bufferPtr_ < readState_.bufferLen_) {
<       if (readState_.readingSize_) {
<         if(readState_.eventSizeBuffPos_ == 0) {
<           if ( (offset_ + readState_.bufferPtr_)/chunkSize_ !=
<                ((offset_ + readState_.bufferPtr_ + 3)/chunkSize_)) {
<             // skip one byte towards chunk boundary
<             //            T_DEBUG_L(1, "Skipping a byte");
<             readState_.bufferPtr_++;
<             continue;
<           }
<         }
< 
<         readState_.eventSizeBuff_[readState_.eventSizeBuffPos_++] =
<           readBuff_[readState_.bufferPtr_++];
<         if (readState_.eventSizeBuffPos_ == 4) {
<           // 0 length event indicates padding
<           if (*((uint32_t *)(readState_.eventSizeBuff_)) == 0) {
<             //            T_DEBUG_L(1, "Got padding");
<             readState_.resetState(readState_.lastDispatchPtr_);
<             continue;
<           }
<           // got a valid event
<           readState_.readingSize_ = false;
<           if (readState_.event_) {
<             delete(readState_.event_);
<           }
<           readState_.event_ = new eventInfo();
<           readState_.event_->eventSize_ = *((uint32_t *)(readState_.eventSizeBuff_));
< 
<           // check if the event is corrupted and perform recovery if required
<           if (isEventCorrupted()) {
<             performRecovery();
<             // start from the top
<             break;
<           }
<         }
<       } else {
<         if (!readState_.event_->eventBuff_) {
<           readState_.event_->eventBuff_ = new uint8_t[readState_.event_->eventSize_];
<           readState_.event_->eventBuffPos_ = 0;
<         }
<         // take either the entire event or the remaining bytes in the buffer
<         int reclaimBuffer = min((uint32_t)(readState_.bufferLen_ - readState_.bufferPtr_),
<                                 readState_.event_->eventSize_ - readState_.event_->eventBuffPos_);
< 
<         // copy data from read buffer into event buffer
<         memcpy(readState_.event_->eventBuff_ + readState_.event_->eventBuffPos_,
<                readBuff_ + readState_.bufferPtr_,
<                reclaimBuffer);
< 
<         // increment position ptrs
<         readState_.event_->eventBuffPos_ += reclaimBuffer;
<         readState_.bufferPtr_ += reclaimBuffer;
< 
<         // check if the event has been read in full
<         if (readState_.event_->eventBuffPos_ == readState_.event_->eventSize_) {
<           // set the completed event to the current event
<           eventInfo* completeEvent = readState_.event_;
<           completeEvent->eventBuffPos_ = 0;
< 
<           readState_.event_ = NULL;
<           readState_.resetState(readState_.bufferPtr_);
< 
<           // exit criteria
<           return completeEvent;
<         }
<       }
<     }
< 
<   }
< }
< 
< bool TFileTransport::isEventCorrupted() {
<   // an error is triggered if:
<   if ( (maxEventSize_ > 0) &&  (readState_.event_->eventSize_ > maxEventSize_)) {
<     // 1. Event size is larger than user-speficied max-event size
<     T_ERROR("Read corrupt event. Event size(%u) greater than max event size (%u)",
<             readState_.event_->eventSize_, maxEventSize_);
<     return true;
<   } else if (readState_.event_->eventSize_ > chunkSize_) {
<     // 2. Event size is larger than chunk size
<     T_ERROR("Read corrupt event. Event size(%u) greater than chunk size (%u)",
<                readState_.event_->eventSize_, chunkSize_);
<     return true;
<   } else if( ((offset_ + readState_.bufferPtr_ - 4)/chunkSize_) !=
<              ((offset_ + readState_.bufferPtr_ + readState_.event_->eventSize_ - 1)/chunkSize_) ) {
<     // 3. size indicates that event crosses chunk boundary
<     T_ERROR("Read corrupt event. Event crosses chunk boundary. Event size:%u  Offset:%lu",
<             readState_.event_->eventSize_,
<             (offset_ + readState_.bufferPtr_ + 4));
< 
<     return true;
<   }
< 
<   return false;
< }
< 
< void TFileTransport::performRecovery() {
<   // perform some kickass recovery
<   uint32_t curChunk = getCurChunk();
<   if (lastBadChunk_ == curChunk) {
<     numCorruptedEventsInChunk_++;
<   } else {
<     lastBadChunk_ = curChunk;
<     numCorruptedEventsInChunk_ = 1;
<   }
< 
<   if (numCorruptedEventsInChunk_ < maxCorruptedEvents_) {
<     // maybe there was an error in reading the file from disk
<     // seek to the beginning of chunk and try again
<     seekToChunk(curChunk);
<   } else {
< 
<     // just skip ahead to the next chunk if we not already at the last chunk
<     if (curChunk != (getNumChunks() - 1)) {
<       seekToChunk(curChunk + 1);
<     } else if (readTimeout_ == TAIL_READ_TIMEOUT) {
<       // if tailing the file, wait until there is enough data to start
<       // the next chunk
<       while(curChunk == (getNumChunks() - 1)) {
<         usleep(DEFAULT_CORRUPTED_SLEEP_TIME_US);
<       }
<       seekToChunk(curChunk + 1);
<     } else {
<       // pretty hosed at this stage, rewind the file back to the last successful
<       // point and punt on the error
<       readState_.resetState(readState_.lastDispatchPtr_);
<       currentEvent_ = NULL;
<       char errorMsg[1024];
<       sprintf(errorMsg, "TFileTransport: log file corrupted at offset: %lu",
<               (offset_ + readState_.lastDispatchPtr_));
<               
<       GlobalOutput(errorMsg);
<       throw TTransportException(errorMsg);
<     }
<   }
< 
< }
< 
< void TFileTransport::seekToChunk(int32_t chunk) {
<   if (fd_ <= 0) {
<     throw TTransportException("File not open");
<   }
< 
<   int32_t numChunks = getNumChunks();
< 
<   // file is empty, seeking to chunk is pointless
<   if (numChunks == 0) {
<     return;
<   }
< 
<   // negative indicates reverse seek (from the end)
<   if (chunk < 0) {
<     chunk += numChunks;
<   }
< 
<   // too large a value for reverse seek, just seek to beginning
<   if (chunk < 0) {
<     T_DEBUG("%s", "Incorrect value for reverse seek. Seeking to beginning...");
<     chunk = 0;
<   }
< 
<   // cannot seek past EOF
<   bool seekToEnd = false;
<   off_t minEndOffset = 0;
<   if (chunk >= numChunks) {
<     T_DEBUG("%s", "Trying to seek past EOF. Seeking to EOF instead...");
<     seekToEnd = true;
<     chunk = numChunks - 1;
<     // this is the min offset to process events till
<     minEndOffset = lseek(fd_, 0, SEEK_END);
<   }
< 
<   off_t newOffset = off_t(chunk) * chunkSize_;
<   offset_ = lseek(fd_, newOffset, SEEK_SET);
<   readState_.resetAllValues();
<   currentEvent_ = NULL;
<   if (offset_ == -1) {
<     GlobalOutput("TFileTransport: lseek error in seekToChunk");
<     throw TTransportException("TFileTransport: lseek error in seekToChunk");
<   }
< 
<   // seek to EOF if user wanted to go to last chunk
<   if (seekToEnd) {
<     uint32_t oldReadTimeout = getReadTimeout();
<     setReadTimeout(NO_TAIL_READ_TIMEOUT);
<     // keep on reading unti the last event at point of seekChunk call
<     boost::scoped_ptr<eventInfo> event;
<     while ((offset_ + readState_.bufferPtr_) < minEndOffset) {
<       event.reset(readEvent());
<       if (event.get() == NULL) {
<         break;
<       }
<     }
<     setReadTimeout(oldReadTimeout);
<   }
< 
< }
< 
< void TFileTransport::seekToEnd() {
<   seekToChunk(getNumChunks());
< }
< 
< uint32_t TFileTransport::getNumChunks() {
<   if (fd_ <= 0) {
<     return 0;
<   }
< 
<   struct stat f_info;
<   int rv = fstat(fd_, &f_info);
< 
<   if (rv < 0) {
<     int errno_copy = errno;
<     throw TTransportException(TTransportException::UNKNOWN,
<                               "TFileTransport::getNumChunks() (fstat)",
<                               errno_copy);
<   }
< 
<   if (f_info.st_size > 0) {
<     return ((f_info.st_size)/chunkSize_) + 1;
<   }
< 
<   // empty file has no chunks
<   return 0;
< }
< 
< uint32_t TFileTransport::getCurChunk() {
<   return offset_/chunkSize_;
< }
< 
< // Utility Functions
< void TFileTransport::openLogFile() {
< #ifndef _WIN32
<   mode_t mode = readOnly_ ? S_IRUSR | S_IRGRP | S_IROTH : S_IRUSR | S_IWUSR| S_IRGRP | S_IROTH;
<   int flags = readOnly_ ? O_RDONLY : O_RDWR | O_CREAT | O_APPEND;
<   fd_ = ::open(filename_.c_str(), flags, mode);
< #else
<   int mode = readOnly_ ? _S_IREAD : _S_IREAD | _S_IWRITE;
<   int flags = readOnly_ ? _O_RDONLY : _O_RDWR | _O_CREAT | _O_APPEND;
<   fd_ = ::_open(filename_.c_str(), flags, mode);
< #endif
<   offset_ = 0;
< 
<   // make sure open call was successful
<   if(fd_ == -1) {
<     int errno_copy = errno;
<     GlobalOutput.perror("TFileTransport: openLogFile() ::open() file: " + filename_, errno_copy);
<     throw TTransportException(TTransportException::NOT_OPEN, filename_, errno_copy);
<   }
< 
< }
< 
< void TFileTransport::getNextFlushTime(struct timespec* ts_next_flush) {
<   clock_gettime(CLOCK_REALTIME, ts_next_flush);
<   ts_next_flush->tv_nsec += (flushMaxUs_ % 1000000) * 1000;
<   if (ts_next_flush->tv_nsec > 1000000000) {
<     ts_next_flush->tv_nsec -= 1000000000;
<     ts_next_flush->tv_sec += 1;
<   }
<   ts_next_flush->tv_sec += flushMaxUs_ / 1000000;
< }
< 
< TFileTransportBuffer::TFileTransportBuffer(uint32_t size)
<   : bufferMode_(WRITE)
<   , writePoint_(0)
<   , readPoint_(0)
<   , size_(size)
< {
<   buffer_ = new eventInfo*[size];
< }
< 
< TFileTransportBuffer::~TFileTransportBuffer() {
<   if (buffer_) {
<     for (uint32_t i = 0; i < writePoint_; i++) {
<       delete buffer_[i];
<     }
<     delete[] buffer_;
<     buffer_ = NULL;
<   }
< }
< 
< bool TFileTransportBuffer::addEvent(eventInfo *event) {
<   if (bufferMode_ == READ) {
<     GlobalOutput("Trying to write to a buffer in read mode");
<   }
<   if (writePoint_ < size_) {
<     buffer_[writePoint_++] = event;
<     return true;
<   } else {
<     // buffer is full
<     return false;
<   }
< }
< 
< eventInfo* TFileTransportBuffer::getNext() {
<   if (bufferMode_ == WRITE) {
<     bufferMode_ = READ;
<   }
<   if (readPoint_ < writePoint_) {
<     return buffer_[readPoint_++];
<   } else {
<     // no more entries
<     return NULL;
<   }
< }
< 
< void TFileTransportBuffer::reset() {
<   if (bufferMode_ == WRITE || writePoint_ > readPoint_) {
<     T_DEBUG("%s", "Resetting a buffer with unread entries");
<   }
<   // Clean up the old entries
<   for (uint32_t i = 0; i < writePoint_; i++) {
<     delete buffer_[i];
<   }
<   bufferMode_ = WRITE;
<   writePoint_ = 0;
<   readPoint_ = 0;
< }
< 
< bool TFileTransportBuffer::isFull() {
<   return writePoint_ == size_;
< }
< 
< bool TFileTransportBuffer::isEmpty() {
<   return writePoint_ == 0;
< }
< 
< TFileProcessor::TFileProcessor(shared_ptr<TProcessor> processor,
<                                shared_ptr<TProtocolFactory> protocolFactory,
<                                shared_ptr<TFileReaderTransport> inputTransport):
<   processor_(processor),
<   inputProtocolFactory_(protocolFactory),
<   outputProtocolFactory_(protocolFactory),
<   inputTransport_(inputTransport) {
< 
<   // default the output transport to a null transport (common case)
<   outputTransport_ = shared_ptr<TNullTransport>(new TNullTransport());
< }
< 
< TFileProcessor::TFileProcessor(shared_ptr<TProcessor> processor,
<                                shared_ptr<TProtocolFactory> inputProtocolFactory,
<                                shared_ptr<TProtocolFactory> outputProtocolFactory,
<                                shared_ptr<TFileReaderTransport> inputTransport):
<   processor_(processor),
<   inputProtocolFactory_(inputProtocolFactory),
<   outputProtocolFactory_(outputProtocolFactory),
<   inputTransport_(inputTransport) {
< 
<   // default the output transport to a null transport (common case)
<   outputTransport_ = shared_ptr<TNullTransport>(new TNullTransport());
< }
< 
< TFileProcessor::TFileProcessor(shared_ptr<TProcessor> processor,
<                                shared_ptr<TProtocolFactory> protocolFactory,
<                                shared_ptr<TFileReaderTransport> inputTransport,
<                                shared_ptr<TTransport> outputTransport):
<   processor_(processor),
<   inputProtocolFactory_(protocolFactory),
<   outputProtocolFactory_(protocolFactory),
<   inputTransport_(inputTransport),
<   outputTransport_(outputTransport) {}
< 
< void TFileProcessor::process(uint32_t numEvents, bool tail) {
<   shared_ptr<TProtocol> inputProtocol = inputProtocolFactory_->getProtocol(inputTransport_);
<   shared_ptr<TProtocol> outputProtocol = outputProtocolFactory_->getProtocol(outputTransport_);
< 
<   // set the read timeout to 0 if tailing is required
<   int32_t oldReadTimeout = inputTransport_->getReadTimeout();
<   if (tail) {
<     // save old read timeout so it can be restored
<     inputTransport_->setReadTimeout(TFileTransport::TAIL_READ_TIMEOUT);
<   }
< 
<   uint32_t numProcessed = 0;
<   while(1) {
<     // bad form to use exceptions for flow control but there is really
<     // no other way around it
<     try {
<       processor_->process(inputProtocol, outputProtocol, NULL);
<       numProcessed++;
<       if ( (numEvents > 0) && (numProcessed == numEvents)) {
<         return;
<       }
<     } catch (TEOFException& teof) {
<       if (!tail) {
<         break;
<       }
<     } catch (TException &te) {
<       cerr << te.what() << endl;
<       break;
<     }
<   }
< 
<   // restore old read timeout
<   if (tail) {
<     inputTransport_->setReadTimeout(oldReadTimeout);
<   }
< 
< }
< 
< void TFileProcessor::processChunk() {
<   shared_ptr<TProtocol> inputProtocol = inputProtocolFactory_->getProtocol(inputTransport_);
<   shared_ptr<TProtocol> outputProtocol = outputProtocolFactory_->getProtocol(outputTransport_);
< 
<   uint32_t curChunk = inputTransport_->getCurChunk();
< 
<   while(1) {
<     // bad form to use exceptions for flow control but there is really
<     // no other way around it
<     try {
<       processor_->process(inputProtocol, outputProtocol, NULL);
<       if (curChunk != inputTransport_->getCurChunk()) {
<         break;
<       }
<     } catch (TEOFException& teof) {
<       break;
<     } catch (TException &te) {
<       cerr << te.what() << endl;
<       break;
<     }
<   }
< }
< 
< }}} // apache::thrift::transport
---
> /*
>  * Licensed to the Apache Software Foundation (ASF) under one
>  * or more contributor license agreements. See the NOTICE file
>  * distributed with this work for additional information
>  * regarding copyright ownership. The ASF licenses this file
>  * to you under the Apache License, Version 2.0 (the
>  * "License"); you may not use this file except in compliance
>  * with the License. You may obtain a copy of the License at
>  *
>  *   http://www.apache.org/licenses/LICENSE-2.0
>  *
>  * Unless required by applicable law or agreed to in writing,
>  * software distributed under the License is distributed on an
>  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
>  * KIND, either express or implied. See the License for the
>  * specific language governing permissions and limitations
>  * under the License.
>  */
> 
> #ifdef HAVE_CONFIG_H
> #include "config.h"
> #endif
> 
> #include "TFileTransport.h"
> #include "TTransportUtils.h"
> 
> #ifdef HAVE_PTHREAD_H
> #include <pthread.h>
> #endif
> #ifdef HAVE_SYS_TIME_H
> #include <sys/time.h>
> #else
> #include <time.h>
> #endif
> #include <fcntl.h>
> #include <errno.h>
> #ifdef HAVE_UNISTD_H
> #include <unistd.h>
> #endif
> #ifdef HAVE_STRINGS_H
> #include <strings.h>
> #endif
> #include <cstdlib>
> #include <cstring>
> #include <iostream>
> #ifdef HAVE_SYS_STAT_H
> #include <sys/stat.h>
> #endif
> 
> #ifdef _WIN32
> #include <io.h>
> #endif
> 
> namespace apache { namespace thrift { namespace transport {
> 
> using boost::scoped_ptr;
> using boost::shared_ptr;
> using namespace std;
> using namespace apache::thrift::protocol;
> using namespace apache::thrift::concurrency;
> 
> #ifndef HAVE_CLOCK_GETTIME
> 
> /**
>  * Fake clock_gettime for systems like darwin
>  *
>  */
> #define CLOCK_REALTIME 0
> static int clock_gettime(int clk_id /*ignored*/, struct timespec *tp) {
>   struct timeval now;
> 
>   int rv = gettimeofday(&now, NULL);
>   if (rv != 0) {
>     return rv;
>   }
> 
>   tp->tv_sec = now.tv_sec;
>   tp->tv_nsec = now.tv_usec * 1000;
>   return 0;
> }
> #endif
> 
> TFileTransport::TFileTransport(string path, bool readOnly)
>   : readState_()
>   , readBuff_(NULL)
>   , currentEvent_(NULL)
>   , readBuffSize_(DEFAULT_READ_BUFF_SIZE)
>   , readTimeout_(NO_TAIL_READ_TIMEOUT)
>   , chunkSize_(DEFAULT_CHUNK_SIZE)
>   , eventBufferSize_(DEFAULT_EVENT_BUFFER_SIZE)
>   , flushMaxUs_(DEFAULT_FLUSH_MAX_US)
>   , flushMaxBytes_(DEFAULT_FLUSH_MAX_BYTES)
>   , maxEventSize_(DEFAULT_MAX_EVENT_SIZE)
>   , maxCorruptedEvents_(DEFAULT_MAX_CORRUPTED_EVENTS)
>   , eofSleepTime_(DEFAULT_EOF_SLEEP_TIME_US)
>   , corruptedEventSleepTime_(DEFAULT_CORRUPTED_SLEEP_TIME_US)
>   , writerThreadIOErrorSleepTime_(DEFAULT_WRITER_THREAD_SLEEP_TIME_US)
>   , writerThreadId_(0)
>   , dequeueBuffer_(NULL)
>   , enqueueBuffer_(NULL)
>   , notFull_(&mutex_)
>   , notEmpty_(&mutex_)
>   , closing_(false)
>   , flushed_(&mutex_)
>   , forceFlush_(false)
>   , filename_(path)
>   , fd_(0)
>   , bufferAndThreadInitialized_(false)
>   , offset_(0)
>   , lastBadChunk_(0)
>   , numCorruptedEventsInChunk_(0)
>   , readOnly_(readOnly)
> {
>   openLogFile();
> }
> 
> void TFileTransport::resetOutputFile(int fd, string filename, int64_t offset) {
>   filename_ = filename;
>   offset_ = offset;
> 
>   // check if current file is still open
>   if (fd_ > 0) {
>     // flush any events in the queue
>     flush();
>     GlobalOutput.printf("error, current file (%s) not closed", filename_.c_str());
>     if (-1 == ::close(fd_)) {
>       int errno_copy = errno;
>       GlobalOutput.perror("TFileTransport: resetOutputFile() ::close() ", errno_copy);
>       throw TTransportException(TTransportException::UNKNOWN, "TFileTransport: error in file close", errno_copy);
>     } else {
>       //successfully closed fd
>       fd_ = 0;
>     }
>   }
> 
>   if (fd) {
>     fd_ = fd;
>   } else {
>     // open file if the input fd is 0
>     openLogFile();
>   }
> }
> 
> 
> TFileTransport::~TFileTransport() {
>   // flush the buffer if a writer thread is active
> #ifdef USE_BOOST_THREAD
>   if(writerThreadId_.get()) {
> #else
>   if (writerThreadId_ > 0) {
> #endif
>     // set state to closing
>     closing_ = true;
> 
>     // wake up the writer thread
>     // Since closing_ is true, it will attempt to flush all data, then exit.
> 	notEmpty_.notify();
> 
> #ifdef USE_BOOST_THREAD
>     writerThreadId_->join();
> 	writerThreadId_.reset();
> #else
>     pthread_join(writerThreadId_, NULL);
>     writerThreadId_ = 0;
> #endif
>   }
> 
>   if (dequeueBuffer_) {
>     delete dequeueBuffer_;
>     dequeueBuffer_ = NULL;
>   }
> 
>   if (enqueueBuffer_) {
>     delete enqueueBuffer_;
>     enqueueBuffer_ = NULL;
>   }
> 
>   if (readBuff_) {
>     delete[] readBuff_;
>     readBuff_ = NULL;
>   }
> 
>   if (currentEvent_) {
>     delete currentEvent_;
>     currentEvent_ = NULL;
>   }
> 
>   // close logfile
>   if (fd_ > 0) {
>     if(-1 == ::close(fd_)) {
>       GlobalOutput.perror("TFileTransport: ~TFileTransport() ::close() ", errno);
>     } else {
>       //successfully closed fd
>       fd_ = 0;
>     }
>   }
> }
> 
> bool TFileTransport::initBufferAndWriteThread() {
>   if (bufferAndThreadInitialized_) {
>     T_ERROR("%s", "Trying to double-init TFileTransport");
>     return false;
>   }
> 
> #ifdef USE_BOOST_THREAD
>   if(!writerThreadId_.get()) {
>     writerThreadId_ = std::auto_ptr<boost::thread>(new boost::thread(boost::bind(startWriterThread, (void *)this)));
>   }
> #else
>   if (writerThreadId_ == 0) {
>     if (pthread_create(&writerThreadId_, NULL, startWriterThread, (void *)this) != 0) {
>       T_ERROR("%s", "Could not create writer thread");
>       return false;
>     }
>   }
> #endif
> 
>   dequeueBuffer_ = new TFileTransportBuffer(eventBufferSize_);
>   enqueueBuffer_ = new TFileTransportBuffer(eventBufferSize_);
>   bufferAndThreadInitialized_ = true;
> 
>   return true;
> }
> 
> void TFileTransport::write(const uint8_t* buf, uint32_t len) {
>   if (readOnly_) {
>     throw TTransportException("TFileTransport: attempting to write to file opened readonly");
>   }
> 
>   enqueueEvent(buf, len);
> }
> 
> void TFileTransport::enqueueEvent(const uint8_t* buf, uint32_t eventLen) {
>   // can't enqueue more events if file is going to close
>   if (closing_) {
>     return;
>   }
> 
>   // make sure that event size is valid
>   if ( (maxEventSize_ > 0) && (eventLen > maxEventSize_) ) {
>     T_ERROR("msg size is greater than max event size: %u > %u\n", eventLen, maxEventSize_);
>     return;
>   }
> 
>   if (eventLen == 0) {
>     T_ERROR("%s", "cannot enqueue an empty event");
>     return;
>   }
> 
>   eventInfo* toEnqueue = new eventInfo();
>   toEnqueue->eventBuff_ = (uint8_t *)std::malloc((sizeof(uint8_t) * eventLen) + 4);
>   if (toEnqueue->eventBuff_ == NULL) {
>     delete toEnqueue;
>     throw std::bad_alloc();
>   }
>   // first 4 bytes is the event length
>   memcpy(toEnqueue->eventBuff_, (void*)(&eventLen), 4);
>   // actual event contents
>   memcpy(toEnqueue->eventBuff_ + 4, buf, eventLen);
>   toEnqueue->eventSize_ = eventLen + 4;
> 
>   // lock mutex
>   Guard g(mutex_);
> 
>   // make sure that enqueue buffer is initialized and writer thread is running
>   if (!bufferAndThreadInitialized_) {
>     if (!initBufferAndWriteThread()) {
>       delete toEnqueue;
>       return;
>     }
>   }
> 
>   // Can't enqueue while buffer is full
>   while (enqueueBuffer_->isFull()) {
> 	  notFull_.wait();
>   }
> 
>   // We shouldn't be trying to enqueue new data while a forced flush is
>   // requested.  (Otherwise the writer thread might not ever be able to finish
>   // the flush if more data keeps being enqueued.)
>   assert(!forceFlush_);
> 
>   // add to the buffer
>   if (!enqueueBuffer_->addEvent(toEnqueue)) {
>     delete toEnqueue;
>     return;
>   }
> 
>   // signal anybody who's waiting for the buffer to be non-empty
>   notEmpty_.notify();
> 
>   // this really should be a loop where it makes sure it got flushed
>   // because condition variables can get triggered by the os for no reason
>   // it is probably a non-factor for the time being
> }
> 
> bool TFileTransport::swapEventBuffers(struct timespec* deadline) {
>   bool swap;
>   Guard g(mutex_);
> 
>   if (!enqueueBuffer_->isEmpty()) {
>     swap = true;
>   } else if (closing_) {
>     // even though there is no data to write,
>     // return immediately if the transport is closing
>     swap = false;
>   } else {
>     if (deadline != NULL) {
>       // if we were handed a deadline time struct, do a timed wait
>       notEmpty_.waitForTime(deadline);
>     } else {
>       // just wait until the buffer gets an item
>       notEmpty_.wait();
>     }
> 
>     // could be empty if we timed out
>     swap = enqueueBuffer_->isEmpty();
>   }
> 
>   if (swap) {
>     TFileTransportBuffer *temp = enqueueBuffer_;
>     enqueueBuffer_ = dequeueBuffer_;
>     dequeueBuffer_ = temp;
>   }
> 
> 
>   if (swap) {
> 	  notFull_.notify();
>   }
> 
>   return swap;
> }
> 
> 
> void TFileTransport::writerThread() {
>   bool hasIOError = false;
> 
>   // open file if it is not open
>   if(!fd_) {
>     try {
>       openLogFile();
>     } catch (...) {
>       int errno_copy = errno;
>       GlobalOutput.perror("TFileTransport: writerThread() openLogFile() ", errno_copy);
>       fd_ = 0;
>       hasIOError = true;
>     }
>   }
> 
>   // set the offset to the correct value (EOF)
>   if (!hasIOError) {
>     try {
>       seekToEnd();
>       // throw away any partial events
>       offset_ += readState_.lastDispatchPtr_;
> #ifndef _WIN32
>       ftruncate(fd_, offset_);
> #else
>       _chsize_s(fd_, offset_);
> #endif
>       readState_.resetAllValues();
>     } catch (...) {
>       int errno_copy = errno;
>       GlobalOutput.perror("TFileTransport: writerThread() initialization ", errno_copy);
>       hasIOError = true;
>     }
>   }
> 
>   // Figure out the next time by which a flush must take place
>   struct timespec ts_next_flush;
>   getNextFlushTime(&ts_next_flush);
>   uint32_t unflushed = 0;
> 
>   while (1) {
>     // this will only be true when the destructor is being invoked
>     if (closing_) {
>       if (hasIOError) {
> #ifndef USE_BOOST_THREAD
> 		  pthread_exit(NULL);
> #else
> 		  return;
> #endif
>       }
> 
>       // Try to empty buffers before exit
>       if (enqueueBuffer_->isEmpty() && dequeueBuffer_->isEmpty()) {
> #ifndef _WIN32
>         fsync(fd_);
> #endif
>         if (-1 == ::close(fd_)) {
>           int errno_copy = errno;
>           GlobalOutput.perror("TFileTransport: writerThread() ::close() ", errno_copy);
>         } else {
>           //fd successfully closed
>           fd_ = 0;
>         }
> #ifndef USE_BOOST_THREAD
>         pthread_exit(NULL);
> #else
>         return;
> #endif
> 	  }
>     }
> 
>     if (swapEventBuffers(&ts_next_flush)) {
>       eventInfo* outEvent;
>       while (NULL != (outEvent = dequeueBuffer_->getNext())) {
>         // Remove an event from the buffer and write it out to disk. If there is any IO error, for instance,
>         // the output file is unmounted or deleted, then this event is dropped. However, the writer thread
>         // will: (1) sleep for a short while; (2) try to reopen the file; (3) if successful then start writing
>         // from the end.
> 
>         while (hasIOError) {
>           T_ERROR("TFileTransport: writer thread going to sleep for %d microseconds due to IO errors", writerThreadIOErrorSleepTime_);
>           thrift_usleep(writerThreadIOErrorSleepTime_);
>           if (closing_) {
> #ifndef USE_BOOST_THREAD
>             pthread_exit(NULL);
> #else
>             return;
> #endif
>           }
>           if (!fd_) {
>             ::close(fd_);
>             fd_ = 0;
>           }
>           try {
>             openLogFile();
>             seekToEnd();
>             unflushed = 0;
>             hasIOError = false;
>             T_LOG_OPER("TFileTransport: log file %s reopened by writer thread during error recovery", filename_.c_str());
>           } catch (...) {
>             T_ERROR("TFileTransport: unable to reopen log file %s during error recovery", filename_.c_str());
>           }
>         }
> 
>         // sanity check on event
>         if ((maxEventSize_ > 0) && (outEvent->eventSize_ > maxEventSize_)) {
>           T_ERROR("msg size is greater than max event size: %u > %u\n", outEvent->eventSize_, maxEventSize_);
>           continue;
>         }
> 
>         // If chunking is required, then make sure that msg does not cross chunk boundary
>         if ((outEvent->eventSize_ > 0) && (chunkSize_ != 0)) {
>           // event size must be less than chunk size
>           if (outEvent->eventSize_ > chunkSize_) {
>             T_ERROR("TFileTransport: event size(%u) > chunk size(%u): skipping event", outEvent->eventSize_, chunkSize_);
>             continue;
>           }
> 
>           int64_t chunk1 = offset_/chunkSize_;
>           int64_t chunk2 = (offset_ + outEvent->eventSize_ - 1)/chunkSize_;
> 
>           // if adding this event will cross a chunk boundary, pad the chunk with zeros
>           if (chunk1 != chunk2) {
>             // refetch the offset to keep in sync
>             offset_ = lseek(fd_, 0, SEEK_CUR);
>             int32_t padding = (int32_t)((offset_ / chunkSize_ + 1) * chunkSize_ - offset_);
> 
>             uint8_t* zeros = new uint8_t[padding];
>             memset(zeros, '\0', padding);
>             boost::scoped_array<uint8_t> array(zeros);
>             if (-1 == ::write(fd_, zeros, padding)) {
>               int errno_copy = errno;
>               GlobalOutput.perror("TFileTransport: writerThread() error while padding zeros ", errno_copy);
>               hasIOError = true;
>               continue;
>             }
>             unflushed += padding;
>             offset_ += padding;
>           }
>         }
> 
>         // write the dequeued event to the file
>         if (outEvent->eventSize_ > 0) {
>           if (-1 == ::write(fd_, outEvent->eventBuff_, outEvent->eventSize_)) {
>             int errno_copy = errno;
>             GlobalOutput.perror("TFileTransport: error while writing event ", errno_copy);
>             hasIOError = true;
>             continue;
>           }
>           unflushed += outEvent->eventSize_;
>           offset_ += outEvent->eventSize_;
>         }
>       }
>       dequeueBuffer_->reset();
>     }
> 
>     if (hasIOError) {
>       continue;
>     }
> 
>     // Local variable to cache the state of forceFlush_.
>     //
>     // We only want to check the value of forceFlush_ once each time around the
>     // loop.  If we check it more than once without holding the lock the entire
>     // time, it could have changed state in between.  This will result in us
>     // making inconsistent decisions.
>     bool forced_flush = false;
> 	{
>     Guard g(mutex_);
>     if (forceFlush_) {
>       if (!enqueueBuffer_->isEmpty()) {
>         // If forceFlush_ is true, we need to flush all available data.
>         // If enqueueBuffer_ is not empty, go back to the start of the loop to
>         // write it out.
>         //
>         // We know the main thread is waiting on forceFlush_ to be cleared,
>         // so no new events will be added to enqueueBuffer_ until we clear
>         // forceFlush_.  Therefore the next time around the loop enqueueBuffer_
>         // is guaranteed to be empty.  (I.e., we're guaranteed to make progress
>         // and clear forceFlush_ the next time around the loop.)
>         continue;
>       }
>       forced_flush = true;
> 	}
> 	}
> 
>     // determine if we need to perform an fsync
>     bool flush = false;
>     if (forced_flush || unflushed > flushMaxBytes_) {
>       flush = true;
>     } else {
>       struct timespec current_time;
>       clock_gettime(CLOCK_REALTIME, &current_time);
>       if (current_time.tv_sec > ts_next_flush.tv_sec ||
>           (current_time.tv_sec == ts_next_flush.tv_sec &&
>            current_time.tv_nsec > ts_next_flush.tv_nsec)) {
>         if (unflushed > 0) {
>           flush = true;
>         } else {
>           // If there is no new data since the last fsync,
>           // don't perform the fsync, but do reset the timer.
>           getNextFlushTime(&ts_next_flush);
>         }
>       }
>     }
> 
>     if (flush) {
>       // sync (force flush) file to disk
> #ifndef _WIN32
>       fsync(fd_);
> #endif
>       unflushed = 0;
>       getNextFlushTime(&ts_next_flush);
> 
>       // notify anybody waiting for flush completion
>       if (forced_flush) {
>         Guard g(mutex_);
>         forceFlush_ = false;
>         assert(enqueueBuffer_->isEmpty());
>         assert(dequeueBuffer_->isEmpty());
> 		flushed_.notifyAll();
>       }
>     }
>   }
> }
> 
> void TFileTransport::flush() {
>   // file must be open for writing for any flushing to take place
> #ifdef USE_BOOST_THREAD
>   if (!writerThreadId_.get()) {
>     return;
>   }
> #else
>   if (writerThreadId_ <= 0) {
>     return;
>   }
> #endif
>   // wait for flush to take place
>   Guard g(mutex_);
> 
>   // Indicate that we are requesting a flush
>   forceFlush_ = true;
>   // Wake up the writer thread so it will perform the flush immediately
>   notEmpty_.notify();
> 
>   while (forceFlush_) {
>     flushed_.wait();
>   }
> }
> 
> 
> uint32_t TFileTransport::readAll(uint8_t* buf, uint32_t len) {
>   uint32_t have = 0;
>   uint32_t get = 0;
> 
>   while (have < len) {
>     get = read(buf+have, len-have);
>     if (get <= 0) {
>       throw TEOFException();
>     }
>     have += get;
>   }
> 
>   return have;
> }
> 
> bool TFileTransport::peek() {
>   // check if there is an event ready to be read
>   if (!currentEvent_) {
>     currentEvent_ = readEvent();
>   }
> 
>   // did not manage to read an event from the file. This could have happened
>   // if the timeout expired or there was some other error
>   if (!currentEvent_) {
>     return false;
>   }
> 
>   // check if there is anything to read
>   return (currentEvent_->eventSize_ - currentEvent_->eventBuffPos_) > 0;
> }
> 
> uint32_t TFileTransport::read(uint8_t* buf, uint32_t len) {
>   // check if there an event is ready to be read
>   if (!currentEvent_) {
>     currentEvent_ = readEvent();
>   }
> 
>   // did not manage to read an event from the file. This could have happened
>   // if the timeout expired or there was some other error
>   if (!currentEvent_) {
>     return 0;
>   }
> 
>   // read as much of the current event as possible
>   int32_t remaining = currentEvent_->eventSize_ - currentEvent_->eventBuffPos_;
>   if (remaining <= (int32_t)len) {
>     // copy over anything thats remaining
>     if (remaining > 0) {
>       memcpy(buf,
>              currentEvent_->eventBuff_ + currentEvent_->eventBuffPos_,
>              remaining);
>     }
>     delete(currentEvent_);
>     currentEvent_ = NULL;
>     return remaining;
>   }
> 
>   // read as much as possible
>   memcpy(buf, currentEvent_->eventBuff_ + currentEvent_->eventBuffPos_, len);
>   currentEvent_->eventBuffPos_ += len;
>   return len;
> }
> 
> // note caller is responsible for freeing returned events
> eventInfo* TFileTransport::readEvent() {
>   int readTries = 0;
> 
>   if (!readBuff_) {
>     readBuff_ = new uint8_t[readBuffSize_];
>   }
> 
>   while (1) {
>     // read from the file if read buffer is exhausted
>     if (readState_.bufferPtr_ == readState_.bufferLen_) {
>       // advance the offset pointer
>       offset_ += readState_.bufferLen_;
>       readState_.bufferLen_ = ::read(fd_, readBuff_, readBuffSize_);
>       //       if (readState_.bufferLen_) {
>       //         T_DEBUG_L(1, "Amount read: %u (offset: %lu)", readState_.bufferLen_, offset_);
>       //       }
>       readState_.bufferPtr_ = 0;
>       readState_.lastDispatchPtr_ = 0;
> 
>       // read error
>       if (readState_.bufferLen_ == -1) {
>         readState_.resetAllValues();
>         GlobalOutput("TFileTransport: error while reading from file");
>         throw TTransportException("TFileTransport: error while reading from file");
>       } else if (readState_.bufferLen_ == 0) {  // EOF
>         // wait indefinitely if there is no timeout
>         if (readTimeout_ == TAIL_READ_TIMEOUT) {
>           thrift_usleep(eofSleepTime_);
>           continue;
>         } else if (readTimeout_ == NO_TAIL_READ_TIMEOUT) {
>           // reset state
>           readState_.resetState(0);
>           return NULL;
>         } else if (readTimeout_ > 0) {
>           // timeout already expired once
>           if (readTries > 0) {
>             readState_.resetState(0);
>             return NULL;
>           } else {
>             thrift_usleep(readTimeout_ * 1000);
>             readTries++;
>             continue;
>           }
>         }
>       }
>     }
> 
>     readTries = 0;
> 
>     // attempt to read an event from the buffer
>     while(readState_.bufferPtr_ < readState_.bufferLen_) {
>       if (readState_.readingSize_) {
>         if(readState_.eventSizeBuffPos_ == 0) {
>           if ( (offset_ + readState_.bufferPtr_)/chunkSize_ !=
>                ((offset_ + readState_.bufferPtr_ + 3)/chunkSize_)) {
>             // skip one byte towards chunk boundary
>             //            T_DEBUG_L(1, "Skipping a byte");
>             readState_.bufferPtr_++;
>             continue;
>           }
>         }
> 
>         readState_.eventSizeBuff_[readState_.eventSizeBuffPos_++] =
>           readBuff_[readState_.bufferPtr_++];
>         if (readState_.eventSizeBuffPos_ == 4) {
>           // 0 length event indicates padding
>           if (*((uint32_t *)(readState_.eventSizeBuff_)) == 0) {
>             //            T_DEBUG_L(1, "Got padding");
>             readState_.resetState(readState_.lastDispatchPtr_);
>             continue;
>           }
>           // got a valid event
>           readState_.readingSize_ = false;
>           if (readState_.event_) {
>             delete(readState_.event_);
>           }
>           readState_.event_ = new eventInfo();
>           readState_.event_->eventSize_ = *((uint32_t *)(readState_.eventSizeBuff_));
> 
>           // check if the event is corrupted and perform recovery if required
>           if (isEventCorrupted()) {
>             performRecovery();
>             // start from the top
>             break;
>           }
>         }
>       } else {
>         if (!readState_.event_->eventBuff_) {
>           readState_.event_->eventBuff_ = new uint8_t[readState_.event_->eventSize_];
>           readState_.event_->eventBuffPos_ = 0;
>         }
>         // take either the entire event or the remaining bytes in the buffer
>         int reclaimBuffer = min((uint32_t)(readState_.bufferLen_ - readState_.bufferPtr_),
>                                 readState_.event_->eventSize_ - readState_.event_->eventBuffPos_);
> 
>         // copy data from read buffer into event buffer
>         memcpy(readState_.event_->eventBuff_ + readState_.event_->eventBuffPos_,
>                readBuff_ + readState_.bufferPtr_,
>                reclaimBuffer);
> 
>         // increment position ptrs
>         readState_.event_->eventBuffPos_ += reclaimBuffer;
>         readState_.bufferPtr_ += reclaimBuffer;
> 
>         // check if the event has been read in full
>         if (readState_.event_->eventBuffPos_ == readState_.event_->eventSize_) {
>           // set the completed event to the current event
>           eventInfo* completeEvent = readState_.event_;
>           completeEvent->eventBuffPos_ = 0;
> 
>           readState_.event_ = NULL;
>           readState_.resetState(readState_.bufferPtr_);
> 
>           // exit criteria
>           return completeEvent;
>         }
>       }
>     }
> 
>   }
> }
> 
> bool TFileTransport::isEventCorrupted() {
>   // an error is triggered if:
>   if ( (maxEventSize_ > 0) &&  (readState_.event_->eventSize_ > maxEventSize_)) {
>     // 1. Event size is larger than user-speficied max-event size
>     T_ERROR("Read corrupt event. Event size(%u) greater than max event size (%u)",
>             readState_.event_->eventSize_, maxEventSize_);
>     return true;
>   } else if (readState_.event_->eventSize_ > chunkSize_) {
>     // 2. Event size is larger than chunk size
>     T_ERROR("Read corrupt event. Event size(%u) greater than chunk size (%u)",
>                readState_.event_->eventSize_, chunkSize_);
>     return true;
>   } else if( ((offset_ + readState_.bufferPtr_ - 4)/chunkSize_) !=
>              ((offset_ + readState_.bufferPtr_ + readState_.event_->eventSize_ - 1)/chunkSize_) ) {
>     // 3. size indicates that event crosses chunk boundary
>     T_ERROR("Read corrupt event. Event crosses chunk boundary. Event size:%u  Offset:%lu",
>             readState_.event_->eventSize_,
>             (offset_ + readState_.bufferPtr_ + 4));
> 
>     return true;
>   }
> 
>   return false;
> }
> 
> void TFileTransport::performRecovery() {
>   // perform some kickass recovery
>   uint32_t curChunk = getCurChunk();
>   if (lastBadChunk_ == curChunk) {
>     numCorruptedEventsInChunk_++;
>   } else {
>     lastBadChunk_ = curChunk;
>     numCorruptedEventsInChunk_ = 1;
>   }
> 
>   if (numCorruptedEventsInChunk_ < maxCorruptedEvents_) {
>     // maybe there was an error in reading the file from disk
>     // seek to the beginning of chunk and try again
>     seekToChunk(curChunk);
>   } else {
> 
>     // just skip ahead to the next chunk if we not already at the last chunk
>     if (curChunk != (getNumChunks() - 1)) {
>       seekToChunk(curChunk + 1);
>     } else if (readTimeout_ == TAIL_READ_TIMEOUT) {
>       // if tailing the file, wait until there is enough data to start
>       // the next chunk
>       while(curChunk == (getNumChunks() - 1)) {
>         thrift_usleep(DEFAULT_CORRUPTED_SLEEP_TIME_US);
>       }
>       seekToChunk(curChunk + 1);
>     } else {
>       // pretty hosed at this stage, rewind the file back to the last successful
>       // point and punt on the error
>       readState_.resetState(readState_.lastDispatchPtr_);
>       currentEvent_ = NULL;
>       char errorMsg[1024];
>       sprintf(errorMsg, "TFileTransport: log file corrupted at offset: %lu",
>               (offset_ + readState_.lastDispatchPtr_));
>               
>       GlobalOutput(errorMsg);
>       throw TTransportException(errorMsg);
>     }
>   }
> 
> }
> 
> void TFileTransport::seekToChunk(int32_t chunk) {
>   if (fd_ <= 0) {
>     throw TTransportException("File not open");
>   }
> 
>   int32_t numChunks = getNumChunks();
> 
>   // file is empty, seeking to chunk is pointless
>   if (numChunks == 0) {
>     return;
>   }
> 
>   // negative indicates reverse seek (from the end)
>   if (chunk < 0) {
>     chunk += numChunks;
>   }
> 
>   // too large a value for reverse seek, just seek to beginning
>   if (chunk < 0) {
>     T_DEBUG("%s", "Incorrect value for reverse seek. Seeking to beginning...");
>     chunk = 0;
>   }
> 
>   // cannot seek past EOF
>   bool seekToEnd = false;
>   off_t minEndOffset = 0;
>   if (chunk >= numChunks) {
>     T_DEBUG("%s", "Trying to seek past EOF. Seeking to EOF instead...");
>     seekToEnd = true;
>     chunk = numChunks - 1;
>     // this is the min offset to process events till
>     minEndOffset = lseek(fd_, 0, SEEK_END);
>   }
> 
>   off_t newOffset = off_t(chunk) * chunkSize_;
>   offset_ = lseek(fd_, newOffset, SEEK_SET);
>   readState_.resetAllValues();
>   currentEvent_ = NULL;
>   if (offset_ == -1) {
>     GlobalOutput("TFileTransport: lseek error in seekToChunk");
>     throw TTransportException("TFileTransport: lseek error in seekToChunk");
>   }
> 
>   // seek to EOF if user wanted to go to last chunk
>   if (seekToEnd) {
>     uint32_t oldReadTimeout = getReadTimeout();
>     setReadTimeout(NO_TAIL_READ_TIMEOUT);
>     // keep on reading unti the last event at point of seekChunk call
>     boost::scoped_ptr<eventInfo> event;
>     while ((offset_ + readState_.bufferPtr_) < minEndOffset) {
>       event.reset(readEvent());
>       if (event.get() == NULL) {
>         break;
>       }
>     }
>     setReadTimeout(oldReadTimeout);
>   }
> 
> }
> 
> void TFileTransport::seekToEnd() {
>   seekToChunk(getNumChunks());
> }
> 
> uint32_t TFileTransport::getNumChunks() {
>   if (fd_ <= 0) {
>     return 0;
>   }
> 
>   struct stat f_info;
>   int rv = fstat(fd_, &f_info);
> 
>   if (rv < 0) {
>     int errno_copy = errno;
>     throw TTransportException(TTransportException::UNKNOWN,
>                               "TFileTransport::getNumChunks() (fstat)",
>                               errno_copy);
>   }
> 
>   if (f_info.st_size > 0) {
>     return ((f_info.st_size)/chunkSize_) + 1;
>   }
> 
>   // empty file has no chunks
>   return 0;
> }
> 
> uint32_t TFileTransport::getCurChunk() {
>   return offset_/chunkSize_;
> }
> 
> // Utility Functions
> void TFileTransport::openLogFile() {
> #ifndef _WIN32
>   mode_t mode = readOnly_ ? S_IRUSR | S_IRGRP | S_IROTH : S_IRUSR | S_IWUSR| S_IRGRP | S_IROTH;
>   int flags = readOnly_ ? O_RDONLY : O_RDWR | O_CREAT | O_APPEND;
>   fd_ = ::open(filename_.c_str(), flags, mode);
> #else
>   int mode = readOnly_ ? _S_IREAD : _S_IREAD | _S_IWRITE;
>   int flags = readOnly_ ? _O_RDONLY : _O_RDWR | _O_CREAT | _O_APPEND;
>   fd_ = ::_open(filename_.c_str(), flags, mode);
> #endif
>   offset_ = 0;
> 
>   // make sure open call was successful
>   if(fd_ == -1) {
>     int errno_copy = errno;
>     GlobalOutput.perror("TFileTransport: openLogFile() ::open() file: " + filename_, errno_copy);
>     throw TTransportException(TTransportException::NOT_OPEN, filename_, errno_copy);
>   }
> 
> }
> 
> void TFileTransport::getNextFlushTime(struct timespec* ts_next_flush) {
>   clock_gettime(CLOCK_REALTIME, ts_next_flush);
>   ts_next_flush->tv_nsec += (flushMaxUs_ % 1000000) * 1000;
>   if (ts_next_flush->tv_nsec > 1000000000) {
>     ts_next_flush->tv_nsec -= 1000000000;
>     ts_next_flush->tv_sec += 1;
>   }
>   ts_next_flush->tv_sec += flushMaxUs_ / 1000000;
> }
> 
> TFileTransportBuffer::TFileTransportBuffer(uint32_t size)
>   : bufferMode_(WRITE)
>   , writePoint_(0)
>   , readPoint_(0)
>   , size_(size)
> {
>   buffer_ = new eventInfo*[size];
> }
> 
> TFileTransportBuffer::~TFileTransportBuffer() {
>   if (buffer_) {
>     for (uint32_t i = 0; i < writePoint_; i++) {
>       delete buffer_[i];
>     }
>     delete[] buffer_;
>     buffer_ = NULL;
>   }
> }
> 
> bool TFileTransportBuffer::addEvent(eventInfo *event) {
>   if (bufferMode_ == READ) {
>     GlobalOutput("Trying to write to a buffer in read mode");
>   }
>   if (writePoint_ < size_) {
>     buffer_[writePoint_++] = event;
>     return true;
>   } else {
>     // buffer is full
>     return false;
>   }
> }
> 
> eventInfo* TFileTransportBuffer::getNext() {
>   if (bufferMode_ == WRITE) {
>     bufferMode_ = READ;
>   }
>   if (readPoint_ < writePoint_) {
>     return buffer_[readPoint_++];
>   } else {
>     // no more entries
>     return NULL;
>   }
> }
> 
> void TFileTransportBuffer::reset() {
>   if (bufferMode_ == WRITE || writePoint_ > readPoint_) {
>     T_DEBUG("%s", "Resetting a buffer with unread entries");
>   }
>   // Clean up the old entries
>   for (uint32_t i = 0; i < writePoint_; i++) {
>     delete buffer_[i];
>   }
>   bufferMode_ = WRITE;
>   writePoint_ = 0;
>   readPoint_ = 0;
> }
> 
> bool TFileTransportBuffer::isFull() {
>   return writePoint_ == size_;
> }
> 
> bool TFileTransportBuffer::isEmpty() {
>   return writePoint_ == 0;
> }
> 
> TFileProcessor::TFileProcessor(shared_ptr<TProcessor> processor,
>                                shared_ptr<TProtocolFactory> protocolFactory,
>                                shared_ptr<TFileReaderTransport> inputTransport):
>   processor_(processor),
>   inputProtocolFactory_(protocolFactory),
>   outputProtocolFactory_(protocolFactory),
>   inputTransport_(inputTransport) {
> 
>   // default the output transport to a null transport (common case)
>   outputTransport_ = shared_ptr<TNullTransport>(new TNullTransport());
> }
> 
> TFileProcessor::TFileProcessor(shared_ptr<TProcessor> processor,
>                                shared_ptr<TProtocolFactory> inputProtocolFactory,
>                                shared_ptr<TProtocolFactory> outputProtocolFactory,
>                                shared_ptr<TFileReaderTransport> inputTransport):
>   processor_(processor),
>   inputProtocolFactory_(inputProtocolFactory),
>   outputProtocolFactory_(outputProtocolFactory),
>   inputTransport_(inputTransport) {
> 
>   // default the output transport to a null transport (common case)
>   outputTransport_ = shared_ptr<TNullTransport>(new TNullTransport());
> }
> 
> TFileProcessor::TFileProcessor(shared_ptr<TProcessor> processor,
>                                shared_ptr<TProtocolFactory> protocolFactory,
>                                shared_ptr<TFileReaderTransport> inputTransport,
>                                shared_ptr<TTransport> outputTransport):
>   processor_(processor),
>   inputProtocolFactory_(protocolFactory),
>   outputProtocolFactory_(protocolFactory),
>   inputTransport_(inputTransport),
>   outputTransport_(outputTransport) {}
> 
> void TFileProcessor::process(uint32_t numEvents, bool tail) {
>   shared_ptr<TProtocol> inputProtocol = inputProtocolFactory_->getProtocol(inputTransport_);
>   shared_ptr<TProtocol> outputProtocol = outputProtocolFactory_->getProtocol(outputTransport_);
> 
>   // set the read timeout to 0 if tailing is required
>   int32_t oldReadTimeout = inputTransport_->getReadTimeout();
>   if (tail) {
>     // save old read timeout so it can be restored
>     inputTransport_->setReadTimeout(TFileTransport::TAIL_READ_TIMEOUT);
>   }
> 
>   uint32_t numProcessed = 0;
>   while(1) {
>     // bad form to use exceptions for flow control but there is really
>     // no other way around it
>     try {
>       processor_->process(inputProtocol, outputProtocol, NULL);
>       numProcessed++;
>       if ( (numEvents > 0) && (numProcessed == numEvents)) {
>         return;
>       }
>     } catch (TEOFException& teof) {
>       if (!tail) {
>         break;
>       }
>     } catch (TException &te) {
>       cerr << te.what() << endl;
>       break;
>     }
>   }
> 
>   // restore old read timeout
>   if (tail) {
>     inputTransport_->setReadTimeout(oldReadTimeout);
>   }
> 
> }
> 
> void TFileProcessor::processChunk() {
>   shared_ptr<TProtocol> inputProtocol = inputProtocolFactory_->getProtocol(inputTransport_);
>   shared_ptr<TProtocol> outputProtocol = outputProtocolFactory_->getProtocol(outputTransport_);
> 
>   uint32_t curChunk = inputTransport_->getCurChunk();
> 
>   while(1) {
>     // bad form to use exceptions for flow control but there is really
>     // no other way around it
>     try {
>       processor_->process(inputProtocol, outputProtocol, NULL);
>       if (curChunk != inputTransport_->getCurChunk()) {
>         break;
>       }
>     } catch (TEOFException& teof) {
>       break;
>     } catch (TException &te) {
>       cerr << te.what() << endl;
>       break;
>     }
>   }
> }
> 
> }}} // apache::thrift::transport
1,823c1,823
< /*
<  * Licensed to the Apache Software Foundation (ASF) under one
<  * or more contributor license agreements. See the NOTICE file
<  * distributed with this work for additional information
<  * regarding copyright ownership. The ASF licenses this file
<  * to you under the Apache License, Version 2.0 (the
<  * "License"); you may not use this file except in compliance
<  * with the License. You may obtain a copy of the License at
<  *
<  *   http://www.apache.org/licenses/LICENSE-2.0
<  *
<  * Unless required by applicable law or agreed to in writing,
<  * software distributed under the License is distributed on an
<  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
<  * KIND, either express or implied. See the License for the
<  * specific language governing permissions and limitations
<  * under the License.
<  */
< 
< #ifdef HAVE_CONFIG_H
< #include <config.h>
< #endif
< #include <cstring>
< #include <sstream>
< #ifdef HAVE_SYS_SOCKET_H
< #include <sys/socket.h>
< #endif
< #ifdef HAVE_SYS_UN_H
< #include <sys/un.h>
< #endif
< #ifdef HAVE_SYS_POLL_H
< #include <sys/poll.h>
< #endif
< #include <sys/types.h>
< #ifdef HAVE_ARPA_INET_H
< #include <arpa/inet.h>
< #endif
< #ifdef HAVE_NETINET_IN_H
< #include <netinet/in.h>
< #include <netinet/tcp.h>
< #endif
< #ifdef HAVE_UNISTD_H
< #include <unistd.h>
< #endif
< #include <errno.h>
< #include <fcntl.h>
< 
< #include "concurrency/Monitor.h"
< #include "TSocket.h"
< #include "TTransportException.h"
< 
< #ifndef SOCKOPT_CAST_T
< #   ifndef _WIN32
< #       define SOCKOPT_CAST_T void
< #   else
< #       define SOCKOPT_CAST_T char
< #   endif // _WIN32
< #endif
< 
< template<class T>
< inline const SOCKOPT_CAST_T* const_cast_sockopt(const T* v) {
<     return reinterpret_cast<const SOCKOPT_CAST_T*>(v);
< }
< 
< template<class T>
< inline SOCKOPT_CAST_T* cast_sockopt(T* v) {
<     return reinterpret_cast<SOCKOPT_CAST_T*>(v);
< }
< 
< namespace apache { namespace thrift { namespace transport {
< 
< using namespace std;
< 
< // Global var to track total socket sys calls
< uint32_t g_socket_syscalls = 0;
< 
< /**
<  * TSocket implementation.
<  *
<  */
< 
< TSocket::TSocket(string host, int port) :
<   host_(host),
<   port_(port),
<   path_(""),
<   socket_(-1),
<   connTimeout_(0),
<   sendTimeout_(0),
<   recvTimeout_(0),
<   lingerOn_(1),
<   lingerVal_(0),
<   noDelay_(1),
<   maxRecvRetries_(5) {
<   recvTimeval_.tv_sec = (int)(recvTimeout_/1000);
<   recvTimeval_.tv_usec = (int)((recvTimeout_%1000)*1000);
< }
< 
< TSocket::TSocket(string path) :
<   host_(""),
<   port_(0),
<   path_(path),
<   socket_(-1),
<   connTimeout_(0),
<   sendTimeout_(0),
<   recvTimeout_(0),
<   lingerOn_(1),
<   lingerVal_(0),
<   noDelay_(1),
<   maxRecvRetries_(5) {
<   recvTimeval_.tv_sec = (int)(recvTimeout_/1000);
<   recvTimeval_.tv_usec = (int)((recvTimeout_%1000)*1000);
<   cachedPeerAddr_.ipv4.sin_family = AF_UNSPEC;
< }
< 
< TSocket::TSocket() :
<   host_(""),
<   port_(0),
<   path_(""),
<   socket_(-1),
<   connTimeout_(0),
<   sendTimeout_(0),
<   recvTimeout_(0),
<   lingerOn_(1),
<   lingerVal_(0),
<   noDelay_(1),
<   maxRecvRetries_(5) {
<   recvTimeval_.tv_sec = (int)(recvTimeout_/1000);
<   recvTimeval_.tv_usec = (int)((recvTimeout_%1000)*1000);
<   cachedPeerAddr_.ipv4.sin_family = AF_UNSPEC;
< }
< 
< TSocket::TSocket(int socket) :
<   host_(""),
<   port_(0),
<   path_(""),
<   socket_(socket),
<   connTimeout_(0),
<   sendTimeout_(0),
<   recvTimeout_(0),
<   lingerOn_(1),
<   lingerVal_(0),
<   noDelay_(1),
<   maxRecvRetries_(5) {
<   recvTimeval_.tv_sec = (int)(recvTimeout_/1000);
<   recvTimeval_.tv_usec = (int)((recvTimeout_%1000)*1000);
<   cachedPeerAddr_.ipv4.sin_family = AF_UNSPEC;
< }
< 
< TSocket::~TSocket() {
<   close();
< }
< 
< bool TSocket::isOpen() {
<   return (socket_ >= 0);
< }
< 
< bool TSocket::peek() {
<   if (!isOpen()) {
<     return false;
<   }
<   uint8_t buf;
<   int r = recv(socket_, cast_sockopt(&buf), 1, MSG_PEEK);
<   if (r == -1) {
<     int errno_copy = errno;
<     #if defined __FreeBSD__ || defined __MACH__
<     /* shigin:
<      * freebsd returns -1 and ECONNRESET if socket was closed by 
<      * the other side
<      */
<     if (errno_copy == ECONNRESET)
<     {
<       close();
<       return false;
<     }
<     #endif
<     GlobalOutput.perror("TSocket::peek() recv() " + getSocketInfo(), errno_copy);
<     throw TTransportException(TTransportException::UNKNOWN, "recv()", errno_copy);
<   }
<   return (r > 0);
< }
< 
< void TSocket::openConnection(struct addrinfo *res) {
< 
<   if (isOpen()) {
<     return;
<   }
< 
<   if (! path_.empty()) {
<     socket_ = socket(PF_UNIX, SOCK_STREAM, IPPROTO_IP);
<   } else {
<     socket_ = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
<   }
< 
<   if (socket_ == -1) {
<     int errno_copy = errno;
<     GlobalOutput.perror("TSocket::open() socket() " + getSocketInfo(), errno_copy);
<     throw TTransportException(TTransportException::NOT_OPEN, "socket()", errno_copy);
<   }
< 
<   // Send timeout
<   if (sendTimeout_ > 0) {
<     setSendTimeout(sendTimeout_);
<   }
< 
<   // Recv timeout
<   if (recvTimeout_ > 0) {
<     setRecvTimeout(recvTimeout_);
<   }
< 
<   // Linger
<   setLinger(lingerOn_, lingerVal_);
< 
<   // No delay
<   setNoDelay(noDelay_);
< 
<   // Uses a low min RTO if asked to.
< #ifdef TCP_LOW_MIN_RTO
<   if (getUseLowMinRto()) {
<     int one = 1;
<     setsockopt(socket_, IPPROTO_TCP, TCP_LOW_MIN_RTO, &one, sizeof(one));
<   }
< #endif
< 
< 
<   // Set the socket to be non blocking for connect if a timeout exists
<   int flags = fcntl(socket_, F_GETFL, 0);
<   if (connTimeout_ > 0) {
<     if (-1 == fcntl(socket_, F_SETFL, flags | O_NONBLOCK)) {
<       int errno_copy = errno;
<       GlobalOutput.perror("TSocket::open() fcntl() " + getSocketInfo(), errno_copy);
<       throw TTransportException(TTransportException::NOT_OPEN, "fcntl() failed", errno_copy);
<     }
<   } else {
<     if (-1 == fcntl(socket_, F_SETFL, flags & ~O_NONBLOCK)) {
<       int errno_copy = errno;
<       GlobalOutput.perror("TSocket::open() fcntl " + getSocketInfo(), errno_copy);
<       throw TTransportException(TTransportException::NOT_OPEN, "fcntl() failed", errno_copy);
<     }
<   }
< 
<   // Connect the socket
<   int ret;
<   if (! path_.empty()) {
< 
< #ifndef _WIN32
< 
<     struct sockaddr_un address;
<     socklen_t len;
< 
<     if (path_.length() > sizeof(address.sun_path)) {
<       int errno_copy = errno;
<       GlobalOutput.perror("TSocket::open() Unix Domain socket path too long", errno_copy);
<       throw TTransportException(TTransportException::NOT_OPEN, " Unix Domain socket path too long");
<     }
< 
<     address.sun_family = AF_UNIX;
<     snprintf(address.sun_path, sizeof(address.sun_path), "%s", path_.c_str());
<     len = sizeof(address);
<     ret = connect(socket_, (struct sockaddr *) &address, len);
< 
< #else
<       GlobalOutput.perror("TSocket::open() Unix Domain socket path not supported on windows", -99);
<       throw TTransportException(TTransportException::NOT_OPEN, " Unix Domain socket path not supported");
< #endif
< 
<   } else {
<     ret = connect(socket_, res->ai_addr, res->ai_addrlen);
<   }
< 
<   // success case
<   if (ret == 0) {
<     goto done;
<   }
< 
<   if ((errno != EINPROGRESS) && (errno != EWOULDBLOCK)) {
<     int errno_copy = errno;
<     GlobalOutput.perror("TSocket::open() connect() " + getSocketInfo(), errno_copy);
<     throw TTransportException(TTransportException::NOT_OPEN, "connect() failed", errno_copy);
<   }
< 
< 
<   struct pollfd fds[1];
<   std::memset(fds, 0 , sizeof(fds));
<   fds[0].fd = socket_;
<   fds[0].events = POLLOUT;
<   ret = poll(fds, 1, connTimeout_);
< 
<   if (ret > 0) {
<     // Ensure the socket is connected and that there are no errors set
<     int val;
<     socklen_t lon;
<     lon = sizeof(int);
<     int ret2 = getsockopt(socket_, SOL_SOCKET, SO_ERROR, cast_sockopt(&val), &lon);
<     if (ret2 == -1) {
<       int errno_copy = errno;
<       GlobalOutput.perror("TSocket::open() getsockopt() " + getSocketInfo(), errno_copy);
<       throw TTransportException(TTransportException::NOT_OPEN, "getsockopt()", errno_copy);
<     }
<     // no errors on socket, go to town
<     if (val == 0) {
<       goto done;
<     }
<     GlobalOutput.perror("TSocket::open() error on socket (after poll) " + getSocketInfo(), val);
<     throw TTransportException(TTransportException::NOT_OPEN, "socket open() error", val);
<   } else if (ret == 0) {
<     // socket timed out
<     string errStr = "TSocket::open() timed out " + getSocketInfo();
<     GlobalOutput(errStr.c_str());
<     throw TTransportException(TTransportException::NOT_OPEN, "open() timed out");
<   } else {
<     // error on poll()
<     int errno_copy = errno;
<     GlobalOutput.perror("TSocket::open() poll() " + getSocketInfo(), errno_copy);
<     throw TTransportException(TTransportException::NOT_OPEN, "poll() failed", errno_copy);
<   }
< 
<  done:
<   // Set socket back to normal mode (blocking)
<   fcntl(socket_, F_SETFL, flags);
< 
<   if (path_.empty()) {
<     setCachedAddress(res->ai_addr, res->ai_addrlen);
<   }
< }
< 
< void TSocket::open() {
<   if (isOpen()) {
<     return;
<   }
<   if (! path_.empty()) {
<     unix_open();
<   } else {
<     local_open();
<   }
< }
< 
< void TSocket::unix_open(){
<   if (! path_.empty()) {
<     // Unix Domain SOcket does not need addrinfo struct, so we pass NULL
<     openConnection(NULL);
<   }
< }
< 
< void TSocket::local_open(){
< 
< #ifdef _WIN32
<     TWinsockSingleton::create();
< #endif // _WIN32
< 
<   if (isOpen()) {
<     return;
<   }
< 
<   // Validate port number
<   if (port_ < 0 || port_ > 0xFFFF) {
<     throw TTransportException(TTransportException::NOT_OPEN, "Specified port is invalid");
<   }
< 
<   struct addrinfo hints, *res, *res0;
<   res = NULL;
<   res0 = NULL;
<   int error;
<   char port[sizeof("65535")];
<   std::memset(&hints, 0, sizeof(hints));
<   hints.ai_family = PF_UNSPEC;
<   hints.ai_socktype = SOCK_STREAM;
<   hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;
<   sprintf(port, "%d", port_);
< 
<   error = getaddrinfo(host_.c_str(), port, &hints, &res0);
< 
<   if (error) {
<     string errStr = "TSocket::open() getaddrinfo() " + getSocketInfo() + string(gai_strerror(error));
<     GlobalOutput(errStr.c_str());
<     close();
<     throw TTransportException(TTransportException::NOT_OPEN, "Could not resolve host for client socket.");
<   }
< 
<   // Cycle through all the returned addresses until one
<   // connects or push the exception up.
<   for (res = res0; res; res = res->ai_next) {
<     try {
<       openConnection(res);
<       break;
<     } catch (TTransportException& ttx) {
<       if (res->ai_next) {
<         close();
<       } else {
<         close();
<         freeaddrinfo(res0); // cleanup on failure
<         throw;
<       }
<     }
<   }
< 
<   // Free address structure memory
<   freeaddrinfo(res0);
< }
< 
< void TSocket::close() {
<   if (socket_ >= 0) {
< 
< #ifdef _WIN32
<       shutdown(socket_, SD_BOTH);
<       ::closesocket(socket_);
< #else
<       shutdown(socket_, SHUT_RDWR);
<       ::close(socket_);
< #endif
< 
<   }
<   socket_ = -1;
< }
< 
< void TSocket::setSocketFD(int socket) {
<   if (socket_ >= 0) {
<     close();
<   }
<   socket_ = socket;
< }
< 
< uint32_t TSocket::read(uint8_t* buf, uint32_t len) {
<   if (socket_ < 0) {
<     throw TTransportException(TTransportException::NOT_OPEN, "Called read on non-open socket");
<   }
< 
<   int32_t retries = 0;
< 
<   // EAGAIN can be signalled both when a timeout has occurred and when
<   // the system is out of resources (an awesome undocumented feature).
<   // The following is an approximation of the time interval under which
<   // EAGAIN is taken to indicate an out of resources error.
<   uint32_t eagainThresholdMicros = 0;
<   if (recvTimeout_) {
<     // if a readTimeout is specified along with a max number of recv retries, then
<     // the threshold will ensure that the read timeout is not exceeded even in the
<     // case of resource errors
<     eagainThresholdMicros = (recvTimeout_*1000)/ ((maxRecvRetries_>0) ? maxRecvRetries_ : 2);
<   }
< 
<  try_again:
<   // Read from the socket
<   struct timeval begin;
<   if (recvTimeout_ > 0) {
<     gettimeofday(&begin, NULL);
<   } else {
<     // if there is no read timeout we don't need the TOD to determine whether
<     // an EAGAIN is due to a timeout or an out-of-resource condition.
<     begin.tv_sec = begin.tv_usec = 0;
<   }
<   int got = recv(socket_, cast_sockopt(buf), len, 0);
<   int errno_copy = errno; //gettimeofday can change errno
<   ++g_socket_syscalls;
< 
<   // Check for error on read
<   if (got < 0) {
<     if (errno_copy == EAGAIN) {
<       // if no timeout we can assume that resource exhaustion has occurred.
<       if (recvTimeout_ == 0) {
<         throw TTransportException(TTransportException::TIMED_OUT,
<                                     "EAGAIN (unavailable resources)");
<       }
<       // check if this is the lack of resources or timeout case
<       struct timeval end;
<       gettimeofday(&end, NULL);
<       uint32_t readElapsedMicros =  (((end.tv_sec - begin.tv_sec) * 1000 * 1000)
<                                      + (((uint64_t)(end.tv_usec - begin.tv_usec))));
< 
<       if (!eagainThresholdMicros || (readElapsedMicros < eagainThresholdMicros)) {
<         if (retries++ < maxRecvRetries_) {
<           usleep(50);
<           goto try_again;
<         } else {
<           throw TTransportException(TTransportException::TIMED_OUT,
<                                     "EAGAIN (unavailable resources)");
<         }
<       } else {
<         // infer that timeout has been hit
<         throw TTransportException(TTransportException::TIMED_OUT,
<                                   "EAGAIN (timed out)");
<       }
<     }
< 
<     // If interrupted, try again
<     if (errno_copy == EINTR && retries++ < maxRecvRetries_) {
<       goto try_again;
<     }
< 
<     #if defined __FreeBSD__ || defined __MACH__
<     if (errno_copy == ECONNRESET) {
<       /* shigin: freebsd doesn't follow POSIX semantic of recv and fails with
<        * ECONNRESET if peer performed shutdown 
<        * edhall: eliminated close() since we do that in the destructor.
<        */
<       return 0;
<     }
<     #endif
< 
< #ifdef _WIN32
<     if(errno_copy == WSAECONNRESET) {
<       return 0; // EOF
<     }
< #endif
< 
<     // Now it's not a try again case, but a real probblez
<     GlobalOutput.perror("TSocket::read() recv() " + getSocketInfo(), errno_copy);
< 
<     // If we disconnect with no linger time
<     if (errno_copy == ECONNRESET) {
<       throw TTransportException(TTransportException::NOT_OPEN, "ECONNRESET");
<     }
< 
<     // This ish isn't open
<     if (errno_copy == ENOTCONN) {
<       throw TTransportException(TTransportException::NOT_OPEN, "ENOTCONN");
<     }
< 
<     // Timed out!
<     if (errno_copy == ETIMEDOUT) {
<       throw TTransportException(TTransportException::TIMED_OUT, "ETIMEDOUT");
<     }
< 
<     // Some other error, whatevz
<     throw TTransportException(TTransportException::UNKNOWN, "Unknown", errno_copy);
<   }
< 
<   // The remote host has closed the socket
<   if (got == 0) {
<     // edhall: we used to call close() here, but our caller may want to deal
<     // with the socket fd and we'll close() in our destructor in any case.
<     return 0;
<   }
< 
<   // Pack data into string
<   return got;
< }
< 
< void TSocket::write(const uint8_t* buf, uint32_t len) {
<   uint32_t sent = 0;
< 
<   while (sent < len) {
<     uint32_t b = write_partial(buf + sent, len - sent);
<     if (b == 0) {
<       // This should only happen if the timeout set with SO_SNDTIMEO expired.
<       // Raise an exception.
<       throw TTransportException(TTransportException::TIMED_OUT,
<                                 "send timeout expired");
<     }
<     sent += b;
<   }
< }
< 
< uint32_t TSocket::write_partial(const uint8_t* buf, uint32_t len) {
<   if (socket_ < 0) {
<     throw TTransportException(TTransportException::NOT_OPEN, "Called write on non-open socket");
<   }
< 
<   uint32_t sent = 0;
< 
<   int flags = 0;
< #ifdef MSG_NOSIGNAL
<   // Note the use of MSG_NOSIGNAL to suppress SIGPIPE errors, instead we
<   // check for the EPIPE return condition and close the socket in that case
<   flags |= MSG_NOSIGNAL;
< #endif // ifdef MSG_NOSIGNAL
< 
<   int b = send(socket_, const_cast_sockopt(buf + sent), len - sent, flags);
<   ++g_socket_syscalls;
< 
<   if (b < 0) {
<     if (errno == EWOULDBLOCK || errno == EAGAIN) {
<       return 0;
<     }
<     // Fail on a send error
<     int errno_copy = errno;
<     GlobalOutput.perror("TSocket::write_partial() send() " + getSocketInfo(), errno_copy);
< 
<     if (errno_copy == EPIPE || errno_copy == ECONNRESET || errno_copy == ENOTCONN) {
<       close();
<       throw TTransportException(TTransportException::NOT_OPEN, "write() send()", errno_copy);
<     }
< 
<     throw TTransportException(TTransportException::UNKNOWN, "write() send()", errno_copy);
<   }
<   
<   // Fail on blocked send
<   if (b == 0) {
<     throw TTransportException(TTransportException::NOT_OPEN, "Socket send returned 0.");
<   }
<   return b;
< }
< 
< std::string TSocket::getHost() {
<   return host_;
< }
< 
< int TSocket::getPort() {
<   return port_;
< }
< 
< void TSocket::setHost(string host) {
<   host_ = host;
< }
< 
< void TSocket::setPort(int port) {
<   port_ = port;
< }
< 
< void TSocket::setLinger(bool on, int linger) {
<   lingerOn_ = on;
<   lingerVal_ = linger;
<   if (socket_ < 0) {
<     return;
<   }
< 
<   struct linger l = {(lingerOn_ ? 1 : 0), lingerVal_};
<   int ret = setsockopt(socket_, SOL_SOCKET, SO_LINGER, cast_sockopt(&l), sizeof(l));
<   if (ret == -1) {
<     int errno_copy = errno;  // Copy errno because we're allocating memory.
<     GlobalOutput.perror("TSocket::setLinger() setsockopt() " + getSocketInfo(), errno_copy);
<   }
< }
< 
< void TSocket::setNoDelay(bool noDelay) {
<   noDelay_ = noDelay;
<   if (socket_ < 0 || !path_.empty()) {
<     return;
<   }
< 
<   // Set socket to NODELAY
<   int v = noDelay_ ? 1 : 0;
<   int ret = setsockopt(socket_, IPPROTO_TCP, TCP_NODELAY, cast_sockopt(&v), sizeof(v));
<   if (ret == -1) {
<     int errno_copy = errno;  // Copy errno because we're allocating memory.
<     GlobalOutput.perror("TSocket::setNoDelay() setsockopt() " + getSocketInfo(), errno_copy);
<   }
< }
< 
< void TSocket::setConnTimeout(int ms) {
<   connTimeout_ = ms;
< }
< 
< void TSocket::setRecvTimeout(int ms) {
<   if (ms < 0) {
<     char errBuf[512];
<     sprintf(errBuf, "TSocket::setRecvTimeout with negative input: %d\n", ms);
<     GlobalOutput(errBuf);
<     return;
<   }
<   recvTimeout_ = ms;
< 
<   if (socket_ < 0) {
<     return;
<   }
< 
<   recvTimeval_.tv_sec = (int)(recvTimeout_/1000);
<   recvTimeval_.tv_usec = (int)((recvTimeout_%1000)*1000);
< 
<   // Copy because poll may modify
<   struct timeval r = recvTimeval_;
<   int ret = setsockopt(socket_, SOL_SOCKET, SO_RCVTIMEO, cast_sockopt(&r), sizeof(r));
<   if (ret == -1) {
<     int errno_copy = errno;  // Copy errno because we're allocating memory.
<     GlobalOutput.perror("TSocket::setRecvTimeout() setsockopt() " + getSocketInfo(), errno_copy);
<   }
< }
< 
< void TSocket::setSendTimeout(int ms) {
<   if (ms < 0) {
<     char errBuf[512];
<     sprintf(errBuf, "TSocket::setSendTimeout with negative input: %d\n", ms);
<     GlobalOutput(errBuf);
<     return;
<   }
<   sendTimeout_ = ms;
< 
<   if (socket_ < 0) {
<     return;
<   }
< 
<   struct timeval s = {(int)(sendTimeout_/1000),
<                       (int)((sendTimeout_%1000)*1000)};
<   int ret = setsockopt(socket_, SOL_SOCKET, SO_SNDTIMEO, cast_sockopt(&s), sizeof(s));
<   if (ret == -1) {
<     int errno_copy = errno;  // Copy errno because we're allocating memory.
<     GlobalOutput.perror("TSocket::setSendTimeout() setsockopt() " + getSocketInfo(), errno_copy);
<   }
< }
< 
< void TSocket::setMaxRecvRetries(int maxRecvRetries) {
<   maxRecvRetries_ = maxRecvRetries;
< }
< 
< string TSocket::getSocketInfo() {
<   std::ostringstream oss;
<   if (host_.empty() || port_ == 0) {
<     oss << "<Host: " << getPeerAddress();
<     oss << " Port: " << getPeerPort() << ">";
<   } else {
<     oss << "<Host: " << host_ << " Port: " << port_ << ">";
<   }
<   return oss.str();
< }
< 
< std::string TSocket::getPeerHost() {
<   if (peerHost_.empty() && path_.empty()) {
<     struct sockaddr_storage addr;
<     struct sockaddr* addrPtr;
<     socklen_t addrLen;
< 
<     if (socket_ < 0) {
<       return host_;
<     }
< 
<     addrPtr = getCachedAddress(&addrLen);
< 
<     if (addrPtr == NULL) {
<       addrLen = sizeof(addr);
<       if (getpeername(socket_, (sockaddr*) &addr, &addrLen) != 0) {
<         return peerHost_;
<       }
<       addrPtr = (sockaddr*)&addr;
< 
<       setCachedAddress(addrPtr, addrLen);
<     }
< 
<     char clienthost[NI_MAXHOST];
<     char clientservice[NI_MAXSERV];
< 
<     getnameinfo((sockaddr*) addrPtr, addrLen,
<                 clienthost, sizeof(clienthost),
<                 clientservice, sizeof(clientservice), 0);
< 
<     peerHost_ = clienthost;
<   }
<   return peerHost_;
< }
< 
< std::string TSocket::getPeerAddress() {
<   if (peerAddress_.empty() && path_.empty()) {
<     struct sockaddr_storage addr;
<     struct sockaddr* addrPtr;
<     socklen_t addrLen;
< 
<     if (socket_ < 0) {
<       return peerAddress_;
<     }
< 
<     addrPtr = getCachedAddress(&addrLen);
< 
<     if (addrPtr == NULL) {
<       addrLen = sizeof(addr);
<       if (getpeername(socket_, (sockaddr*) &addr, &addrLen) != 0) {
<         return peerAddress_;
<       }
<       addrPtr = (sockaddr*)&addr;
< 
<       setCachedAddress(addrPtr, addrLen);
<     }
< 
<     char clienthost[NI_MAXHOST];
<     char clientservice[NI_MAXSERV];
< 
<     getnameinfo(addrPtr, addrLen,
<                 clienthost, sizeof(clienthost),
<                 clientservice, sizeof(clientservice),
<                 NI_NUMERICHOST|NI_NUMERICSERV);
< 
<     peerAddress_ = clienthost;
<     peerPort_ = std::atoi(clientservice);
<   }
<   return peerAddress_;
< }
< 
< int TSocket::getPeerPort() {
<   getPeerAddress();
<   return peerPort_;
< }
< 
< void TSocket::setCachedAddress(const sockaddr* addr, socklen_t len) {
<   if (!path_.empty()) {
<     return;
<   }
< 
<   switch (addr->sa_family) {
<   case AF_INET:
<     if (len == sizeof(sockaddr_in)) {
<       memcpy((void*)&cachedPeerAddr_.ipv4, (void*)addr, len);
<     }
<     break;
< 
<   case AF_INET6:
<     if (len == sizeof(sockaddr_in6)) {
<       memcpy((void*)&cachedPeerAddr_.ipv6, (void*)addr, len);
<     }
<     break;
<   }
< }
< 
< sockaddr* TSocket::getCachedAddress(socklen_t* len) const {
<   switch (cachedPeerAddr_.ipv4.sin_family) {
<   case AF_INET:
<     *len = sizeof(sockaddr_in);
<     return (sockaddr*) &cachedPeerAddr_.ipv4;
< 
<   case AF_INET6:
<     *len = sizeof(sockaddr_in6);
<     return (sockaddr*) &cachedPeerAddr_.ipv6;
< 
<   default:
<     return NULL;
<   }
< } 
< 
< bool TSocket::useLowMinRto_ = false;
< void TSocket::setUseLowMinRto(bool useLowMinRto) {
<   useLowMinRto_ = useLowMinRto;
< }
< bool TSocket::getUseLowMinRto() {
<   return useLowMinRto_;
< }
< 
< }}} // apache::thrift::transport
---
> /*
>  * Licensed to the Apache Software Foundation (ASF) under one
>  * or more contributor license agreements. See the NOTICE file
>  * distributed with this work for additional information
>  * regarding copyright ownership. The ASF licenses this file
>  * to you under the Apache License, Version 2.0 (the
>  * "License"); you may not use this file except in compliance
>  * with the License. You may obtain a copy of the License at
>  *
>  *   http://www.apache.org/licenses/LICENSE-2.0
>  *
>  * Unless required by applicable law or agreed to in writing,
>  * software distributed under the License is distributed on an
>  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
>  * KIND, either express or implied. See the License for the
>  * specific language governing permissions and limitations
>  * under the License.
>  */
> 
> #ifdef HAVE_CONFIG_H
> #include <config.h>
> #endif
> #include <cstring>
> #include <sstream>
> #ifdef HAVE_SYS_SOCKET_H
> #include <sys/socket.h>
> #endif
> #ifdef HAVE_SYS_UN_H
> #include <sys/un.h>
> #endif
> #ifdef HAVE_SYS_POLL_H
> #include <sys/poll.h>
> #endif
> #include <sys/types.h>
> #ifdef HAVE_ARPA_INET_H
> #include <arpa/inet.h>
> #endif
> #ifdef HAVE_NETINET_IN_H
> #include <netinet/in.h>
> #include <netinet/tcp.h>
> #endif
> #ifdef HAVE_UNISTD_H
> #include <unistd.h>
> #endif
> #include <errno.h>
> #include <fcntl.h>
> 
> #include "concurrency/Monitor.h"
> #include "TSocket.h"
> #include "TTransportException.h"
> 
> #ifndef SOCKOPT_CAST_T
> #   ifndef _WIN32
> #       define SOCKOPT_CAST_T void
> #   else
> #       define SOCKOPT_CAST_T char
> #   endif // _WIN32
> #endif
> 
> template<class T>
> inline const SOCKOPT_CAST_T* const_cast_sockopt(const T* v) {
>     return reinterpret_cast<const SOCKOPT_CAST_T*>(v);
> }
> 
> template<class T>
> inline SOCKOPT_CAST_T* cast_sockopt(T* v) {
>     return reinterpret_cast<SOCKOPT_CAST_T*>(v);
> }
> 
> namespace apache { namespace thrift { namespace transport {
> 
> using namespace std;
> 
> // Global var to track total socket sys calls
> uint32_t g_socket_syscalls = 0;
> 
> /**
>  * TSocket implementation.
>  *
>  */
> 
> TSocket::TSocket(string host, int port) :
>   host_(host),
>   port_(port),
>   path_(""),
>   socket_(-1),
>   connTimeout_(0),
>   sendTimeout_(0),
>   recvTimeout_(0),
>   lingerOn_(1),
>   lingerVal_(0),
>   noDelay_(1),
>   maxRecvRetries_(5) {
>   recvTimeval_.tv_sec = (int)(recvTimeout_/1000);
>   recvTimeval_.tv_usec = (int)((recvTimeout_%1000)*1000);
> }
> 
> TSocket::TSocket(string path) :
>   host_(""),
>   port_(0),
>   path_(path),
>   socket_(-1),
>   connTimeout_(0),
>   sendTimeout_(0),
>   recvTimeout_(0),
>   lingerOn_(1),
>   lingerVal_(0),
>   noDelay_(1),
>   maxRecvRetries_(5) {
>   recvTimeval_.tv_sec = (int)(recvTimeout_/1000);
>   recvTimeval_.tv_usec = (int)((recvTimeout_%1000)*1000);
>   cachedPeerAddr_.ipv4.sin_family = AF_UNSPEC;
> }
> 
> TSocket::TSocket() :
>   host_(""),
>   port_(0),
>   path_(""),
>   socket_(-1),
>   connTimeout_(0),
>   sendTimeout_(0),
>   recvTimeout_(0),
>   lingerOn_(1),
>   lingerVal_(0),
>   noDelay_(1),
>   maxRecvRetries_(5) {
>   recvTimeval_.tv_sec = (int)(recvTimeout_/1000);
>   recvTimeval_.tv_usec = (int)((recvTimeout_%1000)*1000);
>   cachedPeerAddr_.ipv4.sin_family = AF_UNSPEC;
> }
> 
> TSocket::TSocket(int socket) :
>   host_(""),
>   port_(0),
>   path_(""),
>   socket_(socket),
>   connTimeout_(0),
>   sendTimeout_(0),
>   recvTimeout_(0),
>   lingerOn_(1),
>   lingerVal_(0),
>   noDelay_(1),
>   maxRecvRetries_(5) {
>   recvTimeval_.tv_sec = (int)(recvTimeout_/1000);
>   recvTimeval_.tv_usec = (int)((recvTimeout_%1000)*1000);
>   cachedPeerAddr_.ipv4.sin_family = AF_UNSPEC;
> }
> 
> TSocket::~TSocket() {
>   close();
> }
> 
> bool TSocket::isOpen() {
>   return (socket_ >= 0);
> }
> 
> bool TSocket::peek() {
>   if (!isOpen()) {
>     return false;
>   }
>   uint8_t buf;
>   int r = recv(socket_, cast_sockopt(&buf), 1, MSG_PEEK);
>   if (r == -1) {
>     int errno_copy = errno;
>     #if defined __FreeBSD__ || defined __MACH__
>     /* shigin:
>      * freebsd returns -1 and ECONNRESET if socket was closed by 
>      * the other side
>      */
>     if (errno_copy == ECONNRESET)
>     {
>       close();
>       return false;
>     }
>     #endif
>     GlobalOutput.perror("TSocket::peek() recv() " + getSocketInfo(), errno_copy);
>     throw TTransportException(TTransportException::UNKNOWN, "recv()", errno_copy);
>   }
>   return (r > 0);
> }
> 
> void TSocket::openConnection(struct addrinfo *res) {
> 
>   if (isOpen()) {
>     return;
>   }
> 
>   if (! path_.empty()) {
>     socket_ = socket(PF_UNIX, SOCK_STREAM, IPPROTO_IP);
>   } else {
>     socket_ = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
>   }
> 
>   if (socket_ == -1) {
>     int errno_copy = errno;
>     GlobalOutput.perror("TSocket::open() socket() " + getSocketInfo(), errno_copy);
>     throw TTransportException(TTransportException::NOT_OPEN, "socket()", errno_copy);
>   }
> 
>   // Send timeout
>   if (sendTimeout_ > 0) {
>     setSendTimeout(sendTimeout_);
>   }
> 
>   // Recv timeout
>   if (recvTimeout_ > 0) {
>     setRecvTimeout(recvTimeout_);
>   }
> 
>   // Linger
>   setLinger(lingerOn_, lingerVal_);
> 
>   // No delay
>   setNoDelay(noDelay_);
> 
>   // Uses a low min RTO if asked to.
> #ifdef TCP_LOW_MIN_RTO
>   if (getUseLowMinRto()) {
>     int one = 1;
>     setsockopt(socket_, IPPROTO_TCP, TCP_LOW_MIN_RTO, &one, sizeof(one));
>   }
> #endif
> 
> 
>   // Set the socket to be non blocking for connect if a timeout exists
>   int flags = fcntl(socket_, F_GETFL, 0);
>   if (connTimeout_ > 0) {
>     if (-1 == fcntl(socket_, F_SETFL, flags | O_NONBLOCK)) {
>       int errno_copy = errno;
>       GlobalOutput.perror("TSocket::open() fcntl() " + getSocketInfo(), errno_copy);
>       throw TTransportException(TTransportException::NOT_OPEN, "fcntl() failed", errno_copy);
>     }
>   } else {
>     if (-1 == fcntl(socket_, F_SETFL, flags & ~O_NONBLOCK)) {
>       int errno_copy = errno;
>       GlobalOutput.perror("TSocket::open() fcntl " + getSocketInfo(), errno_copy);
>       throw TTransportException(TTransportException::NOT_OPEN, "fcntl() failed", errno_copy);
>     }
>   }
> 
>   // Connect the socket
>   int ret;
>   if (! path_.empty()) {
> 
> #ifndef _WIN32
> 
>     struct sockaddr_un address;
>     socklen_t len;
> 
>     if (path_.length() > sizeof(address.sun_path)) {
>       int errno_copy = errno;
>       GlobalOutput.perror("TSocket::open() Unix Domain socket path too long", errno_copy);
>       throw TTransportException(TTransportException::NOT_OPEN, " Unix Domain socket path too long");
>     }
> 
>     address.sun_family = AF_UNIX;
>     snprintf(address.sun_path, sizeof(address.sun_path), "%s", path_.c_str());
>     len = sizeof(address);
>     ret = connect(socket_, (struct sockaddr *) &address, len);
> 
> #else
>       GlobalOutput.perror("TSocket::open() Unix Domain socket path not supported on windows", -99);
>       throw TTransportException(TTransportException::NOT_OPEN, " Unix Domain socket path not supported");
> #endif
> 
>   } else {
>     ret = connect(socket_, res->ai_addr, res->ai_addrlen);
>   }
> 
>   // success case
>   if (ret == 0) {
>     goto done;
>   }
> 
>   if ((errno != EINPROGRESS) && (errno != EWOULDBLOCK)) {
>     int errno_copy = errno;
>     GlobalOutput.perror("TSocket::open() connect() " + getSocketInfo(), errno_copy);
>     throw TTransportException(TTransportException::NOT_OPEN, "connect() failed", errno_copy);
>   }
> 
> 
>   struct pollfd fds[1];
>   std::memset(fds, 0 , sizeof(fds));
>   fds[0].fd = socket_;
>   fds[0].events = POLLOUT;
>   ret = poll(fds, 1, connTimeout_);
> 
>   if (ret > 0) {
>     // Ensure the socket is connected and that there are no errors set
>     int val;
>     socklen_t lon;
>     lon = sizeof(int);
>     int ret2 = getsockopt(socket_, SOL_SOCKET, SO_ERROR, cast_sockopt(&val), &lon);
>     if (ret2 == -1) {
>       int errno_copy = errno;
>       GlobalOutput.perror("TSocket::open() getsockopt() " + getSocketInfo(), errno_copy);
>       throw TTransportException(TTransportException::NOT_OPEN, "getsockopt()", errno_copy);
>     }
>     // no errors on socket, go to town
>     if (val == 0) {
>       goto done;
>     }
>     GlobalOutput.perror("TSocket::open() error on socket (after poll) " + getSocketInfo(), val);
>     throw TTransportException(TTransportException::NOT_OPEN, "socket open() error", val);
>   } else if (ret == 0) {
>     // socket timed out
>     string errStr = "TSocket::open() timed out " + getSocketInfo();
>     GlobalOutput(errStr.c_str());
>     throw TTransportException(TTransportException::NOT_OPEN, "open() timed out");
>   } else {
>     // error on poll()
>     int errno_copy = errno;
>     GlobalOutput.perror("TSocket::open() poll() " + getSocketInfo(), errno_copy);
>     throw TTransportException(TTransportException::NOT_OPEN, "poll() failed", errno_copy);
>   }
> 
>  done:
>   // Set socket back to normal mode (blocking)
>   fcntl(socket_, F_SETFL, flags);
> 
>   if (path_.empty()) {
>     setCachedAddress(res->ai_addr, res->ai_addrlen);
>   }
> }
> 
> void TSocket::open() {
>   if (isOpen()) {
>     return;
>   }
>   if (! path_.empty()) {
>     unix_open();
>   } else {
>     local_open();
>   }
> }
> 
> void TSocket::unix_open(){
>   if (! path_.empty()) {
>     // Unix Domain SOcket does not need addrinfo struct, so we pass NULL
>     openConnection(NULL);
>   }
> }
> 
> void TSocket::local_open(){
> 
> #ifdef _WIN32
>     TWinsockSingleton::create();
> #endif // _WIN32
> 
>   if (isOpen()) {
>     return;
>   }
> 
>   // Validate port number
>   if (port_ < 0 || port_ > 0xFFFF) {
>     throw TTransportException(TTransportException::NOT_OPEN, "Specified port is invalid");
>   }
> 
>   struct addrinfo hints, *res, *res0;
>   res = NULL;
>   res0 = NULL;
>   int error;
>   char port[sizeof("65535")];
>   std::memset(&hints, 0, sizeof(hints));
>   hints.ai_family = PF_UNSPEC;
>   hints.ai_socktype = SOCK_STREAM;
>   hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;
>   sprintf(port, "%d", port_);
> 
>   error = getaddrinfo(host_.c_str(), port, &hints, &res0);
> 
>   if (error) {
>     string errStr = "TSocket::open() getaddrinfo() " + getSocketInfo() + string(gai_strerror(error));
>     GlobalOutput(errStr.c_str());
>     close();
>     throw TTransportException(TTransportException::NOT_OPEN, "Could not resolve host for client socket.");
>   }
> 
>   // Cycle through all the returned addresses until one
>   // connects or push the exception up.
>   for (res = res0; res; res = res->ai_next) {
>     try {
>       openConnection(res);
>       break;
>     } catch (TTransportException& ttx) {
>       if (res->ai_next) {
>         close();
>       } else {
>         close();
>         freeaddrinfo(res0); // cleanup on failure
>         throw;
>       }
>     }
>   }
> 
>   // Free address structure memory
>   freeaddrinfo(res0);
> }
> 
> void TSocket::close() {
>   if (socket_ >= 0) {
> 
> #ifdef _WIN32
>       shutdown(socket_, SD_BOTH);
>       ::closesocket(socket_);
> #else
>       shutdown(socket_, SHUT_RDWR);
>       ::close(socket_);
> #endif
> 
>   }
>   socket_ = -1;
> }
> 
> void TSocket::setSocketFD(int socket) {
>   if (socket_ >= 0) {
>     close();
>   }
>   socket_ = socket;
> }
> 
> uint32_t TSocket::read(uint8_t* buf, uint32_t len) {
>   if (socket_ < 0) {
>     throw TTransportException(TTransportException::NOT_OPEN, "Called read on non-open socket");
>   }
> 
>   int32_t retries = 0;
> 
>   // EAGAIN can be signalled both when a timeout has occurred and when
>   // the system is out of resources (an awesome undocumented feature).
>   // The following is an approximation of the time interval under which
>   // EAGAIN is taken to indicate an out of resources error.
>   uint32_t eagainThresholdMicros = 0;
>   if (recvTimeout_) {
>     // if a readTimeout is specified along with a max number of recv retries, then
>     // the threshold will ensure that the read timeout is not exceeded even in the
>     // case of resource errors
>     eagainThresholdMicros = (recvTimeout_*1000)/ ((maxRecvRetries_>0) ? maxRecvRetries_ : 2);
>   }
> 
>  try_again:
>   // Read from the socket
>   struct timeval begin;
>   if (recvTimeout_ > 0) {
>     gettimeofday(&begin, NULL);
>   } else {
>     // if there is no read timeout we don't need the TOD to determine whether
>     // an EAGAIN is due to a timeout or an out-of-resource condition.
>     begin.tv_sec = begin.tv_usec = 0;
>   }
>   int got = recv(socket_, cast_sockopt(buf), len, 0);
>   int errno_copy = errno; //gettimeofday can change errno
>   ++g_socket_syscalls;
> 
>   // Check for error on read
>   if (got < 0) {
>     if (errno_copy == EAGAIN) {
>       // if no timeout we can assume that resource exhaustion has occurred.
>       if (recvTimeout_ == 0) {
>         throw TTransportException(TTransportException::TIMED_OUT,
>                                     "EAGAIN (unavailable resources)");
>       }
>       // check if this is the lack of resources or timeout case
>       struct timeval end;
>       gettimeofday(&end, NULL);
>       uint32_t readElapsedMicros =  (((end.tv_sec - begin.tv_sec) * 1000 * 1000)
>                                      + (((uint64_t)(end.tv_usec - begin.tv_usec))));
> 
>       if (!eagainThresholdMicros || (readElapsedMicros < eagainThresholdMicros)) {
>         if (retries++ < maxRecvRetries_) {
>           thrift_usleep(50);
>           goto try_again;
>         } else {
>           throw TTransportException(TTransportException::TIMED_OUT,
>                                     "EAGAIN (unavailable resources)");
>         }
>       } else {
>         // infer that timeout has been hit
>         throw TTransportException(TTransportException::TIMED_OUT,
>                                   "EAGAIN (timed out)");
>       }
>     }
> 
>     // If interrupted, try again
>     if (errno_copy == EINTR && retries++ < maxRecvRetries_) {
>       goto try_again;
>     }
> 
>     #if defined __FreeBSD__ || defined __MACH__
>     if (errno_copy == ECONNRESET) {
>       /* shigin: freebsd doesn't follow POSIX semantic of recv and fails with
>        * ECONNRESET if peer performed shutdown 
>        * edhall: eliminated close() since we do that in the destructor.
>        */
>       return 0;
>     }
>     #endif
> 
> #ifdef _WIN32
>     if(errno_copy == WSAECONNRESET) {
>       return 0; // EOF
>     }
> #endif
> 
>     // Now it's not a try again case, but a real probblez
>     GlobalOutput.perror("TSocket::read() recv() " + getSocketInfo(), errno_copy);
> 
>     // If we disconnect with no linger time
>     if (errno_copy == ECONNRESET) {
>       throw TTransportException(TTransportException::NOT_OPEN, "ECONNRESET");
>     }
> 
>     // This ish isn't open
>     if (errno_copy == ENOTCONN) {
>       throw TTransportException(TTransportException::NOT_OPEN, "ENOTCONN");
>     }
> 
>     // Timed out!
>     if (errno_copy == ETIMEDOUT) {
>       throw TTransportException(TTransportException::TIMED_OUT, "ETIMEDOUT");
>     }
> 
>     // Some other error, whatevz
>     throw TTransportException(TTransportException::UNKNOWN, "Unknown", errno_copy);
>   }
> 
>   // The remote host has closed the socket
>   if (got == 0) {
>     // edhall: we used to call close() here, but our caller may want to deal
>     // with the socket fd and we'll close() in our destructor in any case.
>     return 0;
>   }
> 
>   // Pack data into string
>   return got;
> }
> 
> void TSocket::write(const uint8_t* buf, uint32_t len) {
>   uint32_t sent = 0;
> 
>   while (sent < len) {
>     uint32_t b = write_partial(buf + sent, len - sent);
>     if (b == 0) {
>       // This should only happen if the timeout set with SO_SNDTIMEO expired.
>       // Raise an exception.
>       throw TTransportException(TTransportException::TIMED_OUT,
>                                 "send timeout expired");
>     }
>     sent += b;
>   }
> }
> 
> uint32_t TSocket::write_partial(const uint8_t* buf, uint32_t len) {
>   if (socket_ < 0) {
>     throw TTransportException(TTransportException::NOT_OPEN, "Called write on non-open socket");
>   }
> 
>   uint32_t sent = 0;
> 
>   int flags = 0;
> #ifdef MSG_NOSIGNAL
>   // Note the use of MSG_NOSIGNAL to suppress SIGPIPE errors, instead we
>   // check for the EPIPE return condition and close the socket in that case
>   flags |= MSG_NOSIGNAL;
> #endif // ifdef MSG_NOSIGNAL
> 
>   int b = send(socket_, const_cast_sockopt(buf + sent), len - sent, flags);
>   ++g_socket_syscalls;
> 
>   if (b < 0) {
>     if (errno == EWOULDBLOCK || errno == EAGAIN) {
>       return 0;
>     }
>     // Fail on a send error
>     int errno_copy = errno;
>     GlobalOutput.perror("TSocket::write_partial() send() " + getSocketInfo(), errno_copy);
> 
>     if (errno_copy == EPIPE || errno_copy == ECONNRESET || errno_copy == ENOTCONN) {
>       close();
>       throw TTransportException(TTransportException::NOT_OPEN, "write() send()", errno_copy);
>     }
> 
>     throw TTransportException(TTransportException::UNKNOWN, "write() send()", errno_copy);
>   }
>   
>   // Fail on blocked send
>   if (b == 0) {
>     throw TTransportException(TTransportException::NOT_OPEN, "Socket send returned 0.");
>   }
>   return b;
> }
> 
> std::string TSocket::getHost() {
>   return host_;
> }
> 
> int TSocket::getPort() {
>   return port_;
> }
> 
> void TSocket::setHost(string host) {
>   host_ = host;
> }
> 
> void TSocket::setPort(int port) {
>   port_ = port;
> }
> 
> void TSocket::setLinger(bool on, int linger) {
>   lingerOn_ = on;
>   lingerVal_ = linger;
>   if (socket_ < 0) {
>     return;
>   }
> 
>   struct linger l = {(lingerOn_ ? 1 : 0), lingerVal_};
>   int ret = setsockopt(socket_, SOL_SOCKET, SO_LINGER, cast_sockopt(&l), sizeof(l));
>   if (ret == -1) {
>     int errno_copy = errno;  // Copy errno because we're allocating memory.
>     GlobalOutput.perror("TSocket::setLinger() setsockopt() " + getSocketInfo(), errno_copy);
>   }
> }
> 
> void TSocket::setNoDelay(bool noDelay) {
>   noDelay_ = noDelay;
>   if (socket_ < 0 || !path_.empty()) {
>     return;
>   }
> 
>   // Set socket to NODELAY
>   int v = noDelay_ ? 1 : 0;
>   int ret = setsockopt(socket_, IPPROTO_TCP, TCP_NODELAY, cast_sockopt(&v), sizeof(v));
>   if (ret == -1) {
>     int errno_copy = errno;  // Copy errno because we're allocating memory.
>     GlobalOutput.perror("TSocket::setNoDelay() setsockopt() " + getSocketInfo(), errno_copy);
>   }
> }
> 
> void TSocket::setConnTimeout(int ms) {
>   connTimeout_ = ms;
> }
> 
> void TSocket::setRecvTimeout(int ms) {
>   if (ms < 0) {
>     char errBuf[512];
>     sprintf(errBuf, "TSocket::setRecvTimeout with negative input: %d\n", ms);
>     GlobalOutput(errBuf);
>     return;
>   }
>   recvTimeout_ = ms;
> 
>   if (socket_ < 0) {
>     return;
>   }
> 
>   recvTimeval_.tv_sec = (int)(recvTimeout_/1000);
>   recvTimeval_.tv_usec = (int)((recvTimeout_%1000)*1000);
> 
>   // Copy because poll may modify
>   struct timeval r = recvTimeval_;
>   int ret = setsockopt(socket_, SOL_SOCKET, SO_RCVTIMEO, cast_sockopt(&r), sizeof(r));
>   if (ret == -1) {
>     int errno_copy = errno;  // Copy errno because we're allocating memory.
>     GlobalOutput.perror("TSocket::setRecvTimeout() setsockopt() " + getSocketInfo(), errno_copy);
>   }
> }
> 
> void TSocket::setSendTimeout(int ms) {
>   if (ms < 0) {
>     char errBuf[512];
>     sprintf(errBuf, "TSocket::setSendTimeout with negative input: %d\n", ms);
>     GlobalOutput(errBuf);
>     return;
>   }
>   sendTimeout_ = ms;
> 
>   if (socket_ < 0) {
>     return;
>   }
> 
>   struct timeval s = {(int)(sendTimeout_/1000),
>                       (int)((sendTimeout_%1000)*1000)};
>   int ret = setsockopt(socket_, SOL_SOCKET, SO_SNDTIMEO, cast_sockopt(&s), sizeof(s));
>   if (ret == -1) {
>     int errno_copy = errno;  // Copy errno because we're allocating memory.
>     GlobalOutput.perror("TSocket::setSendTimeout() setsockopt() " + getSocketInfo(), errno_copy);
>   }
> }
> 
> void TSocket::setMaxRecvRetries(int maxRecvRetries) {
>   maxRecvRetries_ = maxRecvRetries;
> }
> 
> string TSocket::getSocketInfo() {
>   std::ostringstream oss;
>   if (host_.empty() || port_ == 0) {
>     oss << "<Host: " << getPeerAddress();
>     oss << " Port: " << getPeerPort() << ">";
>   } else {
>     oss << "<Host: " << host_ << " Port: " << port_ << ">";
>   }
>   return oss.str();
> }
> 
> std::string TSocket::getPeerHost() {
>   if (peerHost_.empty() && path_.empty()) {
>     struct sockaddr_storage addr;
>     struct sockaddr* addrPtr;
>     socklen_t addrLen;
> 
>     if (socket_ < 0) {
>       return host_;
>     }
> 
>     addrPtr = getCachedAddress(&addrLen);
> 
>     if (addrPtr == NULL) {
>       addrLen = sizeof(addr);
>       if (getpeername(socket_, (sockaddr*) &addr, &addrLen) != 0) {
>         return peerHost_;
>       }
>       addrPtr = (sockaddr*)&addr;
> 
>       setCachedAddress(addrPtr, addrLen);
>     }
> 
>     char clienthost[NI_MAXHOST];
>     char clientservice[NI_MAXSERV];
> 
>     getnameinfo((sockaddr*) addrPtr, addrLen,
>                 clienthost, sizeof(clienthost),
>                 clientservice, sizeof(clientservice), 0);
> 
>     peerHost_ = clienthost;
>   }
>   return peerHost_;
> }
> 
> std::string TSocket::getPeerAddress() {
>   if (peerAddress_.empty() && path_.empty()) {
>     struct sockaddr_storage addr;
>     struct sockaddr* addrPtr;
>     socklen_t addrLen;
> 
>     if (socket_ < 0) {
>       return peerAddress_;
>     }
> 
>     addrPtr = getCachedAddress(&addrLen);
> 
>     if (addrPtr == NULL) {
>       addrLen = sizeof(addr);
>       if (getpeername(socket_, (sockaddr*) &addr, &addrLen) != 0) {
>         return peerAddress_;
>       }
>       addrPtr = (sockaddr*)&addr;
> 
>       setCachedAddress(addrPtr, addrLen);
>     }
> 
>     char clienthost[NI_MAXHOST];
>     char clientservice[NI_MAXSERV];
> 
>     getnameinfo(addrPtr, addrLen,
>                 clienthost, sizeof(clienthost),
>                 clientservice, sizeof(clientservice),
>                 NI_NUMERICHOST|NI_NUMERICSERV);
> 
>     peerAddress_ = clienthost;
>     peerPort_ = std::atoi(clientservice);
>   }
>   return peerAddress_;
> }
> 
> int TSocket::getPeerPort() {
>   getPeerAddress();
>   return peerPort_;
> }
> 
> void TSocket::setCachedAddress(const sockaddr* addr, socklen_t len) {
>   if (!path_.empty()) {
>     return;
>   }
> 
>   switch (addr->sa_family) {
>   case AF_INET:
>     if (len == sizeof(sockaddr_in)) {
>       memcpy((void*)&cachedPeerAddr_.ipv4, (void*)addr, len);
>     }
>     break;
> 
>   case AF_INET6:
>     if (len == sizeof(sockaddr_in6)) {
>       memcpy((void*)&cachedPeerAddr_.ipv6, (void*)addr, len);
>     }
>     break;
>   }
> }
> 
> sockaddr* TSocket::getCachedAddress(socklen_t* len) const {
>   switch (cachedPeerAddr_.ipv4.sin_family) {
>   case AF_INET:
>     *len = sizeof(sockaddr_in);
>     return (sockaddr*) &cachedPeerAddr_.ipv4;
> 
>   case AF_INET6:
>     *len = sizeof(sockaddr_in6);
>     return (sockaddr*) &cachedPeerAddr_.ipv6;
> 
>   default:
>     return NULL;
>   }
> } 
> 
> bool TSocket::useLowMinRto_ = false;
> void TSocket::setUseLowMinRto(bool useLowMinRto) {
>   useLowMinRto_ = useLowMinRto;
> }
> bool TSocket::getUseLowMinRto() {
>   return useLowMinRto_;
> }
> 
> }}} // apache::thrift::transport
1,108c1,110
< /*
<  * Licensed to the Apache Software Foundation (ASF) under one
<  * or more contributor license agreements. See the NOTICE file
<  * distributed with this work for additional information
<  * regarding copyright ownership. The ASF licenses this file
<  * to you under the Apache License, Version 2.0 (the
<  * "License"); you may not use this file except in compliance
<  * with the License. You may obtain a copy of the License at
<  *
<  *   http://www.apache.org/licenses/LICENSE-2.0
<  *
<  * Unless required by applicable law or agreed to in writing,
<  * software distributed under the License is distributed on an
<  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
<  * KIND, either express or implied. See the License for the
<  * specific language governing permissions and limitations
<  * under the License.
<  */
< 
< #ifndef _THRIFT_WINDOWS_CONFIG_H_
< #define _THRIFT_WINDOWS_CONFIG_H_ 1
< 
< #if defined(_MSC_VER) && (_MSC_VER > 1200)
< #pragma once
< #endif // _MSC_VER
< 
< #ifndef _WIN32
< #error This is a MSVC header only.
< #endif
< 
< #pragma warning(disable: 4996) // Depreciated posix name.
< #pragma warning(disable: 4250) // Inherits via dominance.
< 
< #define VERSION "0.8.0"
< #define HAVE_GETTIMEOFDAY 1
< #define HAVE_SYS_STAT_H 1
< 
< #include "TargetVersion.h"
< #include "GetTimeOfDay.h"
< #include "Operators.h"
< #include "TWinsockSingleton.h"
< #include "WinFcntl.h"
< #include "SocketPair.h"
< 
< // boost
< #include <boost/cstdint.hpp>
< 
< typedef boost::int64_t  int64_t;
< typedef boost::uint32_t uint32_t;
< typedef boost::uint8_t  uint8_t;
< 
< // windows
< #include <Winsock2.h>
< #include <ws2tcpip.h>
< #pragma comment(lib, "Ws2_32.lib")
< 
< // pthreads
< #if 0
< #	include <pthread.h>
< #else
< struct timespec {
< 	int64_t tv_sec;
< 	int64_t tv_nsec;
< };
< #	define USE_BOOST_THREAD 1
< #	define ctime_r( _clock, _buf ) \
<         ( strcpy( (_buf), ctime( (_clock) ) ),  \
<           (_buf) )
< #endif
< 
< typedef ptrdiff_t ssize_t;
< 
< // Missing functions.
< #define usleep(ms) Sleep(ms)
< 
< #if WINVER <= 0x0502
< #define poll(fds, nfds, timeout) \
<     poll_win32(fds, nfds, timeout)
< 
< inline int poll_win32(LPWSAPOLLFD fdArray, ULONG fds, INT timeout)
< {
<     fd_set read_fds;
<     fd_set write_fds;
<     fd_set except_fds;
< 
<     FD_ZERO(&read_fds);
<     FD_ZERO(&write_fds);
<     FD_ZERO(&except_fds);
< 
<     FD_SET(fdArray[0].fd, &read_fds);
<     FD_SET(fdArray[0].fd, &write_fds);
<     FD_SET(fdArray[0].fd, &except_fds);
< 
<     timeval time_out = {timeout * 0.001, timeout * 1000};
<     return select(1, &read_fds, &write_fds, &except_fds, &time_out);
< }
< #else
< 	inline int poll(struct pollfd* fdArray, ULONG fds, INT timeout) {
< 		return WSAPoll(fdArray, fds, timeout);
< 	}
< #endif // WINVER
< 
< inline void close(SOCKET socket)
< {
<     ::closesocket(socket);
< }
< 
< #endif // _THRIFT_WINDOWS_CONFIG_H_
---
> /*
>  * Licensed to the Apache Software Foundation (ASF) under one
>  * or more contributor license agreements. See the NOTICE file
>  * distributed with this work for additional information
>  * regarding copyright ownership. The ASF licenses this file
>  * to you under the Apache License, Version 2.0 (the
>  * "License"); you may not use this file except in compliance
>  * with the License. You may obtain a copy of the License at
>  *
>  *   http://www.apache.org/licenses/LICENSE-2.0
>  *
>  * Unless required by applicable law or agreed to in writing,
>  * software distributed under the License is distributed on an
>  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
>  * KIND, either express or implied. See the License for the
>  * specific language governing permissions and limitations
>  * under the License.
>  */
> 
> #ifndef _THRIFT_WINDOWS_CONFIG_H_
> #define _THRIFT_WINDOWS_CONFIG_H_ 1
> 
> #if defined(_MSC_VER) && (_MSC_VER > 1200)
> #pragma once
> #endif // _MSC_VER
> 
> #ifndef _WIN32
> #error This is a MSVC header only.
> #endif
> 
> #pragma warning(disable: 4996) // Depreciated posix name.
> #pragma warning(disable: 4250) // Inherits via dominance.
> 
> #define VERSION "0.8.0"
> #define HAVE_GETTIMEOFDAY 1
> #define HAVE_SYS_STAT_H 1
> 
> #include "TargetVersion.h"
> #include "GetTimeOfDay.h"
> #include "Operators.h"
> #include "TWinsockSingleton.h"
> #include "WinFcntl.h"
> #include "SocketPair.h"
> 
> // boost
> #include <boost/cstdint.hpp>
> 
> typedef boost::int64_t  int64_t;
> typedef boost::uint32_t uint32_t;
> typedef boost::uint8_t  uint8_t;
> 
> // windows
> #include <Winsock2.h>
> #include <ws2tcpip.h>
> #pragma comment(lib, "Ws2_32.lib")
> 
> // pthreads
> #if 0
> #	include <pthread.h>
> #else
> #ifndef _WINDOWS
> struct timespec {
> 	int64_t tv_sec;
> 	int64_t tv_nsec;
> };
> #endif
> #	define USE_BOOST_THREAD 1
> #	define ctime_r( _clock, _buf ) \
>         ( strcpy( (_buf), ctime( (_clock) ) ),  \
>           (_buf) )
> #endif
> 
> typedef ptrdiff_t ssize_t;
> 
> // Missing functions.
> #define thrift_usleep(ms) Sleep(ms)
> 
> #if WINVER <= 0x0502
> #define poll(fds, nfds, timeout) \
>     poll_win32(fds, nfds, timeout)
> 
> inline int poll_win32(LPWSAPOLLFD fdArray, ULONG fds, INT timeout)
> {
>     fd_set read_fds;
>     fd_set write_fds;
>     fd_set except_fds;
> 
>     FD_ZERO(&read_fds);
>     FD_ZERO(&write_fds);
>     FD_ZERO(&except_fds);
> 
>     FD_SET(fdArray[0].fd, &read_fds);
>     FD_SET(fdArray[0].fd, &write_fds);
>     FD_SET(fdArray[0].fd, &except_fds);
> 
>     timeval time_out = {timeout * 0.001, timeout * 1000};
>     return select(1, &read_fds, &write_fds, &except_fds, &time_out);
> }
> #else
> 	inline int poll(struct pollfd* fdArray, ULONG fds, INT timeout) {
> 		return WSAPoll(fdArray, fds, timeout);
> 	}
> #endif // WINVER
> 
> inline void close(SOCKET socket)
> {
>     ::closesocket(socket);
> }
> 
> #endif // _THRIFT_WINDOWS_CONFIG_H_
1,77c1,77
< /*
<  * Licensed to the Apache Software Foundation (ASF) under one
<  * or more contributor license agreements. See the NOTICE file
<  * distributed with this work for additional information
<  * regarding copyright ownership. The ASF licenses this file
<  * to you under the Apache License, Version 2.0 (the
<  * "License"); you may not use this file except in compliance
<  * with the License. You may obtain a copy of the License at
<  *
<  *   http://www.apache.org/licenses/LICENSE-2.0
<  *
<  * Unless required by applicable law or agreed to in writing,
<  * software distributed under the License is distributed on an
<  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
<  * KIND, either express or implied. See the License for the
<  * specific language governing permissions and limitations
<  * under the License.
<  */
< 
< #ifndef _THRIFT_TRANSPORT_WINDOWS_TWINSOCKSINGLETON_H_
< #define _THRIFT_TRANSPORT_WINDOWS_TWINSOCKSINGLETON_H_ 1
< 
< #if defined(_MSC_VER) && (_MSC_VER > 1200)
< #pragma once
< #endif // _MSC_VER
< 
< #ifndef _WIN32
< #error This is a MSVC header only.
< #endif
< 
< // boost
< #include <boost/noncopyable.hpp>
< #include <boost/scoped_ptr.hpp>
< #include <boost/thread/once.hpp>
< 
< namespace apache { namespace thrift { namespace transport {
< 
< /**
<  * Winsock2 must be intialised once only in order to create sockets. This class
<  * performs a one time initialisation when create is called.
<  */
< class TWinsockSingleton : private boost::noncopyable
< {
< 
< public:
< 
<     typedef boost::scoped_ptr<TWinsockSingleton> instance_ptr;
< 
< private:
< 
<     friend void boost::call_once(void (*func)(void), boost::once_flag& flag);
< 
< private:
< 
<     TWinsockSingleton(void);
< 
< public:
< 
<     ~TWinsockSingleton(void);
< 
< public:
< 
<     static void create(void);
< 
< private:
< 
<     static void init(void);
< 
< private:
< 
<     static instance_ptr     instance_ptr_;
<     static boost::once_flag flags_;
< };
< 
< }}} // apache::thrift::transport
< 
< #endif // _THRIFT_TRANSPORT_WINDOWS_TWINSOCKSINGLETON_H_
---
> /*
>  * Licensed to the Apache Software Foundation (ASF) under one
>  * or more contributor license agreements. See the NOTICE file
>  * distributed with this work for additional information
>  * regarding copyright ownership. The ASF licenses this file
>  * to you under the Apache License, Version 2.0 (the
>  * "License"); you may not use this file except in compliance
>  * with the License. You may obtain a copy of the License at
>  *
>  *   http://www.apache.org/licenses/LICENSE-2.0
>  *
>  * Unless required by applicable law or agreed to in writing,
>  * software distributed under the License is distributed on an
>  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
>  * KIND, either express or implied. See the License for the
>  * specific language governing permissions and limitations
>  * under the License.
>  */
> 
> #ifndef _THRIFT_TRANSPORT_WINDOWS_TWINSOCKSINGLETON_H_
> #define _THRIFT_TRANSPORT_WINDOWS_TWINSOCKSINGLETON_H_ 1
> 
> #if defined(_MSC_VER) && (_MSC_VER > 1200)
> #pragma once
> #endif // _MSC_VER
> 
> #ifndef _WIN32
> #error This is a MSVC header only.
> #endif
> 
> // boost
> #include <boost/noncopyable.hpp>
> #include <boost/scoped_ptr.hpp>
> #include <boost/thread/once.hpp>
> 
> namespace apache { namespace thrift { namespace transport {
> 
> /**
>  * Winsock2 must be intialised once only in order to create sockets. This class
>  * performs a one time initialisation when create is called.
>  */
> class TWinsockSingleton : private boost::noncopyable
> {
> 
> public:
> 
>     typedef boost::scoped_ptr<TWinsockSingleton> instance_ptr;
> 
> private:
> #ifndef _WINDOWS
>     friend void boost::call_once(void (*func)(void), boost::once_flag& flag);
> #endif
> private:
> 
>     TWinsockSingleton(void);
> 
> public:
> 
>     ~TWinsockSingleton(void);
> 
> public:
> 
>     static void create(void);
> 
> private:
> 
>     static void init(void);
> 
> private:
> 
>     static instance_ptr     instance_ptr_;
>     static boost::once_flag flags_;
> };
> 
> }}} // apache::thrift::transport
> 
> #endif // _THRIFT_TRANSPORT_WINDOWS_TWINSOCKSINGLETON_H_
