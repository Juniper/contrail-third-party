1,156c1,238
< <?xml version="1.0" encoding="utf-8"?>
< <Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
<   <ItemGroup Label="ProjectConfigurations">
<     <ProjectConfiguration Include="Debug|Win32">
<       <Configuration>Debug</Configuration>
<       <Platform>Win32</Platform>
<     </ProjectConfiguration>
<     <ProjectConfiguration Include="Release|Win32">
<       <Configuration>Release</Configuration>
<       <Platform>Win32</Platform>
<     </ProjectConfiguration>
<   </ItemGroup>
<   <ItemGroup>
<     <ClInclude Include="src\generate\t_generator.h" />
<     <ClInclude Include="src\generate\t_generator_registry.h" />
<     <ClInclude Include="src\generate\t_oop_generator.h" />
<     <ClInclude Include="src\globals.h" />
<     <ClInclude Include="src\main.h" />
<     <ClInclude Include="src\md5.h" />
<     <ClInclude Include="src\parse\t_base_type.h" />
<     <ClInclude Include="src\parse\t_const.h" />
<     <ClInclude Include="src\parse\t_const_value.h" />
<     <ClInclude Include="src\parse\t_container.h" />
<     <ClInclude Include="src\parse\t_doc.h" />
<     <ClInclude Include="src\parse\t_enum.h" />
<     <ClInclude Include="src\parse\t_enum_value.h" />
<     <ClInclude Include="src\parse\t_field.h" />
<     <ClInclude Include="src\parse\t_function.h" />
<     <ClInclude Include="src\parse\t_list.h" />
<     <ClInclude Include="src\parse\t_map.h" />
<     <ClInclude Include="src\parse\t_program.h" />
<     <ClInclude Include="src\parse\t_scope.h" />
<     <ClInclude Include="src\parse\t_service.h" />
<     <ClInclude Include="src\parse\t_set.h" />
<     <ClInclude Include="src\parse\t_struct.h" />
<     <ClInclude Include="src\parse\t_type.h" />
<     <ClInclude Include="src\parse\t_typedef.h" />
<     <ClInclude Include="src\platform.h" />
<     <ClInclude Include="src\thrifty.h" />
<     <ClInclude Include="src\windows\config.h" />
<     <ClInclude Include="src\windows\version.h" />
<   </ItemGroup>
<   <ItemGroup>
<     <ClCompile Include="src\generate\t_as3_generator.cc" />
<     <ClCompile Include="src\generate\t_cocoa_generator.cc" />
<     <ClCompile Include="src\generate\t_cpp_generator.cc" />
<     <ClCompile Include="src\generate\t_csharp_generator.cc" />
<     <ClCompile Include="src\generate\t_c_glib_generator.cc" />
<     <ClCompile Include="src\generate\t_erl_generator.cc" />
<     <ClCompile Include="src\generate\t_generator.cc" />
<     <ClCompile Include="src\generate\t_go_generator.cc" />
<     <ClCompile Include="src\generate\t_hs_generator.cc" />
<     <ClCompile Include="src\generate\t_html_generator.cc" />
<     <ClCompile Include="src\generate\t_javame_generator.cc" />
<     <ClCompile Include="src\generate\t_java_generator.cc" />
<     <ClCompile Include="src\generate\t_js_generator.cc" />
<     <ClCompile Include="src\generate\t_ocaml_generator.cc" />
<     <ClCompile Include="src\generate\t_perl_generator.cc" />
<     <ClCompile Include="src\generate\t_php_generator.cc" />
<     <ClCompile Include="src\generate\t_py_generator.cc" />
<     <ClCompile Include="src\generate\t_rb_generator.cc" />
<     <ClCompile Include="src\generate\t_st_generator.cc" />
<     <ClCompile Include="src\generate\t_xsd_generator.cc" />
<     <ClCompile Include="src\main.cc" />
<     <ClCompile Include="src\md5.c" />
<     <ClCompile Include="src\parse\parse.cc" />
<     <ClCompile Include="src\thriftl.cc" />
<     <ClCompile Include="src\thrifty.cc" />
<   </ItemGroup>
<   <ItemGroup>
<     <None Include="README_WINDOWS" />
<     <None Include="src\thriftl.ll" />
<     <None Include="src\thrifty.yy" />
<   </ItemGroup>
<   <PropertyGroup Label="Globals">
<     <ProjectGuid>{89975A1A-F799-4556-98B8-64E30AB39A90}</ProjectGuid>
<     <Keyword>Win32Proj</Keyword>
<     <RootNamespace>compiler</RootNamespace>
<   </PropertyGroup>
<   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
<   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
<     <ConfigurationType>Application</ConfigurationType>
<     <UseDebugLibraries>true</UseDebugLibraries>
<     <CharacterSet>MultiByte</CharacterSet>
<   </PropertyGroup>
<   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
<     <ConfigurationType>Application</ConfigurationType>
<     <UseDebugLibraries>false</UseDebugLibraries>
<     <WholeProgramOptimization>true</WholeProgramOptimization>
<     <CharacterSet>MultiByte</CharacterSet>
<   </PropertyGroup>
<   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
<   <ImportGroup Label="ExtensionSettings">
<   </ImportGroup>
<   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
<     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
<   </ImportGroup>
<   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
<     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
<   </ImportGroup>
<   <PropertyGroup Label="UserMacros" />
<   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
<     <LinkIncremental>true</LinkIncremental>
<     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(IncludePath)</IncludePath>
<     <TargetName>thrift</TargetName>
<   </PropertyGroup>
<   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
<     <LinkIncremental>false</LinkIncremental>
<     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(IncludePath)</IncludePath>
<     <TargetName>thrift</TargetName>
<   </PropertyGroup>
<   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
<     <ClCompile>
<       <PrecompiledHeader>
<       </PrecompiledHeader>
<       <WarningLevel>Level3</WarningLevel>
<       <Optimization>Disabled</Optimization>
<       <PreprocessorDefinitions>WIN32;MINGW;YY_NO_UNISTD_H;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <ForcedIncludeFiles>config.h</ForcedIncludeFiles>
<       <CompileAs>CompileAsCpp</CompileAs>
<     </ClCompile>
<     <Link>
<       <SubSystem>Console</SubSystem>
<       <GenerateDebugInformation>true</GenerateDebugInformation>
<     </Link>
<     <PreBuildEvent>
<       <Command>flex -o "src/thriftl.cc" src/thriftl.ll
< bison -y -o "src/thrifty.cc" --defines="src/thrifty.h" src/thrifty.yy</Command>
<     </PreBuildEvent>
<   </ItemDefinitionGroup>
<   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
<     <ClCompile>
<       <WarningLevel>Level3</WarningLevel>
<       <PrecompiledHeader>
<       </PrecompiledHeader>
<       <Optimization>MaxSpeed</Optimization>
<       <FunctionLevelLinking>true</FunctionLevelLinking>
<       <IntrinsicFunctions>true</IntrinsicFunctions>
<       <PreprocessorDefinitions>WIN32;MINGW;YY_NO_UNISTD_H;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
<       <ForcedIncludeFiles>config.h</ForcedIncludeFiles>
<       <CompileAs>CompileAsCpp</CompileAs>
<     </ClCompile>
<     <Link>
<       <SubSystem>Console</SubSystem>
<       <GenerateDebugInformation>true</GenerateDebugInformation>
<       <EnableCOMDATFolding>true</EnableCOMDATFolding>
<       <OptimizeReferences>true</OptimizeReferences>
<     </Link>
<     <PreBuildEvent>
<       <Command>flex -o "src/thriftl.cc" src/thriftl.ll
< bison -y -o "src/thrifty.cc" --defines="src/thrifty.h" src/thrifty.yy</Command>
<     </PreBuildEvent>
<   </ItemDefinitionGroup>
<   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
<   <ImportGroup Label="ExtensionTargets">
<   </ImportGroup>
---
> <?xml version="1.0" encoding="utf-8"?>
> <Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
>   <ItemGroup Label="ProjectConfigurations">
>     <ProjectConfiguration Include="Debug|Win32">
>       <Configuration>Debug</Configuration>
>       <Platform>Win32</Platform>
>     </ProjectConfiguration>
>     <ProjectConfiguration Include="Debug|x64">
>       <Configuration>Debug</Configuration>
>       <Platform>x64</Platform>
>     </ProjectConfiguration>
>     <ProjectConfiguration Include="Release|Win32">
>       <Configuration>Release</Configuration>
>       <Platform>Win32</Platform>
>     </ProjectConfiguration>
>     <ProjectConfiguration Include="Release|x64">
>       <Configuration>Release</Configuration>
>       <Platform>x64</Platform>
>     </ProjectConfiguration>
>   </ItemGroup>
>   <ItemGroup>
>     <ClInclude Include="src\generate\t_generator.h" />
>     <ClInclude Include="src\generate\t_generator_registry.h" />
>     <ClInclude Include="src\generate\t_oop_generator.h" />
>     <ClInclude Include="src\globals.h" />
>     <ClInclude Include="src\main.h" />
>     <ClInclude Include="src\md5.h" />
>     <ClInclude Include="src\parse\t_base_type.h" />
>     <ClInclude Include="src\parse\t_const.h" />
>     <ClInclude Include="src\parse\t_const_value.h" />
>     <ClInclude Include="src\parse\t_container.h" />
>     <ClInclude Include="src\parse\t_doc.h" />
>     <ClInclude Include="src\parse\t_enum.h" />
>     <ClInclude Include="src\parse\t_enum_value.h" />
>     <ClInclude Include="src\parse\t_field.h" />
>     <ClInclude Include="src\parse\t_function.h" />
>     <ClInclude Include="src\parse\t_list.h" />
>     <ClInclude Include="src\parse\t_map.h" />
>     <ClInclude Include="src\parse\t_program.h" />
>     <ClInclude Include="src\parse\t_scope.h" />
>     <ClInclude Include="src\parse\t_service.h" />
>     <ClInclude Include="src\parse\t_set.h" />
>     <ClInclude Include="src\parse\t_struct.h" />
>     <ClInclude Include="src\parse\t_type.h" />
>     <ClInclude Include="src\parse\t_typedef.h" />
>     <ClInclude Include="src\platform.h" />
>     <ClInclude Include="src\thrifty.h" />
>     <ClInclude Include="src\windows\config.h" />
>     <ClInclude Include="src\windows\version.h" />
>   </ItemGroup>
>   <ItemGroup>
>     <ClCompile Include="src\generate\t_as3_generator.cc" />
>     <ClCompile Include="src\generate\t_cocoa_generator.cc" />
>     <ClCompile Include="src\generate\t_cpp_generator.cc" />
>     <ClCompile Include="src\generate\t_csharp_generator.cc" />
>     <ClCompile Include="src\generate\t_c_glib_generator.cc" />
>     <ClCompile Include="src\generate\t_erl_generator.cc" />
>     <ClCompile Include="src\generate\t_generator.cc" />
>     <ClCompile Include="src\generate\t_go_generator.cc" />
>     <ClCompile Include="src\generate\t_hs_generator.cc" />
>     <ClCompile Include="src\generate\t_html_generator.cc" />
>     <ClCompile Include="src\generate\t_javame_generator.cc" />
>     <ClCompile Include="src\generate\t_java_generator.cc" />
>     <ClCompile Include="src\generate\t_js_generator.cc" />
>     <ClCompile Include="src\generate\t_ocaml_generator.cc" />
>     <ClCompile Include="src\generate\t_perl_generator.cc" />
>     <ClCompile Include="src\generate\t_php_generator.cc" />
>     <ClCompile Include="src\generate\t_py_generator.cc" />
>     <ClCompile Include="src\generate\t_rb_generator.cc" />
>     <ClCompile Include="src\generate\t_st_generator.cc" />
>     <ClCompile Include="src\generate\t_xsd_generator.cc" />
>     <ClCompile Include="src\main.cc" />
>     <ClCompile Include="src\md5.c" />
>     <ClCompile Include="src\parse\parse.cc" />
>     <ClCompile Include="src\thrifty.cc" />
>     <ClCompile Include="thriftl.cc" />
>   </ItemGroup>
>   <ItemGroup>
>     <None Include="README_WINDOWS" />
>     <None Include="src\thriftl.ll" />
>     <None Include="src\thrifty.yy" />
>   </ItemGroup>
>   <PropertyGroup Label="Globals">
>     <ProjectGuid>{89975A1A-F799-4556-98B8-64E30AB39A90}</ProjectGuid>
>     <Keyword>Win32Proj</Keyword>
>     <RootNamespace>compiler</RootNamespace>
>     <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
>   </PropertyGroup>
>   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
>     <ConfigurationType>Application</ConfigurationType>
>     <UseDebugLibraries>true</UseDebugLibraries>
>     <CharacterSet>MultiByte</CharacterSet>
>     <PlatformToolset>v140</PlatformToolset>
>   </PropertyGroup>
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
>     <ConfigurationType>Application</ConfigurationType>
>     <UseDebugLibraries>true</UseDebugLibraries>
>     <CharacterSet>MultiByte</CharacterSet>
>     <PlatformToolset>v140</PlatformToolset>
>   </PropertyGroup>
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
>     <ConfigurationType>Application</ConfigurationType>
>     <UseDebugLibraries>false</UseDebugLibraries>
>     <WholeProgramOptimization>true</WholeProgramOptimization>
>     <CharacterSet>MultiByte</CharacterSet>
>     <PlatformToolset>v140</PlatformToolset>
>   </PropertyGroup>
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
>     <ConfigurationType>Application</ConfigurationType>
>     <UseDebugLibraries>false</UseDebugLibraries>
>     <WholeProgramOptimization>true</WholeProgramOptimization>
>     <CharacterSet>MultiByte</CharacterSet>
>     <PlatformToolset>v140</PlatformToolset>
>   </PropertyGroup>
>   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
>   <ImportGroup Label="ExtensionSettings">
>   </ImportGroup>
>   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
>     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
>   </ImportGroup>
>   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
>     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
>   </ImportGroup>
>   <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
>     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
>   </ImportGroup>
>   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
>     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
>   </ImportGroup>
>   <PropertyGroup Label="UserMacros" />
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
>     <LinkIncremental>true</LinkIncremental>
>     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(IncludePath)</IncludePath>
>     <TargetName>thrift</TargetName>
>   </PropertyGroup>
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
>     <LinkIncremental>true</LinkIncremental>
>     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(IncludePath)</IncludePath>
>     <TargetName>thrift</TargetName>
>   </PropertyGroup>
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
>     <LinkIncremental>false</LinkIncremental>
>     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(IncludePath)</IncludePath>
>     <TargetName>thrift</TargetName>
>   </PropertyGroup>
>   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
>     <LinkIncremental>false</LinkIncremental>
>     <IncludePath>$(ProjectDir)\src\;$(ProjectDir)\src\windows\;$(IncludePath)</IncludePath>
>     <TargetName>thrift</TargetName>
>   </PropertyGroup>
>   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
>     <ClCompile>
>       <PrecompiledHeader>
>       </PrecompiledHeader>
>       <WarningLevel>Level3</WarningLevel>
>       <Optimization>Disabled</Optimization>
>       <PreprocessorDefinitions>WIN32;MINGW;YY_NO_UNISTD_H;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <ForcedIncludeFiles>config.h</ForcedIncludeFiles>
>       <CompileAs>CompileAsCpp</CompileAs>
>     </ClCompile>
>     <Link>
>       <SubSystem>Console</SubSystem>
>       <GenerateDebugInformation>true</GenerateDebugInformation>
>     </Link>
>     <PreBuildEvent>
>       <Command>flex -o "src/thriftl.cc" src/thriftl.ll
> bison -y -o "src/thrifty.cc" --defines="src/thrifty.h" src/thrifty.yy</Command>
>     </PreBuildEvent>
>   </ItemDefinitionGroup>
>   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
>     <ClCompile>
>       <PrecompiledHeader>
>       </PrecompiledHeader>
>       <WarningLevel>Level3</WarningLevel>
>       <Optimization>Disabled</Optimization>
>       <PreprocessorDefinitions>WIN32;MINGW;YY_NO_UNISTD_H;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <ForcedIncludeFiles>config.h</ForcedIncludeFiles>
>       <CompileAs>CompileAsCpp</CompileAs>
>     </ClCompile>
>     <Link>
>       <SubSystem>Console</SubSystem>
>       <GenerateDebugInformation>true</GenerateDebugInformation>
>     </Link>
>     <PreBuildEvent>
>       <Command>flex -o "src/thriftl.cc" src/thriftl.ll
> bison -y -o "src/thrifty.cc" --defines="src/thrifty.h" src/thrifty.yy</Command>
>     </PreBuildEvent>
>   </ItemDefinitionGroup>
>   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
>     <ClCompile>
>       <WarningLevel>Level3</WarningLevel>
>       <PrecompiledHeader>
>       </PrecompiledHeader>
>       <Optimization>MaxSpeed</Optimization>
>       <FunctionLevelLinking>true</FunctionLevelLinking>
>       <IntrinsicFunctions>true</IntrinsicFunctions>
>       <PreprocessorDefinitions>WIN32;MINGW;YY_NO_UNISTD_H;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <ForcedIncludeFiles>config.h</ForcedIncludeFiles>
>       <CompileAs>CompileAsCpp</CompileAs>
>     </ClCompile>
>     <Link>
>       <SubSystem>Console</SubSystem>
>       <GenerateDebugInformation>true</GenerateDebugInformation>
>       <EnableCOMDATFolding>true</EnableCOMDATFolding>
>       <OptimizeReferences>true</OptimizeReferences>
>     </Link>
>     <PreBuildEvent>
>       <Command>flex -o "src/thriftl.cc" src/thriftl.ll
> bison -y -o "src/thrifty.cc" --defines="src/thrifty.h" src/thrifty.yy</Command>
>     </PreBuildEvent>
>   </ItemDefinitionGroup>
>   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
>     <ClCompile>
>       <WarningLevel>Level3</WarningLevel>
>       <PrecompiledHeader>
>       </PrecompiledHeader>
>       <Optimization>MaxSpeed</Optimization>
>       <FunctionLevelLinking>true</FunctionLevelLinking>
>       <IntrinsicFunctions>true</IntrinsicFunctions>
>       <PreprocessorDefinitions>WIN32;MINGW;YY_NO_UNISTD_H;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
>       <ForcedIncludeFiles>config.h</ForcedIncludeFiles>
>       <CompileAs>CompileAsCpp</CompileAs>
>     </ClCompile>
>     <Link>
>       <SubSystem>Console</SubSystem>
>       <GenerateDebugInformation>true</GenerateDebugInformation>
>       <EnableCOMDATFolding>true</EnableCOMDATFolding>
>       <OptimizeReferences>true</OptimizeReferences>
>     </Link>
>     <PreBuildEvent>
>       <Command>flex -o "src/thriftl.cc" src/thriftl.ll
> bison -y -o "src/thrifty.cc" --defines="src/thrifty.h" src/thrifty.yy</Command>
>     </PreBuildEvent>
>   </ItemDefinitionGroup>
>   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
>   <ImportGroup Label="ExtensionTargets">
>   </ImportGroup>
1,1188c1,1188
< %{
< /*
<  * Licensed to the Apache Software Foundation (ASF) under one
<  * or more contributor license agreements. See the NOTICE file
<  * distributed with this work for additional information
<  * regarding copyright ownership. The ASF licenses this file
<  * to you under the Apache License, Version 2.0 (the
<  * "License"); you may not use this file except in compliance
<  * with the License. You may obtain a copy of the License at
<  *
<  *   http://www.apache.org/licenses/LICENSE-2.0
<  *
<  * Unless required by applicable law or agreed to in writing,
<  * software distributed under the License is distributed on an
<  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
<  * KIND, either express or implied. See the License for the
<  * specific language governing permissions and limitations
<  * under the License.
<  */
< 
< /**
<  * Thrift parser.
<  *
<  * This parser is used on a thrift definition file.
<  *
<  */
< 
< #define __STDC_LIMIT_MACROS
< #define __STDC_FORMAT_MACROS
< #include <stdio.h>
< #include <inttypes.h>
< #include <limits.h>
< #include "main.h"
< #include "globals.h"
< #include "parse/t_program.h"
< #include "parse/t_scope.h"
< 
< /**
<  * This global variable is used for automatic numbering of field indices etc.
<  * when parsing the members of a struct. Field values are automatically
<  * assigned starting from -1 and working their way down.
<  */
< int y_field_val = -1;
< int g_arglist = 0;
< const int struct_is_struct = 0;
< const int struct_is_union = 1;
< 
< %}
< 
< /**
<  * This structure is used by the parser to hold the data types associated with
<  * various parse nodes.
<  */
< %union {
<   char*          id;
<   int64_t        iconst;
<   double         dconst;
<   bool           tbool;
<   t_doc*         tdoc;
<   t_type*        ttype;
<   t_base_type*   tbase;
<   t_typedef*     ttypedef;
<   t_enum*        tenum;
<   t_enum_value*  tenumv;
<   t_const*       tconst;
<   t_const_value* tconstv;
<   t_struct*      tstruct;
<   t_service*     tservice;
<   t_function*    tfunction;
<   t_field*       tfield;
<   char*          dtext;
<   t_field::e_req ereq;
<   t_annotation*  tannot;
<   t_field_id     tfieldid;
< }
< 
< /**
<  * Strings identifier
<  */
< %token<id>     tok_identifier
< %token<id>     tok_literal
< %token<dtext>  tok_doctext
< %token<id>     tok_st_identifier
< 
< /**
<  * Constant values
<  */
< %token<iconst> tok_int_constant
< %token<dconst> tok_dub_constant
< 
< /**
<  * Header keywords
<  */
< %token tok_include
< %token tok_namespace
< %token tok_cpp_namespace
< %token tok_cpp_include
< %token tok_cpp_type
< %token tok_php_namespace
< %token tok_py_module
< %token tok_perl_package
< %token tok_java_package
< %token tok_xsd_all
< %token tok_xsd_optional
< %token tok_xsd_nillable
< %token tok_xsd_namespace
< %token tok_xsd_attrs
< %token tok_ruby_namespace
< %token tok_smalltalk_category
< %token tok_smalltalk_prefix
< %token tok_cocoa_prefix
< %token tok_csharp_namespace
< %token tok_delphi_namespace
< 
< /**
<  * Base datatype keywords
<  */
< %token tok_void
< %token tok_bool
< %token tok_byte
< %token tok_string
< %token tok_binary
< %token tok_slist
< %token tok_senum
< %token tok_i16
< %token tok_i32
< %token tok_i64
< %token tok_double
< 
< /**
<  * Complex type keywords
<  */
< %token tok_map
< %token tok_list
< %token tok_set
< 
< /**
<  * Function modifiers
<  */
< %token tok_oneway
< 
< /**
<  * Thrift language keywords
<  */
< %token tok_typedef
< %token tok_struct
< %token tok_xception
< %token tok_throws
< %token tok_extends
< %token tok_service
< %token tok_enum
< %token tok_const
< %token tok_required
< %token tok_optional
< %token tok_union
< 
< /**
<  * Grammar nodes
<  */
< 
< %type<ttype>     BaseType
< %type<ttype>     SimpleBaseType
< %type<ttype>     ContainerType
< %type<ttype>     SimpleContainerType
< %type<ttype>     MapType
< %type<ttype>     SetType
< %type<ttype>     ListType
< 
< %type<tdoc>      Definition
< %type<ttype>     TypeDefinition
< 
< %type<ttypedef>  Typedef
< 
< %type<ttype>     TypeAnnotations
< %type<ttype>     TypeAnnotationList
< %type<tannot>    TypeAnnotation
< 
< %type<tfield>    Field
< %type<tfieldid>  FieldIdentifier
< %type<ereq>      FieldRequiredness
< %type<ttype>     FieldType
< %type<tconstv>   FieldValue
< %type<tstruct>   FieldList
< 
< %type<tenum>     Enum
< %type<tenum>     EnumDefList
< %type<tenumv>    EnumDef
< 
< %type<ttypedef>  Senum
< %type<tbase>     SenumDefList
< %type<id>        SenumDef
< 
< %type<tconst>    Const
< %type<tconstv>   ConstValue
< %type<tconstv>   ConstList
< %type<tconstv>   ConstListContents
< %type<tconstv>   ConstMap
< %type<tconstv>   ConstMapContents
< 
< %type<iconst>    StructHead
< %type<tstruct>   Struct
< %type<tstruct>   Xception
< %type<tservice>  Service
< 
< %type<tfunction> Function
< %type<ttype>     FunctionType
< %type<tservice>  FunctionList
< 
< %type<tstruct>   Throws
< %type<tservice>  Extends
< %type<tbool>     Oneway
< %type<tbool>     XsdAll
< %type<tbool>     XsdOptional
< %type<tbool>     XsdNillable
< %type<tstruct>   XsdAttributes
< %type<id>        CppType
< 
< %type<dtext>     CaptureDocText
< 
< %%
< 
< /**
<  * Thrift Grammar Implementation.
<  *
<  * For the most part this source file works its way top down from what you
<  * might expect to find in a typical .thrift file, i.e. type definitions and
<  * namespaces up top followed by service definitions using those types.
<  */
< 
< Program:
<   HeaderList DefinitionList
<     {
<       pdebug("Program -> Headers DefinitionList");
<       /*
<       TODO(dreiss): Decide whether full-program doctext is worth the trouble.
<       if ($1 != NULL) {
<         g_program->set_doc($1);
<       }
<       */
<       clear_doctext();
<     }
< 
< CaptureDocText:
<     {
<       if (g_parse_mode == PROGRAM) {
<         $$ = g_doctext;
<         g_doctext = NULL;
<       } else {
<         $$ = NULL;
<       }
<     }
< 
< /* TODO(dreiss): Try to DestroyDocText in all sorts or random places. */
< DestroyDocText:
<     {
<       if (g_parse_mode == PROGRAM) {
<         clear_doctext();
<       }
<     }
< 
< /* We have to DestroyDocText here, otherwise it catches the doctext
<    on the first real element. */
< HeaderList:
<   HeaderList DestroyDocText Header
<     {
<       pdebug("HeaderList -> HeaderList Header");
<     }
< |
<     {
<       pdebug("HeaderList -> ");
<     }
< 
< Header:
<   Include
<     {
<       pdebug("Header -> Include");
<     }
< | tok_namespace tok_identifier tok_identifier
<     {
<       pdebug("Header -> tok_namespace tok_identifier tok_identifier");
<       if (g_parse_mode == PROGRAM) {
<         g_program->set_namespace($2, $3);
<       }
<     }
< | tok_namespace '*' tok_identifier
<     {
<       pdebug("Header -> tok_namespace * tok_identifier");
<       if (g_parse_mode == PROGRAM) {
<         g_program->set_namespace("*", $3);
<       }
<     }
< /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
< | tok_cpp_namespace tok_identifier
<     {
<       pwarning(1, "'cpp_namespace' is deprecated. Use 'namespace cpp' instead");
<       pdebug("Header -> tok_cpp_namespace tok_identifier");
<       if (g_parse_mode == PROGRAM) {
<         g_program->set_namespace("cpp", $2);
<       }
<     }
< | tok_cpp_include tok_literal
<     {
<       pdebug("Header -> tok_cpp_include tok_literal");
<       if (g_parse_mode == PROGRAM) {
<         g_program->add_cpp_include($2);
<       }
<     }
< | tok_php_namespace tok_identifier
<     {
<       pwarning(1, "'php_namespace' is deprecated. Use 'namespace php' instead");
<       pdebug("Header -> tok_php_namespace tok_identifier");
<       if (g_parse_mode == PROGRAM) {
<         g_program->set_namespace("php", $2);
<       }
<     }
< /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
< | tok_py_module tok_identifier
<     {
<       pwarning(1, "'py_module' is deprecated. Use 'namespace py' instead");
<       pdebug("Header -> tok_py_module tok_identifier");
<       if (g_parse_mode == PROGRAM) {
<         g_program->set_namespace("py", $2);
<       }
<     }
< /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
< | tok_perl_package tok_identifier
<     {
<       pwarning(1, "'perl_package' is deprecated. Use 'namespace perl' instead");
<       pdebug("Header -> tok_perl_namespace tok_identifier");
<       if (g_parse_mode == PROGRAM) {
<         g_program->set_namespace("perl", $2);
<       }
<     }
< /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
< | tok_ruby_namespace tok_identifier
<     {
<       pwarning(1, "'ruby_namespace' is deprecated. Use 'namespace rb' instead");
<       pdebug("Header -> tok_ruby_namespace tok_identifier");
<       if (g_parse_mode == PROGRAM) {
<         g_program->set_namespace("rb", $2);
<       }
<     }
< /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
< | tok_smalltalk_category tok_st_identifier
<     {
<       pwarning(1, "'smalltalk_category' is deprecated. Use 'namespace smalltalk.category' instead");
<       pdebug("Header -> tok_smalltalk_category tok_st_identifier");
<       if (g_parse_mode == PROGRAM) {
<         g_program->set_namespace("smalltalk.category", $2);
<       }
<     }
< /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
< | tok_smalltalk_prefix tok_identifier
<     {
<       pwarning(1, "'smalltalk_prefix' is deprecated. Use 'namespace smalltalk.prefix' instead");
<       pdebug("Header -> tok_smalltalk_prefix tok_identifier");
<       if (g_parse_mode == PROGRAM) {
<         g_program->set_namespace("smalltalk.prefix", $2);
<       }
<     }
< /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
< | tok_java_package tok_identifier
<     {
<       pwarning(1, "'java_package' is deprecated. Use 'namespace java' instead");
<       pdebug("Header -> tok_java_package tok_identifier");
<       if (g_parse_mode == PROGRAM) {
<         g_program->set_namespace("java", $2);
<       }
<     }
< /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
< | tok_cocoa_prefix tok_identifier
<     {
<       pwarning(1, "'cocoa_prefix' is deprecated. Use 'namespace cocoa' instead");
<       pdebug("Header -> tok_cocoa_prefix tok_identifier");
<       if (g_parse_mode == PROGRAM) {
<         g_program->set_namespace("cocoa", $2);
<       }
<     }
< /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
< | tok_xsd_namespace tok_literal
<     {
<       pwarning(1, "'xsd_namespace' is deprecated. Use 'namespace xsd' instead");
<       pdebug("Header -> tok_xsd_namespace tok_literal");
<       if (g_parse_mode == PROGRAM) {
<         g_program->set_namespace("cocoa", $2);
<       }
<     }
< /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
< | tok_csharp_namespace tok_identifier
<    {
<      pwarning(1, "'csharp_namespace' is deprecated. Use 'namespace csharp' instead");
<      pdebug("Header -> tok_csharp_namespace tok_identifier");
<      if (g_parse_mode == PROGRAM) {
<        g_program->set_namespace("csharp", $2);
<      }
<    }
< /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
< | tok_delphi_namespace tok_identifier
<    {
<      pwarning(1, "'delphi_namespace' is deprecated. Use 'namespace delphi' instead");
<      pdebug("Header -> tok_delphi_namespace tok_identifier");
<      if (g_parse_mode == PROGRAM) {
<        g_program->set_namespace("delphi", $2);
<      }
<    }
< 
< Include:
<   tok_include tok_literal
<     {
<       pdebug("Include -> tok_include tok_literal");
<       if (g_parse_mode == INCLUDES) {
<         std::string path = include_file(std::string($2));
<         if (!path.empty()) {
<           g_program->add_include(path, std::string($2));
<         }
<       }
<     }
< 
< DefinitionList:
<   DefinitionList CaptureDocText Definition
<     {
<       pdebug("DefinitionList -> DefinitionList Definition");
<       if ($2 != NULL && $3 != NULL) {
<         $3->set_doc($2);
<       }
<     }
< |
<     {
<       pdebug("DefinitionList -> ");
<     }
< 
< Definition:
<   Const
<     {
<       pdebug("Definition -> Const");
<       if (g_parse_mode == PROGRAM) {
<         g_program->add_const($1);
<       }
<       $$ = $1;
<     }
< | TypeDefinition
<     {
<       pdebug("Definition -> TypeDefinition");
<       if (g_parse_mode == PROGRAM) {
<         g_scope->add_type($1->get_name(), $1);
<         if (g_parent_scope != NULL) {
<           g_parent_scope->add_type(g_parent_prefix + $1->get_name(), $1);
<         }
<       }
<       $$ = $1;
<     }
< | Service
<     {
<       pdebug("Definition -> Service");
<       if (g_parse_mode == PROGRAM) {
<         g_scope->add_service($1->get_name(), $1);
<         if (g_parent_scope != NULL) {
<           g_parent_scope->add_service(g_parent_prefix + $1->get_name(), $1);
<         }
<         g_program->add_service($1);
<       }
<       $$ = $1;
<     }
< 
< TypeDefinition:
<   Typedef
<     {
<       pdebug("TypeDefinition -> Typedef");
<       if (g_parse_mode == PROGRAM) {
<         g_program->add_typedef($1);
<       }
<     }
< | Enum
<     {
<       pdebug("TypeDefinition -> Enum");
<       if (g_parse_mode == PROGRAM) {
<         g_program->add_enum($1);
<       }
<     }
< | Senum
<     {
<       pdebug("TypeDefinition -> Senum");
<       if (g_parse_mode == PROGRAM) {
<         g_program->add_typedef($1);
<       }
<     }
< | Struct
<     {
<       pdebug("TypeDefinition -> Struct");
<       if (g_parse_mode == PROGRAM) {
<         g_program->add_struct($1);
<       }
<     }
< | Xception
<     {
<       pdebug("TypeDefinition -> Xception");
<       if (g_parse_mode == PROGRAM) {
<         g_program->add_xception($1);
<       }
<     }
< 
< Typedef:
<   tok_typedef FieldType tok_identifier
<     {
<       pdebug("TypeDef -> tok_typedef FieldType tok_identifier");
<       t_typedef *td = new t_typedef(g_program, $2, $3);
<       $$ = td;
<     }
< 
< CommaOrSemicolonOptional:
<   ','
<     {}
< | ';'
<     {}
< |
<     {}
< 
< Enum:
<   tok_enum tok_identifier '{' EnumDefList '}'
<     {
<       pdebug("Enum -> tok_enum tok_identifier { EnumDefList }");
<       $$ = $4;
<       $$->set_name($2);
<       $$->resolve_values();
<       // make constants for all the enum values
<       if (g_parse_mode == PROGRAM) {
<         const std::vector<t_enum_value*>& enum_values = $$->get_constants();
<         std::vector<t_enum_value*>::const_iterator c_iter;
<         for (c_iter = enum_values.begin(); c_iter != enum_values.end(); ++c_iter) {
<           std::string const_name = $$->get_name() + "." + (*c_iter)->get_name();
<           t_const_value* const_val = new t_const_value((*c_iter)->get_value());
<           const_val->set_enum($$);
<           g_scope->add_constant(const_name, new t_const(g_type_i32, (*c_iter)->get_name(), const_val));
<           if (g_parent_scope != NULL) {
<             g_parent_scope->add_constant(g_parent_prefix + const_name, new t_const(g_type_i32, (*c_iter)->get_name(), const_val));
<           }
<         }
<       }
<     }
< 
< EnumDefList:
<   EnumDefList EnumDef
<     {
<       pdebug("EnumDefList -> EnumDefList EnumDef");
<       $$ = $1;
<       $$->append($2);
<     }
< |
<     {
<       pdebug("EnumDefList -> ");
<       $$ = new t_enum(g_program);
<     }
< 
< EnumDef:
<   CaptureDocText tok_identifier '=' tok_int_constant CommaOrSemicolonOptional
<     {
<       pdebug("EnumDef -> tok_identifier = tok_int_constant");
<       if ($4 < 0) {
<         pwarning(1, "Negative value supplied for enum %s.\n", $2);
<       }
<       if ($4 > INT_MAX) {
<         pwarning(1, "64-bit value supplied for enum %s.\n", $2);
<       }
<       $$ = new t_enum_value($2, $4);
<       if ($1 != NULL) {
<         $$->set_doc($1);
<       }
<     }
< |
<   CaptureDocText tok_identifier CommaOrSemicolonOptional
<     {
<       pdebug("EnumDef -> tok_identifier");
<       $$ = new t_enum_value($2);
<       if ($1 != NULL) {
<         $$->set_doc($1);
<       }
<     }
< 
< Senum:
<   tok_senum tok_identifier '{' SenumDefList '}'
<     {
<       pdebug("Senum -> tok_senum tok_identifier { SenumDefList }");
<       $$ = new t_typedef(g_program, $4, $2);
<     }
< 
< SenumDefList:
<   SenumDefList SenumDef
<     {
<       pdebug("SenumDefList -> SenumDefList SenumDef");
<       $$ = $1;
<       $$->add_string_enum_val($2);
<     }
< |
<     {
<       pdebug("SenumDefList -> ");
<       $$ = new t_base_type("string", t_base_type::TYPE_STRING);
<       $$->set_string_enum(true);
<     }
< 
< SenumDef:
<   tok_literal CommaOrSemicolonOptional
<     {
<       pdebug("SenumDef -> tok_literal");
<       $$ = $1;
<     }
< 
< Const:
<   tok_const FieldType tok_identifier '=' ConstValue CommaOrSemicolonOptional
<     {
<       pdebug("Const -> tok_const FieldType tok_identifier = ConstValue");
<       if (g_parse_mode == PROGRAM) {
<         g_scope->resolve_const_value($5, $2);
<         $$ = new t_const($2, $3, $5);
<         validate_const_type($$);
< 
<         g_scope->add_constant($3, $$);
<         if (g_parent_scope != NULL) {
<           g_parent_scope->add_constant(g_parent_prefix + $3, $$);
<         }
<       } else {
<         $$ = NULL;
<       }
<     }
< 
< ConstValue:
<   tok_int_constant
<     {
<       pdebug("ConstValue => tok_int_constant");
<       $$ = new t_const_value();
<       $$->set_integer($1);
<       if (!g_allow_64bit_consts && ($1 < INT32_MIN || $1 > INT32_MAX)) {
<         pwarning(1, "64-bit constant \"%"PRIi64"\" may not work in all languages.\n", $1);
<       }
<     }
< | tok_dub_constant
<     {
<       pdebug("ConstValue => tok_dub_constant");
<       $$ = new t_const_value();
<       $$->set_double($1);
<     }
< | tok_literal
<     {
<       pdebug("ConstValue => tok_literal");
<       $$ = new t_const_value($1);
<     }
< | tok_identifier
<     {
<       pdebug("ConstValue => tok_identifier");
<       $$ = new t_const_value();
<       $$->set_identifier($1);
<     }
< | ConstList
<     {
<       pdebug("ConstValue => ConstList");
<       $$ = $1;
<     }
< | ConstMap
<     {
<       pdebug("ConstValue => ConstMap");
<       $$ = $1;
<     }
< 
< ConstList:
<   '[' ConstListContents ']'
<     {
<       pdebug("ConstList => [ ConstListContents ]");
<       $$ = $2;
<     }
< 
< ConstListContents:
<   ConstListContents ConstValue CommaOrSemicolonOptional
<     {
<       pdebug("ConstListContents => ConstListContents ConstValue CommaOrSemicolonOptional");
<       $$ = $1;
<       $$->add_list($2);
<     }
< |
<     {
<       pdebug("ConstListContents =>");
<       $$ = new t_const_value();
<       $$->set_list();
<     }
< 
< ConstMap:
<   '{' ConstMapContents '}'
<     {
<       pdebug("ConstMap => { ConstMapContents }");
<       $$ = $2;
<     }
< 
< ConstMapContents:
<   ConstMapContents ConstValue ':' ConstValue CommaOrSemicolonOptional
<     {
<       pdebug("ConstMapContents => ConstMapContents ConstValue CommaOrSemicolonOptional");
<       $$ = $1;
<       $$->add_map($2, $4);
<     }
< |
<     {
<       pdebug("ConstMapContents =>");
<       $$ = new t_const_value();
<       $$->set_map();
<     }
< 
< StructHead:
<   tok_struct
<     {
<       $$ = struct_is_struct;
<     }
< | tok_union
<     {
<       $$ = struct_is_union;
<     }
< 
< Struct:
<   StructHead tok_identifier XsdAll '{' FieldList '}' TypeAnnotations
<     {
<       pdebug("Struct -> tok_struct tok_identifier { FieldList }");
<       $5->set_xsd_all($3);
<       $5->set_union($1 == struct_is_union);
<       $$ = $5;
<       $$->set_name($2);
<       if ($7 != NULL) {
<         $$->annotations_ = $7->annotations_;
<         delete $7;
<       }
<     }
<     
< XsdAll:
<   tok_xsd_all
<     {
<       $$ = true;
<     }
< |
<     {
<       $$ = false;
<     }
< 
< XsdOptional:
<   tok_xsd_optional
<     {
<       $$ = true;
<     }
< |
<     {
<       $$ = false;
<     }
< 
< XsdNillable:
<   tok_xsd_nillable
<     {
<       $$ = true;
<     }
< |
<     {
<       $$ = false;
<     }
< 
< XsdAttributes:
<   tok_xsd_attrs '{' FieldList '}'
<     {
<       $$ = $3;
<     }
< |
<     {
<       $$ = NULL;
<     }
< 
< Xception:
<   tok_xception tok_identifier '{' FieldList '}'
<     {
<       pdebug("Xception -> tok_xception tok_identifier { FieldList }");
<       $4->set_name($2);
<       $4->set_xception(true);
<       $$ = $4;
<     }
< 
< Service:
<   tok_service tok_identifier Extends '{' FlagArgs FunctionList UnflagArgs '}'
<     {
<       pdebug("Service -> tok_service tok_identifier { FunctionList }");
<       $$ = $6;
<       $$->set_name($2);
<       $$->set_extends($3);
<     }
< 
< FlagArgs:
<     {
<        g_arglist = 1;
<     }
< 
< UnflagArgs:
<     {
<        g_arglist = 0;
<     }
< 
< Extends:
<   tok_extends tok_identifier
<     {
<       pdebug("Extends -> tok_extends tok_identifier");
<       $$ = NULL;
<       if (g_parse_mode == PROGRAM) {
<         $$ = g_scope->get_service($2);
<         if ($$ == NULL) {
<           yyerror("Service \"%s\" has not been defined.", $2);
<           exit(1);
<         }
<       }
<     }
< |
<     {
<       $$ = NULL;
<     }
< 
< FunctionList:
<   FunctionList Function
<     {
<       pdebug("FunctionList -> FunctionList Function");
<       $$ = $1;
<       $1->add_function($2);
<     }
< |
<     {
<       pdebug("FunctionList -> ");
<       $$ = new t_service(g_program);
<     }
< 
< Function:
<   CaptureDocText Oneway FunctionType tok_identifier '(' FieldList ')' Throws CommaOrSemicolonOptional
<     {
<       $6->set_name(std::string($4) + "_args");
<       $$ = new t_function($3, $4, $6, $8, $2);
<       if ($1 != NULL) {
<         $$->set_doc($1);
<       }
<     }
< 
< Oneway:
<   tok_oneway
<     {
<       $$ = true;
<     }
< |
<     {
<       $$ = false;
<     }
< 
< Throws:
<   tok_throws '(' FieldList ')'
<     {
<       pdebug("Throws -> tok_throws ( FieldList )");
<       $$ = $3;
<       if (g_parse_mode == PROGRAM && !validate_throws($$)) {
<         yyerror("Throws clause may not contain non-exception types");
<         exit(1);
<       }
<     }
< |
<     {
<       $$ = new t_struct(g_program);
<     }
< 
< FieldList:
<   FieldList Field
<     {
<       pdebug("FieldList -> FieldList , Field");
<       $$ = $1;
<       if (!($$->append($2))) {
<         yyerror("Field identifier %d for \"%s\" has already been used", $2->get_key(), $2->get_name().c_str());
<         exit(1);
<       }
<     }
< |
<     {
<       pdebug("FieldList -> ");
<       y_field_val = -1;
<       $$ = new t_struct(g_program);
<     }
< 
< Field:
<   CaptureDocText FieldIdentifier FieldRequiredness FieldType tok_identifier FieldValue XsdOptional XsdNillable XsdAttributes TypeAnnotations CommaOrSemicolonOptional
<     {
<       pdebug("tok_int_constant : Field -> FieldType tok_identifier");
<       if ($2.auto_assigned) {
<         pwarning(1, "No field key specified for %s, resulting protocol may have conflicts or not be backwards compatible!\n", $5);
<         if (g_strict >= 192) {
<           yyerror("Implicit field keys are deprecated and not allowed with -strict");
<           exit(1);
<         }
<       }
<       $$ = new t_field($4, $5, $2.value);
<       $$->set_req($3);
<       if ($6 != NULL) {
<         g_scope->resolve_const_value($6, $4);
<         validate_field_value($$, $6);
<         $$->set_value($6);
<       }
<       $$->set_xsd_optional($7);
<       $$->set_xsd_nillable($8);
<       if ($1 != NULL) {
<         $$->set_doc($1);
<       }
<       if ($9 != NULL) {
<         $$->set_xsd_attrs($9);
<       }
<       if ($10 != NULL) {
<         $$->annotations_ = $10->annotations_;
<         delete $10;
<       }
<     }
< 
< FieldIdentifier:
<   tok_int_constant ':'
<     {
<       if ($1 <= 0) {
<         if (g_allow_neg_field_keys) {
<           /*
<            * g_allow_neg_field_keys exists to allow users to add explicitly
<            * specified key values to old .thrift files without breaking
<            * protocol compatibility.
<            */
<           if ($1 != y_field_val) {
<             /*
<              * warn if the user-specified negative value isn't what
<              * thrift would have auto-assigned.
<              */
<             pwarning(1, "Negative field key (%d) differs from what would be "
<                      "auto-assigned by thrift (%d).\n", $1, y_field_val);
<           }
<           /*
<            * Leave $1 as-is, and update y_field_val to be one less than $1.
<            * The FieldList parsing will catch any duplicate key values.
<            */
<           y_field_val = $1 - 1;
<           $$.value = $1;
<           $$.auto_assigned = false;
<         } else {
<           pwarning(1, "Nonpositive value (%d) not allowed as a field key.\n",
<                    $1);
<           $$.value = y_field_val--;
<           $$.auto_assigned = true;
<         }
<       } else {
<         $$.value = $1;
<         $$.auto_assigned = false;
<       }
<     }
< |
<     {
<       $$.value = y_field_val--;
<       $$.auto_assigned = true;
<     }
< 
< FieldRequiredness:
<   tok_required
<     {
<       $$ = t_field::T_REQUIRED;
<     }
< | tok_optional
<     {
<       if (g_arglist) {
<         if (g_parse_mode == PROGRAM) {
<           pwarning(1, "optional keyword is ignored in argument lists.\n");
<         }
<         $$ = t_field::T_OPT_IN_REQ_OUT;
<       } else {
<         $$ = t_field::T_OPTIONAL;
<       }
<     }
< |
<     {
<       $$ = t_field::T_OPT_IN_REQ_OUT;
<     }
< 
< FieldValue:
<   '=' ConstValue
<     {
<       if (g_parse_mode == PROGRAM) {
<         $$ = $2;
<       } else {
<         $$ = NULL;
<       }
<     }
< |
<     {
<       $$ = NULL;
<     }
< 
< FunctionType:
<   FieldType
<     {
<       pdebug("FunctionType -> FieldType");
<       $$ = $1;
<     }
< | tok_void
<     {
<       pdebug("FunctionType -> tok_void");
<       $$ = g_type_void;
<     }
< 
< FieldType:
<   tok_identifier
<     {
<       pdebug("FieldType -> tok_identifier");
<       if (g_parse_mode == INCLUDES) {
<         // Ignore identifiers in include mode
<         $$ = NULL;
<       } else {
<         // Lookup the identifier in the current scope
<         $$ = g_scope->get_type($1);
<         if ($$ == NULL) {
<           yyerror("Type \"%s\" has not been defined.", $1);
<           exit(1);
<         }
<       }
<     }
< | BaseType
<     {
<       pdebug("FieldType -> BaseType");
<       $$ = $1;
<     }
< | ContainerType
<     {
<       pdebug("FieldType -> ContainerType");
<       $$ = $1;
<     }
< 
< BaseType: SimpleBaseType TypeAnnotations
<     {
<       pdebug("BaseType -> SimpleBaseType TypeAnnotations");
<       if ($2 != NULL) {
<         $$ = new t_base_type(*static_cast<t_base_type*>($1));
<         $$->annotations_ = $2->annotations_;
<         delete $2;
<       } else {
<         $$ = $1;
<       }
<     }
< 
< SimpleBaseType:
<   tok_string
<     {
<       pdebug("BaseType -> tok_string");
<       $$ = g_type_string;
<     }
< | tok_binary
<     {
<       pdebug("BaseType -> tok_binary");
<       $$ = g_type_binary;
<     }
< | tok_slist
<     {
<       pdebug("BaseType -> tok_slist");
<       $$ = g_type_slist;
<     }
< | tok_bool
<     {
<       pdebug("BaseType -> tok_bool");
<       $$ = g_type_bool;
<     }
< | tok_byte
<     {
<       pdebug("BaseType -> tok_byte");
<       $$ = g_type_byte;
<     }
< | tok_i16
<     {
<       pdebug("BaseType -> tok_i16");
<       $$ = g_type_i16;
<     }
< | tok_i32
<     {
<       pdebug("BaseType -> tok_i32");
<       $$ = g_type_i32;
<     }
< | tok_i64
<     {
<       pdebug("BaseType -> tok_i64");
<       $$ = g_type_i64;
<     }
< | tok_double
<     {
<       pdebug("BaseType -> tok_double");
<       $$ = g_type_double;
<     }
< 
< ContainerType: SimpleContainerType TypeAnnotations
<     {
<       pdebug("ContainerType -> SimpleContainerType TypeAnnotations");
<       $$ = $1;
<       if ($2 != NULL) {
<         $$->annotations_ = $2->annotations_;
<         delete $2;
<       }
<     }
< 
< SimpleContainerType:
<   MapType
<     {
<       pdebug("SimpleContainerType -> MapType");
<       $$ = $1;
<     }
< | SetType
<     {
<       pdebug("SimpleContainerType -> SetType");
<       $$ = $1;
<     }
< | ListType
<     {
<       pdebug("SimpleContainerType -> ListType");
<       $$ = $1;
<     }
< 
< MapType:
<   tok_map CppType '<' FieldType ',' FieldType '>'
<     {
<       pdebug("MapType -> tok_map <FieldType, FieldType>");
<       $$ = new t_map($4, $6);
<       if ($2 != NULL) {
<         ((t_container*)$$)->set_cpp_name(std::string($2));
<       }
<     }
< 
< SetType:
<   tok_set CppType '<' FieldType '>'
<     {
<       pdebug("SetType -> tok_set<FieldType>");
<       $$ = new t_set($4);
<       if ($2 != NULL) {
<         ((t_container*)$$)->set_cpp_name(std::string($2));
<       }
<     }
< 
< ListType:
<   tok_list '<' FieldType '>' CppType
<     {
<       pdebug("ListType -> tok_list<FieldType>");
<       $$ = new t_list($3);
<       if ($5 != NULL) {
<         ((t_container*)$$)->set_cpp_name(std::string($5));
<       }
<     }
< 
< CppType:
<   tok_cpp_type tok_literal
<     {
<       $$ = $2;
<     }
< |
<     {
<       $$ = NULL;
<     }
< 
< TypeAnnotations:
<   '(' TypeAnnotationList ')'
<     {
<       pdebug("TypeAnnotations -> ( TypeAnnotationList )");
<       $$ = $2;
<     }
< |
<     {
<       $$ = NULL;
<     }
< 
< TypeAnnotationList:
<   TypeAnnotationList TypeAnnotation
<     {
<       pdebug("TypeAnnotationList -> TypeAnnotationList , TypeAnnotation");
<       $$ = $1;
<       $$->annotations_[$2->key] = $2->val;
<       delete $2;
<     }
< |
<     {
<       /* Just use a dummy structure to hold the annotations. */
<       $$ = new t_struct(g_program);
<     }
< 
< TypeAnnotation:
<   tok_identifier '=' tok_literal CommaOrSemicolonOptional
<     {
<       pdebug("TypeAnnotation -> tok_identifier = tok_literal");
<       $$ = new t_annotation;
<       $$->key = $1;
<       $$->val = $3;
<     }
< 
< %%
---
> %{
> /*
>  * Licensed to the Apache Software Foundation (ASF) under one
>  * or more contributor license agreements. See the NOTICE file
>  * distributed with this work for additional information
>  * regarding copyright ownership. The ASF licenses this file
>  * to you under the Apache License, Version 2.0 (the
>  * "License"); you may not use this file except in compliance
>  * with the License. You may obtain a copy of the License at
>  *
>  *   http://www.apache.org/licenses/LICENSE-2.0
>  *
>  * Unless required by applicable law or agreed to in writing,
>  * software distributed under the License is distributed on an
>  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
>  * KIND, either express or implied. See the License for the
>  * specific language governing permissions and limitations
>  * under the License.
>  */
> 
> /**
>  * Thrift parser.
>  *
>  * This parser is used on a thrift definition file.
>  *
>  */
> 
> #define __STDC_LIMIT_MACROS
> #define __STDC_FORMAT_MACROS
> #include <stdio.h>
> #include <inttypes.h>
> #include <limits.h>
> #include "main.h"
> #include "globals.h"
> #include "parse/t_program.h"
> #include "parse/t_scope.h"
> 
> /**
>  * This global variable is used for automatic numbering of field indices etc.
>  * when parsing the members of a struct. Field values are automatically
>  * assigned starting from -1 and working their way down.
>  */
> int y_field_val = -1;
> int g_arglist = 0;
> const int struct_is_struct = 0;
> const int struct_is_union = 1;
> 
> %}
> 
> /**
>  * This structure is used by the parser to hold the data types associated with
>  * various parse nodes.
>  */
> %union {
>   char*          id;
>   int64_t        iconst;
>   double         dconst;
>   bool           tbool;
>   t_doc*         tdoc;
>   t_type*        ttype;
>   t_base_type*   tbase;
>   t_typedef*     ttypedef;
>   t_enum*        tenum;
>   t_enum_value*  tenumv;
>   t_const*       tconst;
>   t_const_value* tconstv;
>   t_struct*      tstruct;
>   t_service*     tservice;
>   t_function*    tfunction;
>   t_field*       tfield;
>   char*          dtext;
>   t_field::e_req ereq;
>   t_annotation*  tannot;
>   t_field_id     tfieldid;
> }
> 
> /**
>  * Strings identifier
>  */
> %token<id>     tok_identifier
> %token<id>     tok_literal
> %token<dtext>  tok_doctext
> %token<id>     tok_st_identifier
> 
> /**
>  * Constant values
>  */
> %token<iconst> tok_int_constant
> %token<dconst> tok_dub_constant
> 
> /**
>  * Header keywords
>  */
> %token tok_include
> %token tok_namespace
> %token tok_cpp_namespace
> %token tok_cpp_include
> %token tok_cpp_type
> %token tok_php_namespace
> %token tok_py_module
> %token tok_perl_package
> %token tok_java_package
> %token tok_xsd_all
> %token tok_xsd_optional
> %token tok_xsd_nillable
> %token tok_xsd_namespace
> %token tok_xsd_attrs
> %token tok_ruby_namespace
> %token tok_smalltalk_category
> %token tok_smalltalk_prefix
> %token tok_cocoa_prefix
> %token tok_csharp_namespace
> %token tok_delphi_namespace
> 
> /**
>  * Base datatype keywords
>  */
> %token tok_void
> %token tok_bool
> %token tok_byte
> %token tok_string
> %token tok_binary
> %token tok_slist
> %token tok_senum
> %token tok_i16
> %token tok_i32
> %token tok_i64
> %token tok_double
> 
> /**
>  * Complex type keywords
>  */
> %token tok_map
> %token tok_list
> %token tok_set
> 
> /**
>  * Function modifiers
>  */
> %token tok_oneway
> 
> /**
>  * Thrift language keywords
>  */
> %token tok_typedef
> %token tok_struct
> %token tok_xception
> %token tok_throws
> %token tok_extends
> %token tok_service
> %token tok_enum
> %token tok_const
> %token tok_required
> %token tok_optional
> %token tok_union
> 
> /**
>  * Grammar nodes
>  */
> 
> %type<ttype>     BaseType
> %type<ttype>     SimpleBaseType
> %type<ttype>     ContainerType
> %type<ttype>     SimpleContainerType
> %type<ttype>     MapType
> %type<ttype>     SetType
> %type<ttype>     ListType
> 
> %type<tdoc>      Definition
> %type<ttype>     TypeDefinition
> 
> %type<ttypedef>  Typedef
> 
> %type<ttype>     TypeAnnotations
> %type<ttype>     TypeAnnotationList
> %type<tannot>    TypeAnnotation
> 
> %type<tfield>    Field
> %type<tfieldid>  FieldIdentifier
> %type<ereq>      FieldRequiredness
> %type<ttype>     FieldType
> %type<tconstv>   FieldValue
> %type<tstruct>   FieldList
> 
> %type<tenum>     Enum
> %type<tenum>     EnumDefList
> %type<tenumv>    EnumDef
> 
> %type<ttypedef>  Senum
> %type<tbase>     SenumDefList
> %type<id>        SenumDef
> 
> %type<tconst>    Const
> %type<tconstv>   ConstValue
> %type<tconstv>   ConstList
> %type<tconstv>   ConstListContents
> %type<tconstv>   ConstMap
> %type<tconstv>   ConstMapContents
> 
> %type<iconst>    StructHead
> %type<tstruct>   Struct
> %type<tstruct>   Xception
> %type<tservice>  Service
> 
> %type<tfunction> Function
> %type<ttype>     FunctionType
> %type<tservice>  FunctionList
> 
> %type<tstruct>   Throws
> %type<tservice>  Extends
> %type<tbool>     Oneway
> %type<tbool>     XsdAll
> %type<tbool>     XsdOptional
> %type<tbool>     XsdNillable
> %type<tstruct>   XsdAttributes
> %type<id>        CppType
> 
> %type<dtext>     CaptureDocText
> 
> %%
> 
> /**
>  * Thrift Grammar Implementation.
>  *
>  * For the most part this source file works its way top down from what you
>  * might expect to find in a typical .thrift file, i.e. type definitions and
>  * namespaces up top followed by service definitions using those types.
>  */
> 
> Program:
>   HeaderList DefinitionList
>     {
>       pdebug("Program -> Headers DefinitionList");
>       /*
>       TODO(dreiss): Decide whether full-program doctext is worth the trouble.
>       if ($1 != NULL) {
>         g_program->set_doc($1);
>       }
>       */
>       clear_doctext();
>     }
> 
> CaptureDocText:
>     {
>       if (g_parse_mode == PROGRAM) {
>         $$ = g_doctext;
>         g_doctext = NULL;
>       } else {
>         $$ = NULL;
>       }
>     }
> 
> /* TODO(dreiss): Try to DestroyDocText in all sorts or random places. */
> DestroyDocText:
>     {
>       if (g_parse_mode == PROGRAM) {
>         clear_doctext();
>       }
>     }
> 
> /* We have to DestroyDocText here, otherwise it catches the doctext
>    on the first real element. */
> HeaderList:
>   HeaderList DestroyDocText Header
>     {
>       pdebug("HeaderList -> HeaderList Header");
>     }
> |
>     {
>       pdebug("HeaderList -> ");
>     }
> 
> Header:
>   Include
>     {
>       pdebug("Header -> Include");
>     }
> | tok_namespace tok_identifier tok_identifier
>     {
>       pdebug("Header -> tok_namespace tok_identifier tok_identifier");
>       if (g_parse_mode == PROGRAM) {
>         g_program->set_namespace($2, $3);
>       }
>     }
> | tok_namespace '*' tok_identifier
>     {
>       pdebug("Header -> tok_namespace * tok_identifier");
>       if (g_parse_mode == PROGRAM) {
>         g_program->set_namespace("*", $3);
>       }
>     }
> /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
> | tok_cpp_namespace tok_identifier
>     {
>       pwarning(1, "'cpp_namespace' is deprecated. Use 'namespace cpp' instead");
>       pdebug("Header -> tok_cpp_namespace tok_identifier");
>       if (g_parse_mode == PROGRAM) {
>         g_program->set_namespace("cpp", $2);
>       }
>     }
> | tok_cpp_include tok_literal
>     {
>       pdebug("Header -> tok_cpp_include tok_literal");
>       if (g_parse_mode == PROGRAM) {
>         g_program->add_cpp_include($2);
>       }
>     }
> | tok_php_namespace tok_identifier
>     {
>       pwarning(1, "'php_namespace' is deprecated. Use 'namespace php' instead");
>       pdebug("Header -> tok_php_namespace tok_identifier");
>       if (g_parse_mode == PROGRAM) {
>         g_program->set_namespace("php", $2);
>       }
>     }
> /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
> | tok_py_module tok_identifier
>     {
>       pwarning(1, "'py_module' is deprecated. Use 'namespace py' instead");
>       pdebug("Header -> tok_py_module tok_identifier");
>       if (g_parse_mode == PROGRAM) {
>         g_program->set_namespace("py", $2);
>       }
>     }
> /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
> | tok_perl_package tok_identifier
>     {
>       pwarning(1, "'perl_package' is deprecated. Use 'namespace perl' instead");
>       pdebug("Header -> tok_perl_namespace tok_identifier");
>       if (g_parse_mode == PROGRAM) {
>         g_program->set_namespace("perl", $2);
>       }
>     }
> /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
> | tok_ruby_namespace tok_identifier
>     {
>       pwarning(1, "'ruby_namespace' is deprecated. Use 'namespace rb' instead");
>       pdebug("Header -> tok_ruby_namespace tok_identifier");
>       if (g_parse_mode == PROGRAM) {
>         g_program->set_namespace("rb", $2);
>       }
>     }
> /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
> | tok_smalltalk_category tok_st_identifier
>     {
>       pwarning(1, "'smalltalk_category' is deprecated. Use 'namespace smalltalk.category' instead");
>       pdebug("Header -> tok_smalltalk_category tok_st_identifier");
>       if (g_parse_mode == PROGRAM) {
>         g_program->set_namespace("smalltalk.category", $2);
>       }
>     }
> /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
> | tok_smalltalk_prefix tok_identifier
>     {
>       pwarning(1, "'smalltalk_prefix' is deprecated. Use 'namespace smalltalk.prefix' instead");
>       pdebug("Header -> tok_smalltalk_prefix tok_identifier");
>       if (g_parse_mode == PROGRAM) {
>         g_program->set_namespace("smalltalk.prefix", $2);
>       }
>     }
> /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
> | tok_java_package tok_identifier
>     {
>       pwarning(1, "'java_package' is deprecated. Use 'namespace java' instead");
>       pdebug("Header -> tok_java_package tok_identifier");
>       if (g_parse_mode == PROGRAM) {
>         g_program->set_namespace("java", $2);
>       }
>     }
> /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
> | tok_cocoa_prefix tok_identifier
>     {
>       pwarning(1, "'cocoa_prefix' is deprecated. Use 'namespace cocoa' instead");
>       pdebug("Header -> tok_cocoa_prefix tok_identifier");
>       if (g_parse_mode == PROGRAM) {
>         g_program->set_namespace("cocoa", $2);
>       }
>     }
> /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
> | tok_xsd_namespace tok_literal
>     {
>       pwarning(1, "'xsd_namespace' is deprecated. Use 'namespace xsd' instead");
>       pdebug("Header -> tok_xsd_namespace tok_literal");
>       if (g_parse_mode == PROGRAM) {
>         g_program->set_namespace("cocoa", $2);
>       }
>     }
> /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
> | tok_csharp_namespace tok_identifier
>    {
>      pwarning(1, "'csharp_namespace' is deprecated. Use 'namespace csharp' instead");
>      pdebug("Header -> tok_csharp_namespace tok_identifier");
>      if (g_parse_mode == PROGRAM) {
>        g_program->set_namespace("csharp", $2);
>      }
>    }
> /* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
> | tok_delphi_namespace tok_identifier
>    {
>      pwarning(1, "'delphi_namespace' is deprecated. Use 'namespace delphi' instead");
>      pdebug("Header -> tok_delphi_namespace tok_identifier");
>      if (g_parse_mode == PROGRAM) {
>        g_program->set_namespace("delphi", $2);
>      }
>    }
> 
> Include:
>   tok_include tok_literal
>     {
>       pdebug("Include -> tok_include tok_literal");
>       if (g_parse_mode == INCLUDES) {
>         std::string path = include_file(std::string($2));
>         if (!path.empty()) {
>           g_program->add_include(path, std::string($2));
>         }
>       }
>     }
> 
> DefinitionList:
>   DefinitionList CaptureDocText Definition
>     {
>       pdebug("DefinitionList -> DefinitionList Definition");
>       if ($2 != NULL && $3 != NULL) {
>         $3->set_doc($2);
>       }
>     }
> |
>     {
>       pdebug("DefinitionList -> ");
>     }
> 
> Definition:
>   Const
>     {
>       pdebug("Definition -> Const");
>       if (g_parse_mode == PROGRAM) {
>         g_program->add_const($1);
>       }
>       $$ = $1;
>     }
> | TypeDefinition
>     {
>       pdebug("Definition -> TypeDefinition");
>       if (g_parse_mode == PROGRAM) {
>         g_scope->add_type($1->get_name(), $1);
>         if (g_parent_scope != NULL) {
>           g_parent_scope->add_type(g_parent_prefix + $1->get_name(), $1);
>         }
>       }
>       $$ = $1;
>     }
> | Service
>     {
>       pdebug("Definition -> Service");
>       if (g_parse_mode == PROGRAM) {
>         g_scope->add_service($1->get_name(), $1);
>         if (g_parent_scope != NULL) {
>           g_parent_scope->add_service(g_parent_prefix + $1->get_name(), $1);
>         }
>         g_program->add_service($1);
>       }
>       $$ = $1;
>     }
> 
> TypeDefinition:
>   Typedef
>     {
>       pdebug("TypeDefinition -> Typedef");
>       if (g_parse_mode == PROGRAM) {
>         g_program->add_typedef($1);
>       }
>     }
> | Enum
>     {
>       pdebug("TypeDefinition -> Enum");
>       if (g_parse_mode == PROGRAM) {
>         g_program->add_enum($1);
>       }
>     }
> | Senum
>     {
>       pdebug("TypeDefinition -> Senum");
>       if (g_parse_mode == PROGRAM) {
>         g_program->add_typedef($1);
>       }
>     }
> | Struct
>     {
>       pdebug("TypeDefinition -> Struct");
>       if (g_parse_mode == PROGRAM) {
>         g_program->add_struct($1);
>       }
>     }
> | Xception
>     {
>       pdebug("TypeDefinition -> Xception");
>       if (g_parse_mode == PROGRAM) {
>         g_program->add_xception($1);
>       }
>     }
> 
> Typedef:
>   tok_typedef FieldType tok_identifier
>     {
>       pdebug("TypeDef -> tok_typedef FieldType tok_identifier");
>       t_typedef *td = new t_typedef(g_program, $2, $3);
>       $$ = td;
>     }
> 
> CommaOrSemicolonOptional:
>   ','
>     {}
> | ';'
>     {}
> |
>     {}
> 
> Enum:
>   tok_enum tok_identifier '{' EnumDefList '}'
>     {
>       pdebug("Enum -> tok_enum tok_identifier { EnumDefList }");
>       $$ = $4;
>       $$->set_name($2);
>       $$->resolve_values();
>       // make constants for all the enum values
>       if (g_parse_mode == PROGRAM) {
>         const std::vector<t_enum_value*>& enum_values = $$->get_constants();
>         std::vector<t_enum_value*>::const_iterator c_iter;
>         for (c_iter = enum_values.begin(); c_iter != enum_values.end(); ++c_iter) {
>           std::string const_name = $$->get_name() + "." + (*c_iter)->get_name();
>           t_const_value* const_val = new t_const_value((*c_iter)->get_value());
>           const_val->set_enum($$);
>           g_scope->add_constant(const_name, new t_const(g_type_i32, (*c_iter)->get_name(), const_val));
>           if (g_parent_scope != NULL) {
>             g_parent_scope->add_constant(g_parent_prefix + const_name, new t_const(g_type_i32, (*c_iter)->get_name(), const_val));
>           }
>         }
>       }
>     }
> 
> EnumDefList:
>   EnumDefList EnumDef
>     {
>       pdebug("EnumDefList -> EnumDefList EnumDef");
>       $$ = $1;
>       $$->append($2);
>     }
> |
>     {
>       pdebug("EnumDefList -> ");
>       $$ = new t_enum(g_program);
>     }
> 
> EnumDef:
>   CaptureDocText tok_identifier '=' tok_int_constant CommaOrSemicolonOptional
>     {
>       pdebug("EnumDef -> tok_identifier = tok_int_constant");
>       if ($4 < 0) {
>         pwarning(1, "Negative value supplied for enum %s.\n", $2);
>       }
>       if ($4 > INT_MAX) {
>         pwarning(1, "64-bit value supplied for enum %s.\n", $2);
>       }
>       $$ = new t_enum_value($2, $4);
>       if ($1 != NULL) {
>         $$->set_doc($1);
>       }
>     }
> |
>   CaptureDocText tok_identifier CommaOrSemicolonOptional
>     {
>       pdebug("EnumDef -> tok_identifier");
>       $$ = new t_enum_value($2);
>       if ($1 != NULL) {
>         $$->set_doc($1);
>       }
>     }
> 
> Senum:
>   tok_senum tok_identifier '{' SenumDefList '}'
>     {
>       pdebug("Senum -> tok_senum tok_identifier { SenumDefList }");
>       $$ = new t_typedef(g_program, $4, $2);
>     }
> 
> SenumDefList:
>   SenumDefList SenumDef
>     {
>       pdebug("SenumDefList -> SenumDefList SenumDef");
>       $$ = $1;
>       $$->add_string_enum_val($2);
>     }
> |
>     {
>       pdebug("SenumDefList -> ");
>       $$ = new t_base_type("string", t_base_type::TYPE_STRING);
>       $$->set_string_enum(true);
>     }
> 
> SenumDef:
>   tok_literal CommaOrSemicolonOptional
>     {
>       pdebug("SenumDef -> tok_literal");
>       $$ = $1;
>     }
> 
> Const:
>   tok_const FieldType tok_identifier '=' ConstValue CommaOrSemicolonOptional
>     {
>       pdebug("Const -> tok_const FieldType tok_identifier = ConstValue");
>       if (g_parse_mode == PROGRAM) {
>         g_scope->resolve_const_value($5, $2);
>         $$ = new t_const($2, $3, $5);
>         validate_const_type($$);
> 
>         g_scope->add_constant($3, $$);
>         if (g_parent_scope != NULL) {
>           g_parent_scope->add_constant(g_parent_prefix + $3, $$);
>         }
>       } else {
>         $$ = NULL;
>       }
>     }
> 
> ConstValue:
>   tok_int_constant
>     {
>       pdebug("ConstValue => tok_int_constant");
>       $$ = new t_const_value();
>       $$->set_integer($1);
>       if (!g_allow_64bit_consts && ($1 < INT32_MIN || $1 > INT32_MAX)) {
>         pwarning(1, "64-bit constant \"%" PRIi64 "\" may not work in all languages.\n", $1);
>       }
>     }
> | tok_dub_constant
>     {
>       pdebug("ConstValue => tok_dub_constant");
>       $$ = new t_const_value();
>       $$->set_double($1);
>     }
> | tok_literal
>     {
>       pdebug("ConstValue => tok_literal");
>       $$ = new t_const_value($1);
>     }
> | tok_identifier
>     {
>       pdebug("ConstValue => tok_identifier");
>       $$ = new t_const_value();
>       $$->set_identifier($1);
>     }
> | ConstList
>     {
>       pdebug("ConstValue => ConstList");
>       $$ = $1;
>     }
> | ConstMap
>     {
>       pdebug("ConstValue => ConstMap");
>       $$ = $1;
>     }
> 
> ConstList:
>   '[' ConstListContents ']'
>     {
>       pdebug("ConstList => [ ConstListContents ]");
>       $$ = $2;
>     }
> 
> ConstListContents:
>   ConstListContents ConstValue CommaOrSemicolonOptional
>     {
>       pdebug("ConstListContents => ConstListContents ConstValue CommaOrSemicolonOptional");
>       $$ = $1;
>       $$->add_list($2);
>     }
> |
>     {
>       pdebug("ConstListContents =>");
>       $$ = new t_const_value();
>       $$->set_list();
>     }
> 
> ConstMap:
>   '{' ConstMapContents '}'
>     {
>       pdebug("ConstMap => { ConstMapContents }");
>       $$ = $2;
>     }
> 
> ConstMapContents:
>   ConstMapContents ConstValue ':' ConstValue CommaOrSemicolonOptional
>     {
>       pdebug("ConstMapContents => ConstMapContents ConstValue CommaOrSemicolonOptional");
>       $$ = $1;
>       $$->add_map($2, $4);
>     }
> |
>     {
>       pdebug("ConstMapContents =>");
>       $$ = new t_const_value();
>       $$->set_map();
>     }
> 
> StructHead:
>   tok_struct
>     {
>       $$ = struct_is_struct;
>     }
> | tok_union
>     {
>       $$ = struct_is_union;
>     }
> 
> Struct:
>   StructHead tok_identifier XsdAll '{' FieldList '}' TypeAnnotations
>     {
>       pdebug("Struct -> tok_struct tok_identifier { FieldList }");
>       $5->set_xsd_all($3);
>       $5->set_union($1 == struct_is_union);
>       $$ = $5;
>       $$->set_name($2);
>       if ($7 != NULL) {
>         $$->annotations_ = $7->annotations_;
>         delete $7;
>       }
>     }
>     
> XsdAll:
>   tok_xsd_all
>     {
>       $$ = true;
>     }
> |
>     {
>       $$ = false;
>     }
> 
> XsdOptional:
>   tok_xsd_optional
>     {
>       $$ = true;
>     }
> |
>     {
>       $$ = false;
>     }
> 
> XsdNillable:
>   tok_xsd_nillable
>     {
>       $$ = true;
>     }
> |
>     {
>       $$ = false;
>     }
> 
> XsdAttributes:
>   tok_xsd_attrs '{' FieldList '}'
>     {
>       $$ = $3;
>     }
> |
>     {
>       $$ = NULL;
>     }
> 
> Xception:
>   tok_xception tok_identifier '{' FieldList '}'
>     {
>       pdebug("Xception -> tok_xception tok_identifier { FieldList }");
>       $4->set_name($2);
>       $4->set_xception(true);
>       $$ = $4;
>     }
> 
> Service:
>   tok_service tok_identifier Extends '{' FlagArgs FunctionList UnflagArgs '}'
>     {
>       pdebug("Service -> tok_service tok_identifier { FunctionList }");
>       $$ = $6;
>       $$->set_name($2);
>       $$->set_extends($3);
>     }
> 
> FlagArgs:
>     {
>        g_arglist = 1;
>     }
> 
> UnflagArgs:
>     {
>        g_arglist = 0;
>     }
> 
> Extends:
>   tok_extends tok_identifier
>     {
>       pdebug("Extends -> tok_extends tok_identifier");
>       $$ = NULL;
>       if (g_parse_mode == PROGRAM) {
>         $$ = g_scope->get_service($2);
>         if ($$ == NULL) {
>           yyerror("Service \"%s\" has not been defined.", $2);
>           exit(1);
>         }
>       }
>     }
> |
>     {
>       $$ = NULL;
>     }
> 
> FunctionList:
>   FunctionList Function
>     {
>       pdebug("FunctionList -> FunctionList Function");
>       $$ = $1;
>       $1->add_function($2);
>     }
> |
>     {
>       pdebug("FunctionList -> ");
>       $$ = new t_service(g_program);
>     }
> 
> Function:
>   CaptureDocText Oneway FunctionType tok_identifier '(' FieldList ')' Throws CommaOrSemicolonOptional
>     {
>       $6->set_name(std::string($4) + "_args");
>       $$ = new t_function($3, $4, $6, $8, $2);
>       if ($1 != NULL) {
>         $$->set_doc($1);
>       }
>     }
> 
> Oneway:
>   tok_oneway
>     {
>       $$ = true;
>     }
> |
>     {
>       $$ = false;
>     }
> 
> Throws:
>   tok_throws '(' FieldList ')'
>     {
>       pdebug("Throws -> tok_throws ( FieldList )");
>       $$ = $3;
>       if (g_parse_mode == PROGRAM && !validate_throws($$)) {
>         yyerror("Throws clause may not contain non-exception types");
>         exit(1);
>       }
>     }
> |
>     {
>       $$ = new t_struct(g_program);
>     }
> 
> FieldList:
>   FieldList Field
>     {
>       pdebug("FieldList -> FieldList , Field");
>       $$ = $1;
>       if (!($$->append($2))) {
>         yyerror("Field identifier %d for \"%s\" has already been used", $2->get_key(), $2->get_name().c_str());
>         exit(1);
>       }
>     }
> |
>     {
>       pdebug("FieldList -> ");
>       y_field_val = -1;
>       $$ = new t_struct(g_program);
>     }
> 
> Field:
>   CaptureDocText FieldIdentifier FieldRequiredness FieldType tok_identifier FieldValue XsdOptional XsdNillable XsdAttributes TypeAnnotations CommaOrSemicolonOptional
>     {
>       pdebug("tok_int_constant : Field -> FieldType tok_identifier");
>       if ($2.auto_assigned) {
>         pwarning(1, "No field key specified for %s, resulting protocol may have conflicts or not be backwards compatible!\n", $5);
>         if (g_strict >= 192) {
>           yyerror("Implicit field keys are deprecated and not allowed with -strict");
>           exit(1);
>         }
>       }
>       $$ = new t_field($4, $5, $2.value);
>       $$->set_req($3);
>       if ($6 != NULL) {
>         g_scope->resolve_const_value($6, $4);
>         validate_field_value($$, $6);
>         $$->set_value($6);
>       }
>       $$->set_xsd_optional($7);
>       $$->set_xsd_nillable($8);
>       if ($1 != NULL) {
>         $$->set_doc($1);
>       }
>       if ($9 != NULL) {
>         $$->set_xsd_attrs($9);
>       }
>       if ($10 != NULL) {
>         $$->annotations_ = $10->annotations_;
>         delete $10;
>       }
>     }
> 
> FieldIdentifier:
>   tok_int_constant ':'
>     {
>       if ($1 <= 0) {
>         if (g_allow_neg_field_keys) {
>           /*
>            * g_allow_neg_field_keys exists to allow users to add explicitly
>            * specified key values to old .thrift files without breaking
>            * protocol compatibility.
>            */
>           if ($1 != y_field_val) {
>             /*
>              * warn if the user-specified negative value isn't what
>              * thrift would have auto-assigned.
>              */
>             pwarning(1, "Negative field key (%d) differs from what would be "
>                      "auto-assigned by thrift (%d).\n", $1, y_field_val);
>           }
>           /*
>            * Leave $1 as-is, and update y_field_val to be one less than $1.
>            * The FieldList parsing will catch any duplicate key values.
>            */
>           y_field_val = $1 - 1;
>           $$.value = $1;
>           $$.auto_assigned = false;
>         } else {
>           pwarning(1, "Nonpositive value (%d) not allowed as a field key.\n",
>                    $1);
>           $$.value = y_field_val--;
>           $$.auto_assigned = true;
>         }
>       } else {
>         $$.value = $1;
>         $$.auto_assigned = false;
>       }
>     }
> |
>     {
>       $$.value = y_field_val--;
>       $$.auto_assigned = true;
>     }
> 
> FieldRequiredness:
>   tok_required
>     {
>       $$ = t_field::T_REQUIRED;
>     }
> | tok_optional
>     {
>       if (g_arglist) {
>         if (g_parse_mode == PROGRAM) {
>           pwarning(1, "optional keyword is ignored in argument lists.\n");
>         }
>         $$ = t_field::T_OPT_IN_REQ_OUT;
>       } else {
>         $$ = t_field::T_OPTIONAL;
>       }
>     }
> |
>     {
>       $$ = t_field::T_OPT_IN_REQ_OUT;
>     }
> 
> FieldValue:
>   '=' ConstValue
>     {
>       if (g_parse_mode == PROGRAM) {
>         $$ = $2;
>       } else {
>         $$ = NULL;
>       }
>     }
> |
>     {
>       $$ = NULL;
>     }
> 
> FunctionType:
>   FieldType
>     {
>       pdebug("FunctionType -> FieldType");
>       $$ = $1;
>     }
> | tok_void
>     {
>       pdebug("FunctionType -> tok_void");
>       $$ = g_type_void;
>     }
> 
> FieldType:
>   tok_identifier
>     {
>       pdebug("FieldType -> tok_identifier");
>       if (g_parse_mode == INCLUDES) {
>         // Ignore identifiers in include mode
>         $$ = NULL;
>       } else {
>         // Lookup the identifier in the current scope
>         $$ = g_scope->get_type($1);
>         if ($$ == NULL) {
>           yyerror("Type \"%s\" has not been defined.", $1);
>           exit(1);
>         }
>       }
>     }
> | BaseType
>     {
>       pdebug("FieldType -> BaseType");
>       $$ = $1;
>     }
> | ContainerType
>     {
>       pdebug("FieldType -> ContainerType");
>       $$ = $1;
>     }
> 
> BaseType: SimpleBaseType TypeAnnotations
>     {
>       pdebug("BaseType -> SimpleBaseType TypeAnnotations");
>       if ($2 != NULL) {
>         $$ = new t_base_type(*static_cast<t_base_type*>($1));
>         $$->annotations_ = $2->annotations_;
>         delete $2;
>       } else {
>         $$ = $1;
>       }
>     }
> 
> SimpleBaseType:
>   tok_string
>     {
>       pdebug("BaseType -> tok_string");
>       $$ = g_type_string;
>     }
> | tok_binary
>     {
>       pdebug("BaseType -> tok_binary");
>       $$ = g_type_binary;
>     }
> | tok_slist
>     {
>       pdebug("BaseType -> tok_slist");
>       $$ = g_type_slist;
>     }
> | tok_bool
>     {
>       pdebug("BaseType -> tok_bool");
>       $$ = g_type_bool;
>     }
> | tok_byte
>     {
>       pdebug("BaseType -> tok_byte");
>       $$ = g_type_byte;
>     }
> | tok_i16
>     {
>       pdebug("BaseType -> tok_i16");
>       $$ = g_type_i16;
>     }
> | tok_i32
>     {
>       pdebug("BaseType -> tok_i32");
>       $$ = g_type_i32;
>     }
> | tok_i64
>     {
>       pdebug("BaseType -> tok_i64");
>       $$ = g_type_i64;
>     }
> | tok_double
>     {
>       pdebug("BaseType -> tok_double");
>       $$ = g_type_double;
>     }
> 
> ContainerType: SimpleContainerType TypeAnnotations
>     {
>       pdebug("ContainerType -> SimpleContainerType TypeAnnotations");
>       $$ = $1;
>       if ($2 != NULL) {
>         $$->annotations_ = $2->annotations_;
>         delete $2;
>       }
>     }
> 
> SimpleContainerType:
>   MapType
>     {
>       pdebug("SimpleContainerType -> MapType");
>       $$ = $1;
>     }
> | SetType
>     {
>       pdebug("SimpleContainerType -> SetType");
>       $$ = $1;
>     }
> | ListType
>     {
>       pdebug("SimpleContainerType -> ListType");
>       $$ = $1;
>     }
> 
> MapType:
>   tok_map CppType '<' FieldType ',' FieldType '>'
>     {
>       pdebug("MapType -> tok_map <FieldType, FieldType>");
>       $$ = new t_map($4, $6);
>       if ($2 != NULL) {
>         ((t_container*)$$)->set_cpp_name(std::string($2));
>       }
>     }
> 
> SetType:
>   tok_set CppType '<' FieldType '>'
>     {
>       pdebug("SetType -> tok_set<FieldType>");
>       $$ = new t_set($4);
>       if ($2 != NULL) {
>         ((t_container*)$$)->set_cpp_name(std::string($2));
>       }
>     }
> 
> ListType:
>   tok_list '<' FieldType '>' CppType
>     {
>       pdebug("ListType -> tok_list<FieldType>");
>       $$ = new t_list($3);
>       if ($5 != NULL) {
>         ((t_container*)$$)->set_cpp_name(std::string($5));
>       }
>     }
> 
> CppType:
>   tok_cpp_type tok_literal
>     {
>       $$ = $2;
>     }
> |
>     {
>       $$ = NULL;
>     }
> 
> TypeAnnotations:
>   '(' TypeAnnotationList ')'
>     {
>       pdebug("TypeAnnotations -> ( TypeAnnotationList )");
>       $$ = $2;
>     }
> |
>     {
>       $$ = NULL;
>     }
> 
> TypeAnnotationList:
>   TypeAnnotationList TypeAnnotation
>     {
>       pdebug("TypeAnnotationList -> TypeAnnotationList , TypeAnnotation");
>       $$ = $1;
>       $$->annotations_[$2->key] = $2->val;
>       delete $2;
>     }
> |
>     {
>       /* Just use a dummy structure to hold the annotations. */
>       $$ = new t_struct(g_program);
>     }
> 
> TypeAnnotation:
>   tok_identifier '=' tok_literal CommaOrSemicolonOptional
>     {
>       pdebug("TypeAnnotation -> tok_identifier = tok_literal");
>       $$ = new t_annotation;
>       $$->key = $1;
>       $$->val = $3;
>     }
> 
> %%
1,1195c1,1195
< /*
<  * Licensed to the Apache Software Foundation (ASF) under one
<  * or more contributor license agreements. See the NOTICE file
<  * distributed with this work for additional information
<  * regarding copyright ownership. The ASF licenses this file
<  * to you under the Apache License, Version 2.0 (the
<  * "License"); you may not use this file except in compliance
<  * with the License. You may obtain a copy of the License at
<  *
<  *   http://www.apache.org/licenses/LICENSE-2.0
<  *
<  * Unless required by applicable law or agreed to in writing,
<  * software distributed under the License is distributed on an
<  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
<  * KIND, either express or implied. See the License for the
<  * specific language governing permissions and limitations
<  * under the License.
<  *
<  * Contains some contributions under the Thrift Software License.
<  * Please see doc/old-thrift-license.txt in the Thrift distribution for
<  * details.
<  */
< 
< #include <string>
< #include <fstream>
< #include <iostream>
< #include <vector>
< #include <algorithm>
< 
< #include <stdlib.h>
< #include <sys/stat.h>
< #include <sys/types.h>
< #include <sstream>
< 
< #include "t_oop_generator.h"
< #include "platform.h"
< #include "version.h"
< 
< using namespace std;
< 
< 
< /**
<  * Ruby code generator.
<  *
<  */
< class t_rb_generator : public t_oop_generator {
<  public:
<   t_rb_generator(
<       t_program* program,
<       const std::map<std::string, std::string>& parsed_options,
<       const std::string& option_string)
<     : t_oop_generator(program)
<   {
<     (void) parsed_options;
<     (void) option_string;
<     out_dir_base_ = "gen-rb";
<   }
< 
<   /**
<    * Init and close methods
<    */
< 
<   void init_generator();
<   void close_generator();
< 
<   /**
<    * Program-level generation functions
<    */
< 
<   void generate_typedef     (t_typedef*  ttypedef);
<   void generate_enum        (t_enum*     tenum);
<   void generate_const       (t_const*    tconst);
<   void generate_struct      (t_struct*   tstruct);
<   void generate_union        (t_struct*   tunion);
<   void generate_xception    (t_struct*   txception);
<   void generate_service     (t_service*  tservice);
< 
<   std::string render_const_value(t_type* type, t_const_value* value);
< 
<   /**
<    * Struct generation code
<    */
< 
<   void generate_rb_struct(std::ofstream& out, t_struct* tstruct, bool is_exception);
<   void generate_rb_struct_required_validator(std::ofstream& out, t_struct* tstruct);
<   void generate_rb_union(std::ofstream& out, t_struct* tstruct, bool is_exception);
<   void generate_rb_union_validator(std::ofstream& out, t_struct* tstruct);
<   void generate_rb_function_helpers(t_function* tfunction);
<   void generate_rb_simple_constructor(std::ofstream& out, t_struct* tstruct);
<   void generate_rb_simple_exception_constructor(std::ofstream& out, t_struct* tstruct);
<   void generate_field_constants (std::ofstream& out, t_struct* tstruct);
<   void generate_field_constructors (std::ofstream& out, t_struct* tstruct);
<   void generate_field_defns (std::ofstream& out, t_struct* tstruct);
<   void generate_field_data  (std::ofstream& out, t_type* field_type, const std::string& field_name, t_const_value* field_value, bool optional);
< 
<   /**
<    * Service-level generation functions
<    */
< 
<   void generate_service_helpers   (t_service*  tservice);
<   void generate_service_interface (t_service* tservice);
<   void generate_service_client    (t_service* tservice);
<   void generate_service_server    (t_service* tservice);
<   void generate_process_function  (t_service* tservice, t_function* tfunction);
< 
<   /**
<    * Serialization constructs
<    */
< 
<   void generate_deserialize_field        (std::ofstream &out,
<                                           t_field*    tfield,
<                                           std::string prefix="",
<                                           bool inclass=false);
< 
<   void generate_deserialize_struct       (std::ofstream &out,
<                                           t_struct*   tstruct,
<                                           std::string prefix="");
< 
<   void generate_deserialize_container    (std::ofstream &out,
<                                           t_type*     ttype,
<                                           std::string prefix="");
< 
<   void generate_deserialize_set_element  (std::ofstream &out,
<                                           t_set*      tset,
<                                           std::string prefix="");
< 
<   void generate_deserialize_map_element  (std::ofstream &out,
<                                           t_map*      tmap,
<                                           std::string prefix="");
< 
<   void generate_deserialize_list_element (std::ofstream &out,
<                                           t_list*     tlist,
<                                           std::string prefix="");
< 
<   void generate_serialize_field          (std::ofstream &out,
<                                           t_field*    tfield,
<                                           std::string prefix="");
< 
<   void generate_serialize_struct         (std::ofstream &out,
<                                           t_struct*   tstruct,
<                                           std::string prefix="");
< 
<   void generate_serialize_container      (std::ofstream &out,
<                                           t_type*     ttype,
<                                           std::string prefix="");
< 
<   void generate_serialize_map_element    (std::ofstream &out,
<                                           t_map*      tmap,
<                                           std::string kiter,
<                                           std::string viter);
< 
<   void generate_serialize_set_element    (std::ofstream &out,
<                                           t_set*      tmap,
<                                           std::string iter);
< 
<   void generate_serialize_list_element   (std::ofstream &out,
<                                           t_list*     tlist,
<                                           std::string iter);
< 
<   void generate_rdoc                     (std::ofstream& out, 
<                                           t_doc* tdoc);
< 
<   /**
<    * Helper rendering functions
<    */
< 
<   std::string rb_autogen_comment();
<   std::string render_includes();
<   std::string declare_field(t_field* tfield);
<   std::string type_name(t_type* ttype);
<   std::string full_type_name(t_type* ttype);
<   std::string function_signature(t_function* tfunction, std::string prefix="");
<   std::string argument_list(t_struct* tstruct);
<   std::string type_to_enum(t_type* ttype);
< 
< 
< 
<   std::vector<std::string> ruby_modules(t_program* p) {
<     std::string ns = p->get_namespace("rb");
<     std::vector<std::string> modules;
<     if (ns.empty()) {
<       return modules;
<     }
< 
<     std::string::iterator pos = ns.begin();
<     while (true) {
<       std::string::iterator delim = std::find(pos, ns.end(), '.');
<       modules.push_back(capitalize(std::string(pos, delim)));
<       pos = delim;
<       if (pos == ns.end()) {
<         break;
<       }
<       ++pos;
<     }
< 
<     return modules;
<   }
< 
<   void begin_namespace(std::ofstream&, std::vector<std::string>);
<   void end_namespace(std::ofstream&, std::vector<std::string>);
< 
<  private:
< 
<   /**
<    * File streams
<    */
< 
<   std::ofstream f_types_;
<   std::ofstream f_consts_;
<   std::ofstream f_service_;
< 
< };
< 
< 
< /**
<  * Prepares for file generation by opening up the necessary file output
<  * streams.
<  *
<  * @param tprogram The program to generate
<  */
< void t_rb_generator::init_generator() {
<   // Make output directory
<   MKDIR(get_out_dir().c_str());
< 
<   // Make output file
<   string f_types_name = get_out_dir()+underscore(program_name_)+"_types.rb";
<   f_types_.open(f_types_name.c_str());
< 
<   string f_consts_name = get_out_dir()+underscore(program_name_)+"_constants.rb";
<   f_consts_.open(f_consts_name.c_str());
< 
<   // Print header
<   f_types_ <<
<     rb_autogen_comment() << endl <<
<     render_includes() << endl;
<     begin_namespace(f_types_, ruby_modules(program_));
< 
<   f_consts_ <<
<     rb_autogen_comment() << endl <<
<     "require '" << underscore(program_name_) << "_types'" << endl <<
<     endl;
<     begin_namespace(f_consts_, ruby_modules(program_));
< 
< }
< 
< /**
<  * Renders all the imports necessary for including another Thrift program
<  */
< string t_rb_generator::render_includes() {
<   const vector<t_program*>& includes = program_->get_includes();
<   string result = "";
<   for (size_t i = 0; i < includes.size(); ++i) {
<     result += "require '" + underscore(includes[i]->get_name()) + "_types'\n";
<   }
<   if (includes.size() > 0) {
<     result += "\n";
<   }
<   return result;
< }
< 
< /**
<  * Autogen'd comment
<  */
< string t_rb_generator::rb_autogen_comment() {
<   return
<     std::string("#\n") +
<     "# Autogenerated by Thrift Compiler (" + THRIFT_VERSION + ")\n" +
<     "#\n" +
<     "# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n" +
<     "#\n";
< }
< 
< /**
<  * Closes the type files
<  */
< void t_rb_generator::close_generator() {
<   // Close types file
<   end_namespace(f_types_, ruby_modules(program_));
<   end_namespace(f_consts_, ruby_modules(program_));
<   f_types_.close();
<   f_consts_.close();
< }
< 
< /**
<  * Generates a typedef. This is not done in Ruby, types are all implicit.
<  *
<  * @param ttypedef The type definition
<  */
< void t_rb_generator::generate_typedef(t_typedef* ttypedef) {
<   (void) ttypedef;
< }
< 
< /**
<  * Generates code for an enumerated type. Done using a class to scope
<  * the values.
<  *
<  * @param tenum The enumeration
<  */
< void t_rb_generator::generate_enum(t_enum* tenum) {
<   indent(f_types_) <<
<     "module " << capitalize(tenum->get_name()) << endl;
<   indent_up();
< 
<   vector<t_enum_value*> constants = tenum->get_constants();
<   vector<t_enum_value*>::iterator c_iter;
<   for (c_iter = constants.begin(); c_iter != constants.end(); ++c_iter) {
<     int value = (*c_iter)->get_value();
< 
<     // Ruby class constants have to be capitalized... omg i am so on the fence
<     // about languages strictly enforcing capitalization why can't we just all
<     // agree and play nice.
<     string name = capitalize((*c_iter)->get_name());
< 
<     generate_rdoc(f_types_, *c_iter);
<     indent(f_types_) << name << " = " << value << endl;
<   }
<   
<   // Create a hash mapping values back to their names (as strings) since ruby has no native enum type
<   indent(f_types_) << "VALUE_MAP = {";
<   bool first = true;
<   for(c_iter = constants.begin(); c_iter != constants.end(); ++c_iter) {
<     // Populate the hash
<     int value = (*c_iter)->get_value();
<     first ? first = false : f_types_ << ", ";
<     f_types_ << value << " => \"" << capitalize((*c_iter)->get_name()) << "\"";
<   }
<   f_types_ << "}" << endl;
<   
<   // Create a set with valid values for this enum
<   indent(f_types_) << "VALID_VALUES = Set.new([";
<   first = true;
<   for (c_iter = constants.begin(); c_iter != constants.end(); ++c_iter) {
<     // Populate the set
<     first ? first = false : f_types_ << ", ";
<     f_types_ << capitalize((*c_iter)->get_name());
<   }
<   f_types_ << "]).freeze" << endl;
< 
<   indent_down();
<   indent(f_types_) <<
<     "end" << endl << endl;
< }
< 
< /**
<  * Generate a constant value
<  */
< void t_rb_generator::generate_const(t_const* tconst) {
<   t_type* type = tconst->get_type();
<   string name = tconst->get_name();
<   t_const_value* value = tconst->get_value();
< 
<   name[0] = toupper(name[0]);
< 
<   indent(f_consts_) << name << " = " << render_const_value(type, value);
<   f_consts_ << endl << endl;
< }
< 
< /**
<  * Prints the value of a constant with the given type. Note that type checking
<  * is NOT performed in this function as it is always run beforehand using the
<  * validate_types method in main.cc
<  */
< string t_rb_generator::render_const_value(t_type* type, t_const_value* value) {
<   type = get_true_type(type);
<   std::ostringstream out;
<   if (type->is_base_type()) {
<     t_base_type::t_base tbase = ((t_base_type*)type)->get_base();
<     switch (tbase) {
<     case t_base_type::TYPE_STRING:
<       out << "%q\"" << get_escaped_string(value) << '"';
<       break;
<     case t_base_type::TYPE_BOOL:
<       out << (value->get_integer() > 0 ? "true" : "false");
<       break;
<     case t_base_type::TYPE_BYTE:
<     case t_base_type::TYPE_I16:
<     case t_base_type::TYPE_I32:
<     case t_base_type::TYPE_I64:
<       out << value->get_integer();
<       break;
<     case t_base_type::TYPE_DOUBLE:
<       if (value->get_type() == t_const_value::CV_INTEGER) {
<         out << value->get_integer();
<       } else {
<         out << value->get_double();
<       }
<       break;
<     default:
<       throw "compiler error: no const of base type " + t_base_type::t_base_name(tbase);
<     }
<   } else if (type->is_enum()) {
<     indent(out) << value->get_integer();
<   } else if (type->is_struct() || type->is_xception()) {
<     out << full_type_name(type) << ".new({" << endl;
<     indent_up();
<     const vector<t_field*>& fields = ((t_struct*)type)->get_members();
<     vector<t_field*>::const_iterator f_iter;
<     const map<t_const_value*, t_const_value*>& val = value->get_map();
<     map<t_const_value*, t_const_value*>::const_iterator v_iter;
<     for (v_iter = val.begin(); v_iter != val.end(); ++v_iter) {
<       t_type* field_type = NULL;
<       for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
<         if ((*f_iter)->get_name() == v_iter->first->get_string()) {
<           field_type = (*f_iter)->get_type();
<         }
<       }
<       if (field_type == NULL) {
<         throw "type error: " + type->get_name() + " has no field " + v_iter->first->get_string();
<       }
<       out << indent();
<       out << render_const_value(g_type_string, v_iter->first);
<       out << " => ";
<       out << render_const_value(field_type, v_iter->second);
<       out << "," << endl;
<     }
<     indent_down();
<     indent(out) << "})";
<   } else if (type->is_map()) {
<     t_type* ktype = ((t_map*)type)->get_key_type();
<     t_type* vtype = ((t_map*)type)->get_val_type();
<     out << "{" << endl;
<     indent_up();
<     const map<t_const_value*, t_const_value*>& val = value->get_map();
<     map<t_const_value*, t_const_value*>::const_iterator v_iter;
<     for (v_iter = val.begin(); v_iter != val.end(); ++v_iter) {
<       out << indent();
<       out << render_const_value(ktype, v_iter->first);
<       out << " => ";
<       out << render_const_value(vtype, v_iter->second);
<       out << "," << endl;
<     }
<     indent_down();
<     indent(out) << "}";
<   } else if (type->is_list() || type->is_set()) {
<     t_type* etype;
<     if (type->is_list()) {
<       etype = ((t_list*)type)->get_elem_type();
<     } else {
<       etype = ((t_set*)type)->get_elem_type();
<     }
<     if (type->is_set()) {
<       out << "Set.new([" << endl;
<     } else {
<       out << "[" << endl;
<     }
<     indent_up();
<     const vector<t_const_value*>& val = value->get_list();
<     vector<t_const_value*>::const_iterator v_iter;
<     for (v_iter = val.begin(); v_iter != val.end(); ++v_iter) {
<       out << indent();
<       out << render_const_value(etype, *v_iter);
<       out << "," << endl;
<     }
<     indent_down();
<     if (type->is_set()) {
<       indent(out) << "])";
<     } else {
<       indent(out) << "]";
<     }
<   } else {
<     throw "CANNOT GENERATE CONSTANT FOR TYPE: " + type->get_name();
<   }
<   return out.str();
< }
< 
< /**
<  * Generates a ruby struct
<  */
< void t_rb_generator::generate_struct(t_struct* tstruct) {
<   if (tstruct->is_union()) {
<     generate_rb_union(f_types_, tstruct, false);
<   } else {
<     generate_rb_struct(f_types_, tstruct, false);
<   }
< }
< 
< /**
<  * Generates a struct definition for a thrift exception. Basically the same
<  * as a struct but extends the Exception class.
<  *
<  * @param txception The struct definition
<  */
< void t_rb_generator::generate_xception(t_struct* txception) {
<   generate_rb_struct(f_types_, txception, true);
< }
< 
< /**
<  * Generates a ruby struct
<  */
< void t_rb_generator::generate_rb_struct(std::ofstream& out, t_struct* tstruct, bool is_exception = false) {
<   generate_rdoc(out, tstruct);
<   indent(out) << "class " << type_name(tstruct);
<   if (is_exception) {
<     out << " < ::Thrift::Exception";
<   }
<   out << endl;
< 
<   indent_up();
<   indent(out) << "include ::Thrift::Struct, ::Thrift::Struct_Union" << endl;
< 
<   if (is_exception) {
<     generate_rb_simple_exception_constructor(out, tstruct);
<   }
< 
<   generate_field_constants(out, tstruct);
<   generate_field_defns(out, tstruct);
<   generate_rb_struct_required_validator(out, tstruct);
< 
<   indent(out) << "::Thrift::Struct.generate_accessors self" << endl;
< 
<   indent_down();
<   indent(out) << "end" << endl << endl;
< }
< 
< 
< /**
<  * Generates a ruby union
<  */
< void t_rb_generator::generate_rb_union(std::ofstream& out, t_struct* tstruct, bool is_exception = false) {
<   (void) is_exception;
<   generate_rdoc(out, tstruct);
<   indent(out) << "class " << type_name(tstruct) << " < ::Thrift::Union" << endl;
< 
<   indent_up();
<   indent(out) << "include ::Thrift::Struct_Union" << endl;
< 
<   generate_field_constructors(out, tstruct);
< 
<   generate_field_constants(out, tstruct);
<   generate_field_defns(out, tstruct);
<   generate_rb_union_validator(out, tstruct);
< 
<   indent(out) << "::Thrift::Union.generate_accessors self" << endl;
< 
<   indent_down();
<   indent(out) << "end" << endl << endl;
< }
< 
< void t_rb_generator::generate_field_constructors(std::ofstream& out, t_struct* tstruct) {
< 
<   indent(out) << "class << self" << endl;
<   indent_up();
< 
<   const vector<t_field*>& fields = tstruct->get_members();
<   vector<t_field*>::const_iterator f_iter;
< 
<   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
<     if (f_iter != fields.begin()) {
<       out << endl;
<     }
<     std::string field_name = (*f_iter)->get_name();
< 
<     indent(out) << "def " << field_name << "(val)" << endl;
<     indent(out) << "  " << tstruct->get_name() << ".new(:" << field_name << ", val)" << endl;
<     indent(out) << "end" << endl;
<   }
<   
<   indent_down();
<   indent(out) << "end" << endl;
< 
<   out << endl;
< }
< 
< void t_rb_generator::generate_rb_simple_exception_constructor(std::ofstream& out, t_struct* tstruct) {
<   const vector<t_field*>& members = tstruct->get_members();
< 
<   if (members.size() == 1) {
<     vector<t_field*>::const_iterator m_iter = members.begin();
< 
<     if ((*m_iter)->get_type()->is_string()) {
<       string name = (*m_iter)->get_name();
< 
<       indent(out) << "def initialize(message=nil)" << endl;
<       indent_up();
<       indent(out) << "super()" << endl;
<       indent(out) << "self." << name << " = message" << endl;
<       indent_down();
<       indent(out) << "end" << endl << endl;
< 
<       if (name != "message") {
<         indent(out) << "def message; " << name << " end" << endl << endl;
<       }
<     }
<   }
< }
< 
< void t_rb_generator::generate_field_constants(std::ofstream& out, t_struct* tstruct) {
<   const vector<t_field*>& fields = tstruct->get_members();
<   vector<t_field*>::const_iterator f_iter;
< 
<   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
<     std::string field_name = (*f_iter)->get_name();
<     std::string cap_field_name = upcase_string(field_name);
<     
<     indent(out) << cap_field_name << " = " << (*f_iter)->get_key() << endl;
<   }
<   out << endl;
< }
< 
< void t_rb_generator::generate_field_defns(std::ofstream& out, t_struct* tstruct) {
<   const vector<t_field*>& fields = tstruct->get_members();
<   vector<t_field*>::const_iterator f_iter;
< 
<   indent(out) << "FIELDS = {" << endl;
<   indent_up();
<   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
<     if (f_iter != fields.begin()) {
<       out << "," << endl;
<     }
< 
<     // generate the field docstrings within the FIELDS constant. no real better place...
<     generate_rdoc(out, *f_iter);
< 
<     indent(out) <<
<       upcase_string((*f_iter)->get_name()) << " => ";
< 
<     generate_field_data(out, (*f_iter)->get_type(), (*f_iter)->get_name(), (*f_iter)->get_value(), 
<       (*f_iter)->get_req() == t_field::T_OPTIONAL);
<   }
<   indent_down();
<   out << endl;
<   indent(out) << "}" << endl << endl;
<   
<   indent(out) << "def struct_fields; FIELDS; end" << endl << endl;
<   
< }
< 
< void t_rb_generator::generate_field_data(std::ofstream& out, t_type* field_type,
<     const std::string& field_name = "", t_const_value* field_value = NULL, bool optional = false) {
<   field_type = get_true_type(field_type);
< 
<   // Begin this field's defn
<   out << "{:type => " << type_to_enum(field_type);
< 
<   if (!field_name.empty()) {
<     out << ", :name => '" << field_name << "'";
<   }
< 
<   if (field_value != NULL) {
<     out << ", :default => " << render_const_value(field_type, field_value);
<   }
< 
<   if (!field_type->is_base_type()) {
<     if (field_type->is_struct() || field_type->is_xception()) {
<       out << ", :class => " << full_type_name((t_struct*)field_type);
<     } else if (field_type->is_list()) {
<       out << ", :element => ";
<       generate_field_data(out, ((t_list*)field_type)->get_elem_type());
<     } else if (field_type->is_map()) {
<       out << ", :key => ";
<       generate_field_data(out, ((t_map*)field_type)->get_key_type());
<       out << ", :value => ";
<       generate_field_data(out, ((t_map*)field_type)->get_val_type());
<     } else if (field_type->is_set()) {
<       out << ", :element => ";
<       generate_field_data(out, ((t_set*)field_type)->get_elem_type());
<     }
<   } else {
<     if (((t_base_type*)field_type)->is_binary()) {
<       out << ", :binary => true";
<     }
<   }
<   
<   if(optional) {
<     out << ", :optional => true";
<   }
< 
<   if (field_type->is_enum()) {
<     out << ", :enum_class => " << full_type_name(field_type);
<   }
< 
<   // End of this field's defn
<   out << "}";
< }
< 
< void t_rb_generator::begin_namespace(std::ofstream& out, vector<std::string> modules) {
<   for (vector<std::string>::iterator m_iter = modules.begin(); m_iter != modules.end(); ++m_iter) {
<     indent(out) << "module " << *m_iter << endl;
<     indent_up();
<   }
< }
< 
< void t_rb_generator::end_namespace(std::ofstream& out, vector<std::string> modules) {
<   for (vector<std::string>::reverse_iterator m_iter = modules.rbegin(); m_iter != modules.rend(); ++m_iter) {
<     indent_down();
<     indent(out) << "end" << endl;
<   }
< }
< 
< 
< /**
<  * Generates a thrift service.
<  *
<  * @param tservice The service definition
<  */
< void t_rb_generator::generate_service(t_service* tservice) {
<   string f_service_name = get_out_dir()+underscore(service_name_)+".rb";
<   f_service_.open(f_service_name.c_str());
< 
<   f_service_ <<
<     rb_autogen_comment() << endl <<
<     "require 'thrift'" << endl;
< 
<   if (tservice->get_extends() != NULL) {
<     f_service_ <<
<       "require '" << underscore(tservice->get_extends()->get_name()) << "'" << endl;
<   }
< 
<   f_service_ <<
<     "require '" << underscore(program_name_) << "_types'" << endl <<
<     endl;
< 
<   begin_namespace(f_service_, ruby_modules(tservice->get_program()));
< 
<   indent(f_service_) << "module " << capitalize(tservice->get_name()) << endl;
<   indent_up();
< 
<   // Generate the three main parts of the service (well, two for now in PHP)
<   generate_service_client(tservice);
<   generate_service_server(tservice);
<   generate_service_helpers(tservice);
< 
<   indent_down();
<   indent(f_service_) << "end" << endl <<
<     endl;
< 
<   end_namespace(f_service_, ruby_modules(tservice->get_program()));
< 
<   // Close service file
<   f_service_.close();
< }
< 
< /**
<  * Generates helper functions for a service.
<  *
<  * @param tservice The service to generate a header definition for
<  */
< void t_rb_generator::generate_service_helpers(t_service* tservice) {
<   vector<t_function*> functions = tservice->get_functions();
<   vector<t_function*>::iterator f_iter;
< 
<   indent(f_service_) <<
<     "# HELPER FUNCTIONS AND STRUCTURES" << endl << endl;
< 
<   for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
<     t_struct* ts = (*f_iter)->get_arglist();
<     generate_rb_struct(f_service_, ts);
<     generate_rb_function_helpers(*f_iter);
<   }
< }
< 
< /**
<  * Generates a struct and helpers for a function.
<  *
<  * @param tfunction The function
<  */
< void t_rb_generator::generate_rb_function_helpers(t_function* tfunction) {
<   t_struct result(program_, tfunction->get_name() + "_result");
<   t_field success(tfunction->get_returntype(), "success", 0);
<   if (!tfunction->get_returntype()->is_void()) {
<     result.append(&success);
<   }
< 
<   t_struct* xs = tfunction->get_xceptions();
<   const vector<t_field*>& fields = xs->get_members();
<   vector<t_field*>::const_iterator f_iter;
<   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
<     result.append(*f_iter);
<   }
<   generate_rb_struct(f_service_, &result);
< }
< 
< /**
<  * Generates a service client definition.
<  *
<  * @param tservice The service to generate a server for.
<  */
< void t_rb_generator::generate_service_client(t_service* tservice) {
<   string extends = "";
<   string extends_client = "";
<   if (tservice->get_extends() != NULL) {
<     extends = full_type_name(tservice->get_extends());
<     extends_client = " < " + extends + "::Client ";
<   }
< 
<   indent(f_service_) <<
<     "class Client" << extends_client << endl;
<   indent_up();
< 
<   indent(f_service_) <<
<     "include ::Thrift::Client" << endl << endl;
< 
<   // Generate client method implementations
<   vector<t_function*> functions = tservice->get_functions();
<   vector<t_function*>::const_iterator f_iter;
<   for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
<     t_struct* arg_struct = (*f_iter)->get_arglist();
<     const vector<t_field*>& fields = arg_struct->get_members();
<     vector<t_field*>::const_iterator fld_iter;
<     string funname = (*f_iter)->get_name();
< 
<     // Open function
<     indent(f_service_) <<
<       "def " << function_signature(*f_iter) << endl;
<     indent_up();
<       indent(f_service_) <<
<         "send_" << funname << "(";
< 
<       bool first = true;
<       for (fld_iter = fields.begin(); fld_iter != fields.end(); ++fld_iter) {
<         if (first) {
<           first = false;
<         } else {
<           f_service_ << ", ";
<         }
<         f_service_ << (*fld_iter)->get_name();
<       }
<       f_service_ << ")" << endl;
< 
<       if (!(*f_iter)->is_oneway()) {
<         f_service_ << indent();
<         if (!(*f_iter)->get_returntype()->is_void()) {
<           f_service_ << "return ";
<         }
<         f_service_ <<
<           "recv_" << funname << "()" << endl;
<       }
<     indent_down();
<     indent(f_service_) << "end" << endl;
<     f_service_ << endl;
< 
<     indent(f_service_) <<
<       "def send_" << function_signature(*f_iter) << endl;
<     indent_up();
< 
<       std::string argsname = capitalize((*f_iter)->get_name() + "_args");
< 
<       indent(f_service_) << "send_message('" << funname << "', " << argsname;
< 
<       for (fld_iter = fields.begin(); fld_iter != fields.end(); ++fld_iter) {
<         f_service_ << ", :" << (*fld_iter)->get_name() << " => " << (*fld_iter)->get_name();
<       }
< 
<       f_service_ << ")" << endl;
< 
<     indent_down();
<     indent(f_service_) << "end" << endl;
< 
<     if (!(*f_iter)->is_oneway()) {
<       std::string resultname = capitalize((*f_iter)->get_name() + "_result");
<       t_struct noargs(program_);
< 
<       t_function recv_function((*f_iter)->get_returntype(),
<                                string("recv_") + (*f_iter)->get_name(),
<                                &noargs);
<       // Open function
<       f_service_ <<
<         endl <<
<         indent() << "def " << function_signature(&recv_function) << endl;
<       indent_up();
< 
<       // TODO(mcslee): Validate message reply here, seq ids etc.
< 
<       f_service_ <<
<         indent() << "result = receive_message(" << resultname << ")" << endl;
< 
<       // Careful, only return _result if not a void function
<       if (!(*f_iter)->get_returntype()->is_void()) {
<         f_service_ <<
<           indent() << "return result.success unless result.success.nil?" << endl;
<       }
< 
<       t_struct* xs = (*f_iter)->get_xceptions();
<       const std::vector<t_field*>& xceptions = xs->get_members();
<       vector<t_field*>::const_iterator x_iter;
<       for (x_iter = xceptions.begin(); x_iter != xceptions.end(); ++x_iter) {
<         indent(f_service_) <<
<           "raise result." << (*x_iter)->get_name() <<
<             " unless result." << (*x_iter)->get_name() << ".nil?" << endl;
<       }
< 
<       // Careful, only return _result if not a void function
<       if ((*f_iter)->get_returntype()->is_void()) {
<         indent(f_service_) <<
<           "return" << endl;
<       } else {
<         f_service_ <<
<           indent() << "raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, '" << (*f_iter)->get_name() << " failed: unknown result')" << endl;
<       }
< 
<       // Close function
<       indent_down();
<       indent(f_service_) << "end" << endl << endl;
<     }
<   }
< 
<   indent_down();
<   indent(f_service_) << "end" << endl << endl;
< }
< 
< /**
<  * Generates a service server definition.
<  *
<  * @param tservice The service to generate a server for.
<  */
< void t_rb_generator::generate_service_server(t_service* tservice) {
<   // Generate the dispatch methods
<   vector<t_function*> functions = tservice->get_functions();
<   vector<t_function*>::iterator f_iter;
< 
<   string extends = "";
<   string extends_processor = "";
<   if (tservice->get_extends() != NULL) {
<     extends = full_type_name(tservice->get_extends());
<     extends_processor = " < " + extends + "::Processor ";
<   }
< 
<   // Generate the header portion
<   indent(f_service_) <<
<     "class Processor" << extends_processor << endl;
<   indent_up();
< 
<   f_service_ <<
<     indent() << "include ::Thrift::Processor" << endl <<
<     endl;
< 
<   // Generate the process subfunctions
<   for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
<     generate_process_function(tservice, *f_iter);
<   }
< 
<   indent_down();
<   indent(f_service_) << "end" << endl << endl;
< }
< 
< /**
<  * Generates a process function definition.
<  *
<  * @param tfunction The function to write a dispatcher for
<  */
< void t_rb_generator::generate_process_function(t_service* tservice,
<                                                t_function* tfunction) {
<   (void) tservice;
<   // Open function
<   indent(f_service_) <<
<     "def process_" << tfunction->get_name() <<
<     "(seqid, iprot, oprot)" << endl;
<   indent_up();
< 
<   string argsname = capitalize(tfunction->get_name()) + "_args";
<   string resultname = capitalize(tfunction->get_name()) + "_result";
< 
<   f_service_ <<
<     indent() << "args = read_args(iprot, " << argsname << ")" << endl;
< 
<   t_struct* xs = tfunction->get_xceptions();
<   const std::vector<t_field*>& xceptions = xs->get_members();
<   vector<t_field*>::const_iterator x_iter;
< 
<   // Declare result for non oneway function
<   if (!tfunction->is_oneway()) {
<     f_service_ <<
<       indent() << "result = " << resultname << ".new()" << endl;
<   }
< 
<   // Try block for a function with exceptions
<   if (xceptions.size() > 0) {
<     f_service_ <<
<       indent() << "begin" << endl;
<     indent_up();
<   }
< 
<   // Generate the function call
<   t_struct* arg_struct = tfunction->get_arglist();
<   const std::vector<t_field*>& fields = arg_struct->get_members();
<   vector<t_field*>::const_iterator f_iter;
< 
<   f_service_ << indent();
<   if (!tfunction->is_oneway() && !tfunction->get_returntype()->is_void()) {
<     f_service_ << "result.success = ";
<   }
<   f_service_ <<
<     "@handler." << tfunction->get_name() << "(";
<   bool first = true;
<   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
<     if (first) {
<       first = false;
<     } else {
<       f_service_ << ", ";
<     }
<     f_service_ << "args." << (*f_iter)->get_name();
<   }
<   f_service_ << ")" << endl;
< 
<   if (!tfunction->is_oneway() && xceptions.size() > 0) {
<     indent_down();
<     for (x_iter = xceptions.begin(); x_iter != xceptions.end(); ++x_iter) {
<       f_service_ <<
<         indent() << "rescue " << full_type_name((*x_iter)->get_type()) << " => " << (*x_iter)->get_name() << endl;
<       if (!tfunction->is_oneway()) {
<         indent_up();
<         f_service_ <<
<           indent() << "result." << (*x_iter)->get_name() << " = " << (*x_iter)->get_name() << endl;
<         indent_down();
<       }
<     }
<     indent(f_service_) << "end" << endl;
<   }
< 
<   // Shortcut out here for oneway functions
<   if (tfunction->is_oneway()) {
<     f_service_ <<
<       indent() << "return" << endl;
<     indent_down();
<     indent(f_service_) << "end" << endl << endl;
<     return;
<   }
< 
<   f_service_ <<
<     indent() << "write_result(result, oprot, '" << tfunction->get_name() << "', seqid)" << endl;
< 
<   // Close function
<   indent_down();
<   indent(f_service_) << "end" << endl << endl;
< }
< 
< /**
<  * Renders a function signature of the form 'type name(args)'
<  *
<  * @param tfunction Function definition
<  * @return String of rendered function definition
<  */
< string t_rb_generator::function_signature(t_function* tfunction,
<                                            string prefix) {
<   // TODO(mcslee): Nitpicky, no ',' if argument_list is empty
<   return
<     prefix + tfunction->get_name() +
<     "(" +  argument_list(tfunction->get_arglist()) + ")";
< }
< 
< /**
<  * Renders a field list
<  */
< string t_rb_generator::argument_list(t_struct* tstruct) {
<   string result = "";
< 
<   const vector<t_field*>& fields = tstruct->get_members();
<   vector<t_field*>::const_iterator f_iter;
<   bool first = true;
<   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
<     if (first) {
<       first = false;
<     } else {
<       result += ", ";
<     }
<     result += (*f_iter)->get_name();
<   }
<   return result;
< }
< 
< string t_rb_generator::type_name(t_type* ttype) {
<   string prefix = "";
< 
<   string name = ttype->get_name();
<   if (ttype->is_struct() || ttype->is_xception() || ttype->is_enum()) {
<     name = capitalize(ttype->get_name());
<   }
< 
<   return prefix + name;
< }
< 
< string t_rb_generator::full_type_name(t_type* ttype) {
<   string prefix = "";
<   vector<std::string> modules = ruby_modules(ttype->get_program());
<   for (vector<std::string>::iterator m_iter = modules.begin();
<        m_iter != modules.end(); ++m_iter) {
<     prefix += *m_iter + "::";
<   }
<   return prefix + type_name(ttype);
< }
< 
< /**
<  * Converts the parse type to a Ruby tyoe
<  */
< string t_rb_generator::type_to_enum(t_type* type) {
<   type = get_true_type(type);
< 
<   if (type->is_base_type()) {
<     t_base_type::t_base tbase = ((t_base_type*)type)->get_base();
<     switch (tbase) {
<     case t_base_type::TYPE_VOID:
<       throw "NO T_VOID CONSTRUCT";
<     case t_base_type::TYPE_STRING:
<       return "::Thrift::Types::STRING";
<     case t_base_type::TYPE_BOOL:
<       return "::Thrift::Types::BOOL";
<     case t_base_type::TYPE_BYTE:
<       return "::Thrift::Types::BYTE";
<     case t_base_type::TYPE_I16:
<       return "::Thrift::Types::I16";
<     case t_base_type::TYPE_I32:
<       return "::Thrift::Types::I32";
<     case t_base_type::TYPE_I64:
<       return "::Thrift::Types::I64";
<     case t_base_type::TYPE_DOUBLE:
<       return "::Thrift::Types::DOUBLE";
<     }
<   } else if (type->is_enum()) {
<     return "::Thrift::Types::I32";
<   } else if (type->is_struct() || type->is_xception()) {
<     return "::Thrift::Types::STRUCT";
<   } else if (type->is_map()) {
<     return "::Thrift::Types::MAP";
<   } else if (type->is_set()) {
<     return "::Thrift::Types::SET";
<   } else if (type->is_list()) {
<     return "::Thrift::Types::LIST";
<   }
< 
<   throw "INVALID TYPE IN type_to_enum: " + type->get_name();
< }
< 
< 
< void t_rb_generator::generate_rdoc(std::ofstream& out, t_doc* tdoc) {
<   if (tdoc->has_doc()) {
<     generate_docstring_comment(out,
<       "", "# ", tdoc->get_doc(), "");
<   }
< }
< 
< void t_rb_generator::generate_rb_struct_required_validator(std::ofstream& out, 
<                                                            t_struct* tstruct) {
<   indent(out) << "def validate" << endl;
<   indent_up();
< 
<   const vector<t_field*>& fields = tstruct->get_members();
<   vector<t_field*>::const_iterator f_iter;
< 
<   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
<     t_field* field = (*f_iter);
<     if (field->get_req() == t_field::T_REQUIRED) {
<       indent(out) << "raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field " << field->get_name() << " is unset!')";
<       if (field->get_type()->is_bool()) {
<         out << " if @" << field->get_name() << ".nil?";
<       } else {
<         out << " unless @" << field->get_name();
<       }
<       out << endl;
<     }
<   }
< 
<   // if field is an enum, check that its value is valid
<   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
<     t_field* field = (*f_iter);
< 
<     if (field->get_type()->is_enum()){      
<       indent(out) << "unless @" << field->get_name() << ".nil? || " << full_type_name(field->get_type()) << "::VALID_VALUES.include?(@" << field->get_name() << ")" << endl;
<       indent_up();
<       indent(out) << "raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field " << field->get_name() << "!')" << endl;  
<       indent_down();
<       indent(out) << "end" << endl;
<     }
<   }
< 
<   indent_down();
<   indent(out) << "end" << endl << endl;
< }
< 
< void t_rb_generator::generate_rb_union_validator(std::ofstream& out, 
<                                                  t_struct* tstruct) {
<   indent(out) << "def validate" << endl;
<   indent_up();
< 
<   const vector<t_field*>& fields = tstruct->get_members();
<   vector<t_field*>::const_iterator f_iter;
< 
<   indent(out) << "raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?" << endl;
< 
<   // if field is an enum, check that its value is valid
<   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
<     const t_field* field = (*f_iter);
< 
<     if (field->get_type()->is_enum()){      
<       indent(out) << "if get_set_field == :" << field->get_name() << endl;
<       indent(out) << "  raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field " << field->get_name() << "!') unless " << full_type_name(field->get_type()) << "::VALID_VALUES.include?(get_value)" << endl;  
<       indent(out) << "end" << endl;
<     }
<   }
< 
<   indent_down();
<   indent(out) << "end" << endl << endl;
< }
< 
< THRIFT_REGISTER_GENERATOR(rb, "Ruby", "")
< 
---
> /*
>  * Licensed to the Apache Software Foundation (ASF) under one
>  * or more contributor license agreements. See the NOTICE file
>  * distributed with this work for additional information
>  * regarding copyright ownership. The ASF licenses this file
>  * to you under the Apache License, Version 2.0 (the
>  * "License"); you may not use this file except in compliance
>  * with the License. You may obtain a copy of the License at
>  *
>  *   http://www.apache.org/licenses/LICENSE-2.0
>  *
>  * Unless required by applicable law or agreed to in writing,
>  * software distributed under the License is distributed on an
>  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
>  * KIND, either express or implied. See the License for the
>  * specific language governing permissions and limitations
>  * under the License.
>  *
>  * Contains some contributions under the Thrift Software License.
>  * Please see doc/old-thrift-license.txt in the Thrift distribution for
>  * details.
>  */
> 
> #include <string>
> #include <fstream>
> #include <iostream>
> #include <vector>
> #include <algorithm>
> 
> #include <stdlib.h>
> #include <sys/stat.h>
> #include <sys/types.h>
> #include <sstream>
> 
> #include "t_oop_generator.h"
> #include "platform.h"
> #include "version.h"
> 
> using namespace std;
> 
> 
> /**
>  * Ruby code generator.
>  *
>  */
> class t_rb_generator : public t_oop_generator {
>  public:
>   t_rb_generator(
>       t_program* program,
>       const std::map<std::string, std::string>& parsed_options,
>       const std::string& option_string)
>     : t_oop_generator(program)
>   {
>     (void) parsed_options;
>     (void) option_string;
>     out_dir_base_ = "gen-rb";
>   }
> 
>   /**
>    * Init and close methods
>    */
> 
>   void init_generator();
>   void close_generator();
> 
>   /**
>    * Program-level generation functions
>    */
> 
>   void generate_typedef     (t_typedef*  ttypedef);
>   void generate_enum        (t_enum*     tenum);
>   void generate_const       (t_const*    tconst);
>   void generate_struct      (t_struct*   tstruct);
>   void generate_union        (t_struct*   tunion);
>   void generate_xception    (t_struct*   txception);
>   void generate_service     (t_service*  tservice);
> 
>   std::string render_const_value(t_type* type, t_const_value* value);
> 
>   /**
>    * Struct generation code
>    */
> 
>   void generate_rb_struct(std::ofstream& out, t_struct* tstruct, bool is_exception);
>   void generate_rb_struct_required_validator(std::ofstream& out, t_struct* tstruct);
>   void generate_rb_union(std::ofstream& out, t_struct* tstruct, bool is_exception);
>   void generate_rb_union_validator(std::ofstream& out, t_struct* tstruct);
>   void generate_rb_function_helpers(t_function* tfunction);
>   void generate_rb_simple_constructor(std::ofstream& out, t_struct* tstruct);
>   void generate_rb_simple_exception_constructor(std::ofstream& out, t_struct* tstruct);
>   void generate_field_constants (std::ofstream& out, t_struct* tstruct);
>   void generate_field_constructors (std::ofstream& out, t_struct* tstruct);
>   void generate_field_defns (std::ofstream& out, t_struct* tstruct);
>   void generate_field_data  (std::ofstream& out, t_type* field_type, const std::string& field_name, t_const_value* field_value, bool optional);
> 
>   /**
>    * Service-level generation functions
>    */
> 
>   void generate_service_helpers   (t_service*  tservice);
>   void generate_service_interface (t_service* tservice);
>   void generate_service_client    (t_service* tservice);
>   void generate_service_server    (t_service* tservice);
>   void generate_process_function  (t_service* tservice, t_function* tfunction);
> 
>   /**
>    * Serialization constructs
>    */
> 
>   void generate_deserialize_field        (std::ofstream &out,
>                                           t_field*    tfield,
>                                           std::string prefix="",
>                                           bool inclass=false);
> 
>   void generate_deserialize_struct       (std::ofstream &out,
>                                           t_struct*   tstruct,
>                                           std::string prefix="");
> 
>   void generate_deserialize_container    (std::ofstream &out,
>                                           t_type*     ttype,
>                                           std::string prefix="");
> 
>   void generate_deserialize_set_element  (std::ofstream &out,
>                                           t_set*      tset,
>                                           std::string prefix="");
> 
>   void generate_deserialize_map_element  (std::ofstream &out,
>                                           t_map*      tmap,
>                                           std::string prefix="");
> 
>   void generate_deserialize_list_element (std::ofstream &out,
>                                           t_list*     tlist,
>                                           std::string prefix="");
> 
>   void generate_serialize_field          (std::ofstream &out,
>                                           t_field*    tfield,
>                                           std::string prefix="");
> 
>   void generate_serialize_struct         (std::ofstream &out,
>                                           t_struct*   tstruct,
>                                           std::string prefix="");
> 
>   void generate_serialize_container      (std::ofstream &out,
>                                           t_type*     ttype,
>                                           std::string prefix="");
> 
>   void generate_serialize_map_element    (std::ofstream &out,
>                                           t_map*      tmap,
>                                           std::string kiter,
>                                           std::string viter);
> 
>   void generate_serialize_set_element    (std::ofstream &out,
>                                           t_set*      tmap,
>                                           std::string iter);
> 
>   void generate_serialize_list_element   (std::ofstream &out,
>                                           t_list*     tlist,
>                                           std::string iter);
> 
>   void generate_rdoc                     (std::ofstream& out, 
>                                           t_doc* tdoc);
> 
>   /**
>    * Helper rendering functions
>    */
> 
>   std::string rb_autogen_comment();
>   std::string render_includes();
>   std::string declare_field(t_field* tfield);
>   std::string type_name(t_type* ttype);
>   std::string full_type_name(t_type* ttype);
>   std::string function_signature(t_function* tfunction, std::string prefix="");
>   std::string argument_list(t_struct* tstruct);
>   std::string type_to_enum(t_type* ttype);
> 
> 
> 
>   std::vector<std::string> ruby_modules(t_program* p) {
>     std::string ns = p->get_namespace("rb");
>     std::vector<std::string> modules;
>     if (ns.empty()) {
>       return modules;
>     }
> 
>     std::string::iterator pos = ns.begin();
>     while (true) {
>       std::string::iterator delim = std::find(pos, ns.end(), '.');
>       modules.push_back(capitalize(std::string(pos, delim)));
>       pos = delim;
>       if (pos == ns.end()) {
>         break;
>       }
>       ++pos;
>     }
> 
>     return modules;
>   }
> 
>   void begin_namespace(std::ofstream&, std::vector<std::string>);
>   void end_namespace(std::ofstream&, std::vector<std::string>);
> 
>  private:
> 
>   /**
>    * File streams
>    */
> 
>   std::ofstream f_types_;
>   std::ofstream f_consts_;
>   std::ofstream f_service_;
> 
> };
> 
> 
> /**
>  * Prepares for file generation by opening up the necessary file output
>  * streams.
>  *
>  * @param tprogram The program to generate
>  */
> void t_rb_generator::init_generator() {
>   // Make output directory
>   MKDIR(get_out_dir().c_str());
> 
>   // Make output file
>   string f_types_name = get_out_dir()+underscore(program_name_)+"_types.rb";
>   f_types_.open(f_types_name.c_str());
> 
>   string f_consts_name = get_out_dir()+underscore(program_name_)+"_constants.rb";
>   f_consts_.open(f_consts_name.c_str());
> 
>   // Print header
>   f_types_ <<
>     rb_autogen_comment() << endl <<
>     render_includes() << endl;
>     begin_namespace(f_types_, ruby_modules(program_));
> 
>   f_consts_ <<
>     rb_autogen_comment() << endl <<
>     "require '" << underscore(program_name_) << "_types'" << endl <<
>     endl;
>     begin_namespace(f_consts_, ruby_modules(program_));
> 
> }
> 
> /**
>  * Renders all the imports necessary for including another Thrift program
>  */
> string t_rb_generator::render_includes() {
>   const vector<t_program*>& includes = program_->get_includes();
>   string result = "";
>   for (size_t i = 0; i < includes.size(); ++i) {
>     result += "require '" + underscore(includes[i]->get_name()) + "_types'\n";
>   }
>   if (includes.size() > 0) {
>     result += "\n";
>   }
>   return result;
> }
> 
> /**
>  * Autogen'd comment
>  */
> string t_rb_generator::rb_autogen_comment() {
>   return
>     std::string("#\n") +
>     "# Autogenerated by Thrift Compiler (" + THRIFT_VERSION + ")\n" +
>     "#\n" +
>     "# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n" +
>     "#\n";
> }
> 
> /**
>  * Closes the type files
>  */
> void t_rb_generator::close_generator() {
>   // Close types file
>   end_namespace(f_types_, ruby_modules(program_));
>   end_namespace(f_consts_, ruby_modules(program_));
>   f_types_.close();
>   f_consts_.close();
> }
> 
> /**
>  * Generates a typedef. This is not done in Ruby, types are all implicit.
>  *
>  * @param ttypedef The type definition
>  */
> void t_rb_generator::generate_typedef(t_typedef* ttypedef) {
>   (void) ttypedef;
> }
> 
> /**
>  * Generates code for an enumerated type. Done using a class to scope
>  * the values.
>  *
>  * @param tenum The enumeration
>  */
> void t_rb_generator::generate_enum(t_enum* tenum) {
>   indent(f_types_) <<
>     "module " << capitalize(tenum->get_name()) << endl;
>   indent_up();
> 
>   vector<t_enum_value*> constants = tenum->get_constants();
>   vector<t_enum_value*>::iterator c_iter;
>   for (c_iter = constants.begin(); c_iter != constants.end(); ++c_iter) {
>     int value = (*c_iter)->get_value();
> 
>     // Ruby class constants have to be capitalized... omg i am so on the fence
>     // about languages strictly enforcing capitalization why can't we just all
>     // agree and play nice.
>     string name = capitalize((*c_iter)->get_name());
> 
>     generate_rdoc(f_types_, *c_iter);
>     indent(f_types_) << name << " = " << value << endl;
>   }
>   
>   // Create a hash mapping values back to their names (as strings) since ruby has no native enum type
>   indent(f_types_) << "VALUE_MAP = {";
>   bool first = true;
>   for(c_iter = constants.begin(); c_iter != constants.end(); ++c_iter) {
>     // Populate the hash
>     int value = (*c_iter)->get_value();
>     first ? first = false : static_cast<bool>(f_types_ << ", ");
>     f_types_ << value << " => \"" << capitalize((*c_iter)->get_name()) << "\"";
>   }
>   f_types_ << "}" << endl;
>   
>   // Create a set with valid values for this enum
>   indent(f_types_) << "VALID_VALUES = Set.new([";
>   first = true;
>   for (c_iter = constants.begin(); c_iter != constants.end(); ++c_iter) {
>     // Populate the set
>     first ? first = false : static_cast<bool>(f_types_ << ", ");
>     f_types_ << capitalize((*c_iter)->get_name());
>   }
>   f_types_ << "]).freeze" << endl;
> 
>   indent_down();
>   indent(f_types_) <<
>     "end" << endl << endl;
> }
> 
> /**
>  * Generate a constant value
>  */
> void t_rb_generator::generate_const(t_const* tconst) {
>   t_type* type = tconst->get_type();
>   string name = tconst->get_name();
>   t_const_value* value = tconst->get_value();
> 
>   name[0] = toupper(name[0]);
> 
>   indent(f_consts_) << name << " = " << render_const_value(type, value);
>   f_consts_ << endl << endl;
> }
> 
> /**
>  * Prints the value of a constant with the given type. Note that type checking
>  * is NOT performed in this function as it is always run beforehand using the
>  * validate_types method in main.cc
>  */
> string t_rb_generator::render_const_value(t_type* type, t_const_value* value) {
>   type = get_true_type(type);
>   std::ostringstream out;
>   if (type->is_base_type()) {
>     t_base_type::t_base tbase = ((t_base_type*)type)->get_base();
>     switch (tbase) {
>     case t_base_type::TYPE_STRING:
>       out << "%q\"" << get_escaped_string(value) << '"';
>       break;
>     case t_base_type::TYPE_BOOL:
>       out << (value->get_integer() > 0 ? "true" : "false");
>       break;
>     case t_base_type::TYPE_BYTE:
>     case t_base_type::TYPE_I16:
>     case t_base_type::TYPE_I32:
>     case t_base_type::TYPE_I64:
>       out << value->get_integer();
>       break;
>     case t_base_type::TYPE_DOUBLE:
>       if (value->get_type() == t_const_value::CV_INTEGER) {
>         out << value->get_integer();
>       } else {
>         out << value->get_double();
>       }
>       break;
>     default:
>       throw "compiler error: no const of base type " + t_base_type::t_base_name(tbase);
>     }
>   } else if (type->is_enum()) {
>     indent(out) << value->get_integer();
>   } else if (type->is_struct() || type->is_xception()) {
>     out << full_type_name(type) << ".new({" << endl;
>     indent_up();
>     const vector<t_field*>& fields = ((t_struct*)type)->get_members();
>     vector<t_field*>::const_iterator f_iter;
>     const map<t_const_value*, t_const_value*>& val = value->get_map();
>     map<t_const_value*, t_const_value*>::const_iterator v_iter;
>     for (v_iter = val.begin(); v_iter != val.end(); ++v_iter) {
>       t_type* field_type = NULL;
>       for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
>         if ((*f_iter)->get_name() == v_iter->first->get_string()) {
>           field_type = (*f_iter)->get_type();
>         }
>       }
>       if (field_type == NULL) {
>         throw "type error: " + type->get_name() + " has no field " + v_iter->first->get_string();
>       }
>       out << indent();
>       out << render_const_value(g_type_string, v_iter->first);
>       out << " => ";
>       out << render_const_value(field_type, v_iter->second);
>       out << "," << endl;
>     }
>     indent_down();
>     indent(out) << "})";
>   } else if (type->is_map()) {
>     t_type* ktype = ((t_map*)type)->get_key_type();
>     t_type* vtype = ((t_map*)type)->get_val_type();
>     out << "{" << endl;
>     indent_up();
>     const map<t_const_value*, t_const_value*>& val = value->get_map();
>     map<t_const_value*, t_const_value*>::const_iterator v_iter;
>     for (v_iter = val.begin(); v_iter != val.end(); ++v_iter) {
>       out << indent();
>       out << render_const_value(ktype, v_iter->first);
>       out << " => ";
>       out << render_const_value(vtype, v_iter->second);
>       out << "," << endl;
>     }
>     indent_down();
>     indent(out) << "}";
>   } else if (type->is_list() || type->is_set()) {
>     t_type* etype;
>     if (type->is_list()) {
>       etype = ((t_list*)type)->get_elem_type();
>     } else {
>       etype = ((t_set*)type)->get_elem_type();
>     }
>     if (type->is_set()) {
>       out << "Set.new([" << endl;
>     } else {
>       out << "[" << endl;
>     }
>     indent_up();
>     const vector<t_const_value*>& val = value->get_list();
>     vector<t_const_value*>::const_iterator v_iter;
>     for (v_iter = val.begin(); v_iter != val.end(); ++v_iter) {
>       out << indent();
>       out << render_const_value(etype, *v_iter);
>       out << "," << endl;
>     }
>     indent_down();
>     if (type->is_set()) {
>       indent(out) << "])";
>     } else {
>       indent(out) << "]";
>     }
>   } else {
>     throw "CANNOT GENERATE CONSTANT FOR TYPE: " + type->get_name();
>   }
>   return out.str();
> }
> 
> /**
>  * Generates a ruby struct
>  */
> void t_rb_generator::generate_struct(t_struct* tstruct) {
>   if (tstruct->is_union()) {
>     generate_rb_union(f_types_, tstruct, false);
>   } else {
>     generate_rb_struct(f_types_, tstruct, false);
>   }
> }
> 
> /**
>  * Generates a struct definition for a thrift exception. Basically the same
>  * as a struct but extends the Exception class.
>  *
>  * @param txception The struct definition
>  */
> void t_rb_generator::generate_xception(t_struct* txception) {
>   generate_rb_struct(f_types_, txception, true);
> }
> 
> /**
>  * Generates a ruby struct
>  */
> void t_rb_generator::generate_rb_struct(std::ofstream& out, t_struct* tstruct, bool is_exception = false) {
>   generate_rdoc(out, tstruct);
>   indent(out) << "class " << type_name(tstruct);
>   if (is_exception) {
>     out << " < ::Thrift::Exception";
>   }
>   out << endl;
> 
>   indent_up();
>   indent(out) << "include ::Thrift::Struct, ::Thrift::Struct_Union" << endl;
> 
>   if (is_exception) {
>     generate_rb_simple_exception_constructor(out, tstruct);
>   }
> 
>   generate_field_constants(out, tstruct);
>   generate_field_defns(out, tstruct);
>   generate_rb_struct_required_validator(out, tstruct);
> 
>   indent(out) << "::Thrift::Struct.generate_accessors self" << endl;
> 
>   indent_down();
>   indent(out) << "end" << endl << endl;
> }
> 
> 
> /**
>  * Generates a ruby union
>  */
> void t_rb_generator::generate_rb_union(std::ofstream& out, t_struct* tstruct, bool is_exception = false) {
>   (void) is_exception;
>   generate_rdoc(out, tstruct);
>   indent(out) << "class " << type_name(tstruct) << " < ::Thrift::Union" << endl;
> 
>   indent_up();
>   indent(out) << "include ::Thrift::Struct_Union" << endl;
> 
>   generate_field_constructors(out, tstruct);
> 
>   generate_field_constants(out, tstruct);
>   generate_field_defns(out, tstruct);
>   generate_rb_union_validator(out, tstruct);
> 
>   indent(out) << "::Thrift::Union.generate_accessors self" << endl;
> 
>   indent_down();
>   indent(out) << "end" << endl << endl;
> }
> 
> void t_rb_generator::generate_field_constructors(std::ofstream& out, t_struct* tstruct) {
> 
>   indent(out) << "class << self" << endl;
>   indent_up();
> 
>   const vector<t_field*>& fields = tstruct->get_members();
>   vector<t_field*>::const_iterator f_iter;
> 
>   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
>     if (f_iter != fields.begin()) {
>       out << endl;
>     }
>     std::string field_name = (*f_iter)->get_name();
> 
>     indent(out) << "def " << field_name << "(val)" << endl;
>     indent(out) << "  " << tstruct->get_name() << ".new(:" << field_name << ", val)" << endl;
>     indent(out) << "end" << endl;
>   }
>   
>   indent_down();
>   indent(out) << "end" << endl;
> 
>   out << endl;
> }
> 
> void t_rb_generator::generate_rb_simple_exception_constructor(std::ofstream& out, t_struct* tstruct) {
>   const vector<t_field*>& members = tstruct->get_members();
> 
>   if (members.size() == 1) {
>     vector<t_field*>::const_iterator m_iter = members.begin();
> 
>     if ((*m_iter)->get_type()->is_string()) {
>       string name = (*m_iter)->get_name();
> 
>       indent(out) << "def initialize(message=nil)" << endl;
>       indent_up();
>       indent(out) << "super()" << endl;
>       indent(out) << "self." << name << " = message" << endl;
>       indent_down();
>       indent(out) << "end" << endl << endl;
> 
>       if (name != "message") {
>         indent(out) << "def message; " << name << " end" << endl << endl;
>       }
>     }
>   }
> }
> 
> void t_rb_generator::generate_field_constants(std::ofstream& out, t_struct* tstruct) {
>   const vector<t_field*>& fields = tstruct->get_members();
>   vector<t_field*>::const_iterator f_iter;
> 
>   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
>     std::string field_name = (*f_iter)->get_name();
>     std::string cap_field_name = upcase_string(field_name);
>     
>     indent(out) << cap_field_name << " = " << (*f_iter)->get_key() << endl;
>   }
>   out << endl;
> }
> 
> void t_rb_generator::generate_field_defns(std::ofstream& out, t_struct* tstruct) {
>   const vector<t_field*>& fields = tstruct->get_members();
>   vector<t_field*>::const_iterator f_iter;
> 
>   indent(out) << "FIELDS = {" << endl;
>   indent_up();
>   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
>     if (f_iter != fields.begin()) {
>       out << "," << endl;
>     }
> 
>     // generate the field docstrings within the FIELDS constant. no real better place...
>     generate_rdoc(out, *f_iter);
> 
>     indent(out) <<
>       upcase_string((*f_iter)->get_name()) << " => ";
> 
>     generate_field_data(out, (*f_iter)->get_type(), (*f_iter)->get_name(), (*f_iter)->get_value(), 
>       (*f_iter)->get_req() == t_field::T_OPTIONAL);
>   }
>   indent_down();
>   out << endl;
>   indent(out) << "}" << endl << endl;
>   
>   indent(out) << "def struct_fields; FIELDS; end" << endl << endl;
>   
> }
> 
> void t_rb_generator::generate_field_data(std::ofstream& out, t_type* field_type,
>     const std::string& field_name = "", t_const_value* field_value = NULL, bool optional = false) {
>   field_type = get_true_type(field_type);
> 
>   // Begin this field's defn
>   out << "{:type => " << type_to_enum(field_type);
> 
>   if (!field_name.empty()) {
>     out << ", :name => '" << field_name << "'";
>   }
> 
>   if (field_value != NULL) {
>     out << ", :default => " << render_const_value(field_type, field_value);
>   }
> 
>   if (!field_type->is_base_type()) {
>     if (field_type->is_struct() || field_type->is_xception()) {
>       out << ", :class => " << full_type_name((t_struct*)field_type);
>     } else if (field_type->is_list()) {
>       out << ", :element => ";
>       generate_field_data(out, ((t_list*)field_type)->get_elem_type());
>     } else if (field_type->is_map()) {
>       out << ", :key => ";
>       generate_field_data(out, ((t_map*)field_type)->get_key_type());
>       out << ", :value => ";
>       generate_field_data(out, ((t_map*)field_type)->get_val_type());
>     } else if (field_type->is_set()) {
>       out << ", :element => ";
>       generate_field_data(out, ((t_set*)field_type)->get_elem_type());
>     }
>   } else {
>     if (((t_base_type*)field_type)->is_binary()) {
>       out << ", :binary => true";
>     }
>   }
>   
>   if(optional) {
>     out << ", :optional => true";
>   }
> 
>   if (field_type->is_enum()) {
>     out << ", :enum_class => " << full_type_name(field_type);
>   }
> 
>   // End of this field's defn
>   out << "}";
> }
> 
> void t_rb_generator::begin_namespace(std::ofstream& out, vector<std::string> modules) {
>   for (vector<std::string>::iterator m_iter = modules.begin(); m_iter != modules.end(); ++m_iter) {
>     indent(out) << "module " << *m_iter << endl;
>     indent_up();
>   }
> }
> 
> void t_rb_generator::end_namespace(std::ofstream& out, vector<std::string> modules) {
>   for (vector<std::string>::reverse_iterator m_iter = modules.rbegin(); m_iter != modules.rend(); ++m_iter) {
>     indent_down();
>     indent(out) << "end" << endl;
>   }
> }
> 
> 
> /**
>  * Generates a thrift service.
>  *
>  * @param tservice The service definition
>  */
> void t_rb_generator::generate_service(t_service* tservice) {
>   string f_service_name = get_out_dir()+underscore(service_name_)+".rb";
>   f_service_.open(f_service_name.c_str());
> 
>   f_service_ <<
>     rb_autogen_comment() << endl <<
>     "require 'thrift'" << endl;
> 
>   if (tservice->get_extends() != NULL) {
>     f_service_ <<
>       "require '" << underscore(tservice->get_extends()->get_name()) << "'" << endl;
>   }
> 
>   f_service_ <<
>     "require '" << underscore(program_name_) << "_types'" << endl <<
>     endl;
> 
>   begin_namespace(f_service_, ruby_modules(tservice->get_program()));
> 
>   indent(f_service_) << "module " << capitalize(tservice->get_name()) << endl;
>   indent_up();
> 
>   // Generate the three main parts of the service (well, two for now in PHP)
>   generate_service_client(tservice);
>   generate_service_server(tservice);
>   generate_service_helpers(tservice);
> 
>   indent_down();
>   indent(f_service_) << "end" << endl <<
>     endl;
> 
>   end_namespace(f_service_, ruby_modules(tservice->get_program()));
> 
>   // Close service file
>   f_service_.close();
> }
> 
> /**
>  * Generates helper functions for a service.
>  *
>  * @param tservice The service to generate a header definition for
>  */
> void t_rb_generator::generate_service_helpers(t_service* tservice) {
>   vector<t_function*> functions = tservice->get_functions();
>   vector<t_function*>::iterator f_iter;
> 
>   indent(f_service_) <<
>     "# HELPER FUNCTIONS AND STRUCTURES" << endl << endl;
> 
>   for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
>     t_struct* ts = (*f_iter)->get_arglist();
>     generate_rb_struct(f_service_, ts);
>     generate_rb_function_helpers(*f_iter);
>   }
> }
> 
> /**
>  * Generates a struct and helpers for a function.
>  *
>  * @param tfunction The function
>  */
> void t_rb_generator::generate_rb_function_helpers(t_function* tfunction) {
>   t_struct result(program_, tfunction->get_name() + "_result");
>   t_field success(tfunction->get_returntype(), "success", 0);
>   if (!tfunction->get_returntype()->is_void()) {
>     result.append(&success);
>   }
> 
>   t_struct* xs = tfunction->get_xceptions();
>   const vector<t_field*>& fields = xs->get_members();
>   vector<t_field*>::const_iterator f_iter;
>   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
>     result.append(*f_iter);
>   }
>   generate_rb_struct(f_service_, &result);
> }
> 
> /**
>  * Generates a service client definition.
>  *
>  * @param tservice The service to generate a server for.
>  */
> void t_rb_generator::generate_service_client(t_service* tservice) {
>   string extends = "";
>   string extends_client = "";
>   if (tservice->get_extends() != NULL) {
>     extends = full_type_name(tservice->get_extends());
>     extends_client = " < " + extends + "::Client ";
>   }
> 
>   indent(f_service_) <<
>     "class Client" << extends_client << endl;
>   indent_up();
> 
>   indent(f_service_) <<
>     "include ::Thrift::Client" << endl << endl;
> 
>   // Generate client method implementations
>   vector<t_function*> functions = tservice->get_functions();
>   vector<t_function*>::const_iterator f_iter;
>   for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
>     t_struct* arg_struct = (*f_iter)->get_arglist();
>     const vector<t_field*>& fields = arg_struct->get_members();
>     vector<t_field*>::const_iterator fld_iter;
>     string funname = (*f_iter)->get_name();
> 
>     // Open function
>     indent(f_service_) <<
>       "def " << function_signature(*f_iter) << endl;
>     indent_up();
>       indent(f_service_) <<
>         "send_" << funname << "(";
> 
>       bool first = true;
>       for (fld_iter = fields.begin(); fld_iter != fields.end(); ++fld_iter) {
>         if (first) {
>           first = false;
>         } else {
>           f_service_ << ", ";
>         }
>         f_service_ << (*fld_iter)->get_name();
>       }
>       f_service_ << ")" << endl;
> 
>       if (!(*f_iter)->is_oneway()) {
>         f_service_ << indent();
>         if (!(*f_iter)->get_returntype()->is_void()) {
>           f_service_ << "return ";
>         }
>         f_service_ <<
>           "recv_" << funname << "()" << endl;
>       }
>     indent_down();
>     indent(f_service_) << "end" << endl;
>     f_service_ << endl;
> 
>     indent(f_service_) <<
>       "def send_" << function_signature(*f_iter) << endl;
>     indent_up();
> 
>       std::string argsname = capitalize((*f_iter)->get_name() + "_args");
> 
>       indent(f_service_) << "send_message('" << funname << "', " << argsname;
> 
>       for (fld_iter = fields.begin(); fld_iter != fields.end(); ++fld_iter) {
>         f_service_ << ", :" << (*fld_iter)->get_name() << " => " << (*fld_iter)->get_name();
>       }
> 
>       f_service_ << ")" << endl;
> 
>     indent_down();
>     indent(f_service_) << "end" << endl;
> 
>     if (!(*f_iter)->is_oneway()) {
>       std::string resultname = capitalize((*f_iter)->get_name() + "_result");
>       t_struct noargs(program_);
> 
>       t_function recv_function((*f_iter)->get_returntype(),
>                                string("recv_") + (*f_iter)->get_name(),
>                                &noargs);
>       // Open function
>       f_service_ <<
>         endl <<
>         indent() << "def " << function_signature(&recv_function) << endl;
>       indent_up();
> 
>       // TODO(mcslee): Validate message reply here, seq ids etc.
> 
>       f_service_ <<
>         indent() << "result = receive_message(" << resultname << ")" << endl;
> 
>       // Careful, only return _result if not a void function
>       if (!(*f_iter)->get_returntype()->is_void()) {
>         f_service_ <<
>           indent() << "return result.success unless result.success.nil?" << endl;
>       }
> 
>       t_struct* xs = (*f_iter)->get_xceptions();
>       const std::vector<t_field*>& xceptions = xs->get_members();
>       vector<t_field*>::const_iterator x_iter;
>       for (x_iter = xceptions.begin(); x_iter != xceptions.end(); ++x_iter) {
>         indent(f_service_) <<
>           "raise result." << (*x_iter)->get_name() <<
>             " unless result." << (*x_iter)->get_name() << ".nil?" << endl;
>       }
> 
>       // Careful, only return _result if not a void function
>       if ((*f_iter)->get_returntype()->is_void()) {
>         indent(f_service_) <<
>           "return" << endl;
>       } else {
>         f_service_ <<
>           indent() << "raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, '" << (*f_iter)->get_name() << " failed: unknown result')" << endl;
>       }
> 
>       // Close function
>       indent_down();
>       indent(f_service_) << "end" << endl << endl;
>     }
>   }
> 
>   indent_down();
>   indent(f_service_) << "end" << endl << endl;
> }
> 
> /**
>  * Generates a service server definition.
>  *
>  * @param tservice The service to generate a server for.
>  */
> void t_rb_generator::generate_service_server(t_service* tservice) {
>   // Generate the dispatch methods
>   vector<t_function*> functions = tservice->get_functions();
>   vector<t_function*>::iterator f_iter;
> 
>   string extends = "";
>   string extends_processor = "";
>   if (tservice->get_extends() != NULL) {
>     extends = full_type_name(tservice->get_extends());
>     extends_processor = " < " + extends + "::Processor ";
>   }
> 
>   // Generate the header portion
>   indent(f_service_) <<
>     "class Processor" << extends_processor << endl;
>   indent_up();
> 
>   f_service_ <<
>     indent() << "include ::Thrift::Processor" << endl <<
>     endl;
> 
>   // Generate the process subfunctions
>   for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
>     generate_process_function(tservice, *f_iter);
>   }
> 
>   indent_down();
>   indent(f_service_) << "end" << endl << endl;
> }
> 
> /**
>  * Generates a process function definition.
>  *
>  * @param tfunction The function to write a dispatcher for
>  */
> void t_rb_generator::generate_process_function(t_service* tservice,
>                                                t_function* tfunction) {
>   (void) tservice;
>   // Open function
>   indent(f_service_) <<
>     "def process_" << tfunction->get_name() <<
>     "(seqid, iprot, oprot)" << endl;
>   indent_up();
> 
>   string argsname = capitalize(tfunction->get_name()) + "_args";
>   string resultname = capitalize(tfunction->get_name()) + "_result";
> 
>   f_service_ <<
>     indent() << "args = read_args(iprot, " << argsname << ")" << endl;
> 
>   t_struct* xs = tfunction->get_xceptions();
>   const std::vector<t_field*>& xceptions = xs->get_members();
>   vector<t_field*>::const_iterator x_iter;
> 
>   // Declare result for non oneway function
>   if (!tfunction->is_oneway()) {
>     f_service_ <<
>       indent() << "result = " << resultname << ".new()" << endl;
>   }
> 
>   // Try block for a function with exceptions
>   if (xceptions.size() > 0) {
>     f_service_ <<
>       indent() << "begin" << endl;
>     indent_up();
>   }
> 
>   // Generate the function call
>   t_struct* arg_struct = tfunction->get_arglist();
>   const std::vector<t_field*>& fields = arg_struct->get_members();
>   vector<t_field*>::const_iterator f_iter;
> 
>   f_service_ << indent();
>   if (!tfunction->is_oneway() && !tfunction->get_returntype()->is_void()) {
>     f_service_ << "result.success = ";
>   }
>   f_service_ <<
>     "@handler." << tfunction->get_name() << "(";
>   bool first = true;
>   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
>     if (first) {
>       first = false;
>     } else {
>       f_service_ << ", ";
>     }
>     f_service_ << "args." << (*f_iter)->get_name();
>   }
>   f_service_ << ")" << endl;
> 
>   if (!tfunction->is_oneway() && xceptions.size() > 0) {
>     indent_down();
>     for (x_iter = xceptions.begin(); x_iter != xceptions.end(); ++x_iter) {
>       f_service_ <<
>         indent() << "rescue " << full_type_name((*x_iter)->get_type()) << " => " << (*x_iter)->get_name() << endl;
>       if (!tfunction->is_oneway()) {
>         indent_up();
>         f_service_ <<
>           indent() << "result." << (*x_iter)->get_name() << " = " << (*x_iter)->get_name() << endl;
>         indent_down();
>       }
>     }
>     indent(f_service_) << "end" << endl;
>   }
> 
>   // Shortcut out here for oneway functions
>   if (tfunction->is_oneway()) {
>     f_service_ <<
>       indent() << "return" << endl;
>     indent_down();
>     indent(f_service_) << "end" << endl << endl;
>     return;
>   }
> 
>   f_service_ <<
>     indent() << "write_result(result, oprot, '" << tfunction->get_name() << "', seqid)" << endl;
> 
>   // Close function
>   indent_down();
>   indent(f_service_) << "end" << endl << endl;
> }
> 
> /**
>  * Renders a function signature of the form 'type name(args)'
>  *
>  * @param tfunction Function definition
>  * @return String of rendered function definition
>  */
> string t_rb_generator::function_signature(t_function* tfunction,
>                                            string prefix) {
>   // TODO(mcslee): Nitpicky, no ',' if argument_list is empty
>   return
>     prefix + tfunction->get_name() +
>     "(" +  argument_list(tfunction->get_arglist()) + ")";
> }
> 
> /**
>  * Renders a field list
>  */
> string t_rb_generator::argument_list(t_struct* tstruct) {
>   string result = "";
> 
>   const vector<t_field*>& fields = tstruct->get_members();
>   vector<t_field*>::const_iterator f_iter;
>   bool first = true;
>   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
>     if (first) {
>       first = false;
>     } else {
>       result += ", ";
>     }
>     result += (*f_iter)->get_name();
>   }
>   return result;
> }
> 
> string t_rb_generator::type_name(t_type* ttype) {
>   string prefix = "";
> 
>   string name = ttype->get_name();
>   if (ttype->is_struct() || ttype->is_xception() || ttype->is_enum()) {
>     name = capitalize(ttype->get_name());
>   }
> 
>   return prefix + name;
> }
> 
> string t_rb_generator::full_type_name(t_type* ttype) {
>   string prefix = "";
>   vector<std::string> modules = ruby_modules(ttype->get_program());
>   for (vector<std::string>::iterator m_iter = modules.begin();
>        m_iter != modules.end(); ++m_iter) {
>     prefix += *m_iter + "::";
>   }
>   return prefix + type_name(ttype);
> }
> 
> /**
>  * Converts the parse type to a Ruby tyoe
>  */
> string t_rb_generator::type_to_enum(t_type* type) {
>   type = get_true_type(type);
> 
>   if (type->is_base_type()) {
>     t_base_type::t_base tbase = ((t_base_type*)type)->get_base();
>     switch (tbase) {
>     case t_base_type::TYPE_VOID:
>       throw "NO T_VOID CONSTRUCT";
>     case t_base_type::TYPE_STRING:
>       return "::Thrift::Types::STRING";
>     case t_base_type::TYPE_BOOL:
>       return "::Thrift::Types::BOOL";
>     case t_base_type::TYPE_BYTE:
>       return "::Thrift::Types::BYTE";
>     case t_base_type::TYPE_I16:
>       return "::Thrift::Types::I16";
>     case t_base_type::TYPE_I32:
>       return "::Thrift::Types::I32";
>     case t_base_type::TYPE_I64:
>       return "::Thrift::Types::I64";
>     case t_base_type::TYPE_DOUBLE:
>       return "::Thrift::Types::DOUBLE";
>     }
>   } else if (type->is_enum()) {
>     return "::Thrift::Types::I32";
>   } else if (type->is_struct() || type->is_xception()) {
>     return "::Thrift::Types::STRUCT";
>   } else if (type->is_map()) {
>     return "::Thrift::Types::MAP";
>   } else if (type->is_set()) {
>     return "::Thrift::Types::SET";
>   } else if (type->is_list()) {
>     return "::Thrift::Types::LIST";
>   }
> 
>   throw "INVALID TYPE IN type_to_enum: " + type->get_name();
> }
> 
> 
> void t_rb_generator::generate_rdoc(std::ofstream& out, t_doc* tdoc) {
>   if (tdoc->has_doc()) {
>     generate_docstring_comment(out,
>       "", "# ", tdoc->get_doc(), "");
>   }
> }
> 
> void t_rb_generator::generate_rb_struct_required_validator(std::ofstream& out, 
>                                                            t_struct* tstruct) {
>   indent(out) << "def validate" << endl;
>   indent_up();
> 
>   const vector<t_field*>& fields = tstruct->get_members();
>   vector<t_field*>::const_iterator f_iter;
> 
>   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
>     t_field* field = (*f_iter);
>     if (field->get_req() == t_field::T_REQUIRED) {
>       indent(out) << "raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field " << field->get_name() << " is unset!')";
>       if (field->get_type()->is_bool()) {
>         out << " if @" << field->get_name() << ".nil?";
>       } else {
>         out << " unless @" << field->get_name();
>       }
>       out << endl;
>     }
>   }
> 
>   // if field is an enum, check that its value is valid
>   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
>     t_field* field = (*f_iter);
> 
>     if (field->get_type()->is_enum()){      
>       indent(out) << "unless @" << field->get_name() << ".nil? || " << full_type_name(field->get_type()) << "::VALID_VALUES.include?(@" << field->get_name() << ")" << endl;
>       indent_up();
>       indent(out) << "raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field " << field->get_name() << "!')" << endl;  
>       indent_down();
>       indent(out) << "end" << endl;
>     }
>   }
> 
>   indent_down();
>   indent(out) << "end" << endl << endl;
> }
> 
> void t_rb_generator::generate_rb_union_validator(std::ofstream& out, 
>                                                  t_struct* tstruct) {
>   indent(out) << "def validate" << endl;
>   indent_up();
> 
>   const vector<t_field*>& fields = tstruct->get_members();
>   vector<t_field*>::const_iterator f_iter;
> 
>   indent(out) << "raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?" << endl;
> 
>   // if field is an enum, check that its value is valid
>   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
>     const t_field* field = (*f_iter);
> 
>     if (field->get_type()->is_enum()){      
>       indent(out) << "if get_set_field == :" << field->get_name() << endl;
>       indent(out) << "  raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field " << field->get_name() << "!') unless " << full_type_name(field->get_type()) << "::VALID_VALUES.include?(get_value)" << endl;  
>       indent(out) << "end" << endl;
>     }
>   }
> 
>   indent_down();
>   indent(out) << "end" << endl << endl;
> }
> 
> THRIFT_REGISTER_GENERATOR(rb, "Ruby", "")
> 
