--- compiler/cpp/src/generate/t_rb_generator.cc	Sat Nov 26 11:00:48 2011
+++ compiler/cpp/src/generate/t_rb_generator.cc	Wed Oct 11 15:45:33 2017
@@ -1,1195 +1,1195 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements. See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership. The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations
- * under the License.
- *
- * Contains some contributions under the Thrift Software License.
- * Please see doc/old-thrift-license.txt in the Thrift distribution for
- * details.
- */
-
-#include <string>
-#include <fstream>
-#include <iostream>
-#include <vector>
-#include <algorithm>
-
-#include <stdlib.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sstream>
-
-#include "t_oop_generator.h"
-#include "platform.h"
-#include "version.h"
-
-using namespace std;
-
-
-/**
- * Ruby code generator.
- *
- */
-class t_rb_generator : public t_oop_generator {
- public:
-  t_rb_generator(
-      t_program* program,
-      const std::map<std::string, std::string>& parsed_options,
-      const std::string& option_string)
-    : t_oop_generator(program)
-  {
-    (void) parsed_options;
-    (void) option_string;
-    out_dir_base_ = "gen-rb";
-  }
-
-  /**
-   * Init and close methods
-   */
-
-  void init_generator();
-  void close_generator();
-
-  /**
-   * Program-level generation functions
-   */
-
-  void generate_typedef     (t_typedef*  ttypedef);
-  void generate_enum        (t_enum*     tenum);
-  void generate_const       (t_const*    tconst);
-  void generate_struct      (t_struct*   tstruct);
-  void generate_union        (t_struct*   tunion);
-  void generate_xception    (t_struct*   txception);
-  void generate_service     (t_service*  tservice);
-
-  std::string render_const_value(t_type* type, t_const_value* value);
-
-  /**
-   * Struct generation code
-   */
-
-  void generate_rb_struct(std::ofstream& out, t_struct* tstruct, bool is_exception);
-  void generate_rb_struct_required_validator(std::ofstream& out, t_struct* tstruct);
-  void generate_rb_union(std::ofstream& out, t_struct* tstruct, bool is_exception);
-  void generate_rb_union_validator(std::ofstream& out, t_struct* tstruct);
-  void generate_rb_function_helpers(t_function* tfunction);
-  void generate_rb_simple_constructor(std::ofstream& out, t_struct* tstruct);
-  void generate_rb_simple_exception_constructor(std::ofstream& out, t_struct* tstruct);
-  void generate_field_constants (std::ofstream& out, t_struct* tstruct);
-  void generate_field_constructors (std::ofstream& out, t_struct* tstruct);
-  void generate_field_defns (std::ofstream& out, t_struct* tstruct);
-  void generate_field_data  (std::ofstream& out, t_type* field_type, const std::string& field_name, t_const_value* field_value, bool optional);
-
-  /**
-   * Service-level generation functions
-   */
-
-  void generate_service_helpers   (t_service*  tservice);
-  void generate_service_interface (t_service* tservice);
-  void generate_service_client    (t_service* tservice);
-  void generate_service_server    (t_service* tservice);
-  void generate_process_function  (t_service* tservice, t_function* tfunction);
-
-  /**
-   * Serialization constructs
-   */
-
-  void generate_deserialize_field        (std::ofstream &out,
-                                          t_field*    tfield,
-                                          std::string prefix="",
-                                          bool inclass=false);
-
-  void generate_deserialize_struct       (std::ofstream &out,
-                                          t_struct*   tstruct,
-                                          std::string prefix="");
-
-  void generate_deserialize_container    (std::ofstream &out,
-                                          t_type*     ttype,
-                                          std::string prefix="");
-
-  void generate_deserialize_set_element  (std::ofstream &out,
-                                          t_set*      tset,
-                                          std::string prefix="");
-
-  void generate_deserialize_map_element  (std::ofstream &out,
-                                          t_map*      tmap,
-                                          std::string prefix="");
-
-  void generate_deserialize_list_element (std::ofstream &out,
-                                          t_list*     tlist,
-                                          std::string prefix="");
-
-  void generate_serialize_field          (std::ofstream &out,
-                                          t_field*    tfield,
-                                          std::string prefix="");
-
-  void generate_serialize_struct         (std::ofstream &out,
-                                          t_struct*   tstruct,
-                                          std::string prefix="");
-
-  void generate_serialize_container      (std::ofstream &out,
-                                          t_type*     ttype,
-                                          std::string prefix="");
-
-  void generate_serialize_map_element    (std::ofstream &out,
-                                          t_map*      tmap,
-                                          std::string kiter,
-                                          std::string viter);
-
-  void generate_serialize_set_element    (std::ofstream &out,
-                                          t_set*      tmap,
-                                          std::string iter);
-
-  void generate_serialize_list_element   (std::ofstream &out,
-                                          t_list*     tlist,
-                                          std::string iter);
-
-  void generate_rdoc                     (std::ofstream& out, 
-                                          t_doc* tdoc);
-
-  /**
-   * Helper rendering functions
-   */
-
-  std::string rb_autogen_comment();
-  std::string render_includes();
-  std::string declare_field(t_field* tfield);
-  std::string type_name(t_type* ttype);
-  std::string full_type_name(t_type* ttype);
-  std::string function_signature(t_function* tfunction, std::string prefix="");
-  std::string argument_list(t_struct* tstruct);
-  std::string type_to_enum(t_type* ttype);
-
-
-
-  std::vector<std::string> ruby_modules(t_program* p) {
-    std::string ns = p->get_namespace("rb");
-    std::vector<std::string> modules;
-    if (ns.empty()) {
-      return modules;
-    }
-
-    std::string::iterator pos = ns.begin();
-    while (true) {
-      std::string::iterator delim = std::find(pos, ns.end(), '.');
-      modules.push_back(capitalize(std::string(pos, delim)));
-      pos = delim;
-      if (pos == ns.end()) {
-        break;
-      }
-      ++pos;
-    }
-
-    return modules;
-  }
-
-  void begin_namespace(std::ofstream&, std::vector<std::string>);
-  void end_namespace(std::ofstream&, std::vector<std::string>);
-
- private:
-
-  /**
-   * File streams
-   */
-
-  std::ofstream f_types_;
-  std::ofstream f_consts_;
-  std::ofstream f_service_;
-
-};
-
-
-/**
- * Prepares for file generation by opening up the necessary file output
- * streams.
- *
- * @param tprogram The program to generate
- */
-void t_rb_generator::init_generator() {
-  // Make output directory
-  MKDIR(get_out_dir().c_str());
-
-  // Make output file
-  string f_types_name = get_out_dir()+underscore(program_name_)+"_types.rb";
-  f_types_.open(f_types_name.c_str());
-
-  string f_consts_name = get_out_dir()+underscore(program_name_)+"_constants.rb";
-  f_consts_.open(f_consts_name.c_str());
-
-  // Print header
-  f_types_ <<
-    rb_autogen_comment() << endl <<
-    render_includes() << endl;
-    begin_namespace(f_types_, ruby_modules(program_));
-
-  f_consts_ <<
-    rb_autogen_comment() << endl <<
-    "require '" << underscore(program_name_) << "_types'" << endl <<
-    endl;
-    begin_namespace(f_consts_, ruby_modules(program_));
-
-}
-
-/**
- * Renders all the imports necessary for including another Thrift program
- */
-string t_rb_generator::render_includes() {
-  const vector<t_program*>& includes = program_->get_includes();
-  string result = "";
-  for (size_t i = 0; i < includes.size(); ++i) {
-    result += "require '" + underscore(includes[i]->get_name()) + "_types'\n";
-  }
-  if (includes.size() > 0) {
-    result += "\n";
-  }
-  return result;
-}
-
-/**
- * Autogen'd comment
- */
-string t_rb_generator::rb_autogen_comment() {
-  return
-    std::string("#\n") +
-    "# Autogenerated by Thrift Compiler (" + THRIFT_VERSION + ")\n" +
-    "#\n" +
-    "# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n" +
-    "#\n";
-}
-
-/**
- * Closes the type files
- */
-void t_rb_generator::close_generator() {
-  // Close types file
-  end_namespace(f_types_, ruby_modules(program_));
-  end_namespace(f_consts_, ruby_modules(program_));
-  f_types_.close();
-  f_consts_.close();
-}
-
-/**
- * Generates a typedef. This is not done in Ruby, types are all implicit.
- *
- * @param ttypedef The type definition
- */
-void t_rb_generator::generate_typedef(t_typedef* ttypedef) {
-  (void) ttypedef;
-}
-
-/**
- * Generates code for an enumerated type. Done using a class to scope
- * the values.
- *
- * @param tenum The enumeration
- */
-void t_rb_generator::generate_enum(t_enum* tenum) {
-  indent(f_types_) <<
-    "module " << capitalize(tenum->get_name()) << endl;
-  indent_up();
-
-  vector<t_enum_value*> constants = tenum->get_constants();
-  vector<t_enum_value*>::iterator c_iter;
-  for (c_iter = constants.begin(); c_iter != constants.end(); ++c_iter) {
-    int value = (*c_iter)->get_value();
-
-    // Ruby class constants have to be capitalized... omg i am so on the fence
-    // about languages strictly enforcing capitalization why can't we just all
-    // agree and play nice.
-    string name = capitalize((*c_iter)->get_name());
-
-    generate_rdoc(f_types_, *c_iter);
-    indent(f_types_) << name << " = " << value << endl;
-  }
-  
-  // Create a hash mapping values back to their names (as strings) since ruby has no native enum type
-  indent(f_types_) << "VALUE_MAP = {";
-  bool first = true;
-  for(c_iter = constants.begin(); c_iter != constants.end(); ++c_iter) {
-    // Populate the hash
-    int value = (*c_iter)->get_value();
-    first ? first = false : f_types_ << ", ";
-    f_types_ << value << " => \"" << capitalize((*c_iter)->get_name()) << "\"";
-  }
-  f_types_ << "}" << endl;
-  
-  // Create a set with valid values for this enum
-  indent(f_types_) << "VALID_VALUES = Set.new([";
-  first = true;
-  for (c_iter = constants.begin(); c_iter != constants.end(); ++c_iter) {
-    // Populate the set
-    first ? first = false : f_types_ << ", ";
-    f_types_ << capitalize((*c_iter)->get_name());
-  }
-  f_types_ << "]).freeze" << endl;
-
-  indent_down();
-  indent(f_types_) <<
-    "end" << endl << endl;
-}
-
-/**
- * Generate a constant value
- */
-void t_rb_generator::generate_const(t_const* tconst) {
-  t_type* type = tconst->get_type();
-  string name = tconst->get_name();
-  t_const_value* value = tconst->get_value();
-
-  name[0] = toupper(name[0]);
-
-  indent(f_consts_) << name << " = " << render_const_value(type, value);
-  f_consts_ << endl << endl;
-}
-
-/**
- * Prints the value of a constant with the given type. Note that type checking
- * is NOT performed in this function as it is always run beforehand using the
- * validate_types method in main.cc
- */
-string t_rb_generator::render_const_value(t_type* type, t_const_value* value) {
-  type = get_true_type(type);
-  std::ostringstream out;
-  if (type->is_base_type()) {
-    t_base_type::t_base tbase = ((t_base_type*)type)->get_base();
-    switch (tbase) {
-    case t_base_type::TYPE_STRING:
-      out << "%q\"" << get_escaped_string(value) << '"';
-      break;
-    case t_base_type::TYPE_BOOL:
-      out << (value->get_integer() > 0 ? "true" : "false");
-      break;
-    case t_base_type::TYPE_BYTE:
-    case t_base_type::TYPE_I16:
-    case t_base_type::TYPE_I32:
-    case t_base_type::TYPE_I64:
-      out << value->get_integer();
-      break;
-    case t_base_type::TYPE_DOUBLE:
-      if (value->get_type() == t_const_value::CV_INTEGER) {
-        out << value->get_integer();
-      } else {
-        out << value->get_double();
-      }
-      break;
-    default:
-      throw "compiler error: no const of base type " + t_base_type::t_base_name(tbase);
-    }
-  } else if (type->is_enum()) {
-    indent(out) << value->get_integer();
-  } else if (type->is_struct() || type->is_xception()) {
-    out << full_type_name(type) << ".new({" << endl;
-    indent_up();
-    const vector<t_field*>& fields = ((t_struct*)type)->get_members();
-    vector<t_field*>::const_iterator f_iter;
-    const map<t_const_value*, t_const_value*>& val = value->get_map();
-    map<t_const_value*, t_const_value*>::const_iterator v_iter;
-    for (v_iter = val.begin(); v_iter != val.end(); ++v_iter) {
-      t_type* field_type = NULL;
-      for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
-        if ((*f_iter)->get_name() == v_iter->first->get_string()) {
-          field_type = (*f_iter)->get_type();
-        }
-      }
-      if (field_type == NULL) {
-        throw "type error: " + type->get_name() + " has no field " + v_iter->first->get_string();
-      }
-      out << indent();
-      out << render_const_value(g_type_string, v_iter->first);
-      out << " => ";
-      out << render_const_value(field_type, v_iter->second);
-      out << "," << endl;
-    }
-    indent_down();
-    indent(out) << "})";
-  } else if (type->is_map()) {
-    t_type* ktype = ((t_map*)type)->get_key_type();
-    t_type* vtype = ((t_map*)type)->get_val_type();
-    out << "{" << endl;
-    indent_up();
-    const map<t_const_value*, t_const_value*>& val = value->get_map();
-    map<t_const_value*, t_const_value*>::const_iterator v_iter;
-    for (v_iter = val.begin(); v_iter != val.end(); ++v_iter) {
-      out << indent();
-      out << render_const_value(ktype, v_iter->first);
-      out << " => ";
-      out << render_const_value(vtype, v_iter->second);
-      out << "," << endl;
-    }
-    indent_down();
-    indent(out) << "}";
-  } else if (type->is_list() || type->is_set()) {
-    t_type* etype;
-    if (type->is_list()) {
-      etype = ((t_list*)type)->get_elem_type();
-    } else {
-      etype = ((t_set*)type)->get_elem_type();
-    }
-    if (type->is_set()) {
-      out << "Set.new([" << endl;
-    } else {
-      out << "[" << endl;
-    }
-    indent_up();
-    const vector<t_const_value*>& val = value->get_list();
-    vector<t_const_value*>::const_iterator v_iter;
-    for (v_iter = val.begin(); v_iter != val.end(); ++v_iter) {
-      out << indent();
-      out << render_const_value(etype, *v_iter);
-      out << "," << endl;
-    }
-    indent_down();
-    if (type->is_set()) {
-      indent(out) << "])";
-    } else {
-      indent(out) << "]";
-    }
-  } else {
-    throw "CANNOT GENERATE CONSTANT FOR TYPE: " + type->get_name();
-  }
-  return out.str();
-}
-
-/**
- * Generates a ruby struct
- */
-void t_rb_generator::generate_struct(t_struct* tstruct) {
-  if (tstruct->is_union()) {
-    generate_rb_union(f_types_, tstruct, false);
-  } else {
-    generate_rb_struct(f_types_, tstruct, false);
-  }
-}
-
-/**
- * Generates a struct definition for a thrift exception. Basically the same
- * as a struct but extends the Exception class.
- *
- * @param txception The struct definition
- */
-void t_rb_generator::generate_xception(t_struct* txception) {
-  generate_rb_struct(f_types_, txception, true);
-}
-
-/**
- * Generates a ruby struct
- */
-void t_rb_generator::generate_rb_struct(std::ofstream& out, t_struct* tstruct, bool is_exception = false) {
-  generate_rdoc(out, tstruct);
-  indent(out) << "class " << type_name(tstruct);
-  if (is_exception) {
-    out << " < ::Thrift::Exception";
-  }
-  out << endl;
-
-  indent_up();
-  indent(out) << "include ::Thrift::Struct, ::Thrift::Struct_Union" << endl;
-
-  if (is_exception) {
-    generate_rb_simple_exception_constructor(out, tstruct);
-  }
-
-  generate_field_constants(out, tstruct);
-  generate_field_defns(out, tstruct);
-  generate_rb_struct_required_validator(out, tstruct);
-
-  indent(out) << "::Thrift::Struct.generate_accessors self" << endl;
-
-  indent_down();
-  indent(out) << "end" << endl << endl;
-}
-
-
-/**
- * Generates a ruby union
- */
-void t_rb_generator::generate_rb_union(std::ofstream& out, t_struct* tstruct, bool is_exception = false) {
-  (void) is_exception;
-  generate_rdoc(out, tstruct);
-  indent(out) << "class " << type_name(tstruct) << " < ::Thrift::Union" << endl;
-
-  indent_up();
-  indent(out) << "include ::Thrift::Struct_Union" << endl;
-
-  generate_field_constructors(out, tstruct);
-
-  generate_field_constants(out, tstruct);
-  generate_field_defns(out, tstruct);
-  generate_rb_union_validator(out, tstruct);
-
-  indent(out) << "::Thrift::Union.generate_accessors self" << endl;
-
-  indent_down();
-  indent(out) << "end" << endl << endl;
-}
-
-void t_rb_generator::generate_field_constructors(std::ofstream& out, t_struct* tstruct) {
-
-  indent(out) << "class << self" << endl;
-  indent_up();
-
-  const vector<t_field*>& fields = tstruct->get_members();
-  vector<t_field*>::const_iterator f_iter;
-
-  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
-    if (f_iter != fields.begin()) {
-      out << endl;
-    }
-    std::string field_name = (*f_iter)->get_name();
-
-    indent(out) << "def " << field_name << "(val)" << endl;
-    indent(out) << "  " << tstruct->get_name() << ".new(:" << field_name << ", val)" << endl;
-    indent(out) << "end" << endl;
-  }
-  
-  indent_down();
-  indent(out) << "end" << endl;
-
-  out << endl;
-}
-
-void t_rb_generator::generate_rb_simple_exception_constructor(std::ofstream& out, t_struct* tstruct) {
-  const vector<t_field*>& members = tstruct->get_members();
-
-  if (members.size() == 1) {
-    vector<t_field*>::const_iterator m_iter = members.begin();
-
-    if ((*m_iter)->get_type()->is_string()) {
-      string name = (*m_iter)->get_name();
-
-      indent(out) << "def initialize(message=nil)" << endl;
-      indent_up();
-      indent(out) << "super()" << endl;
-      indent(out) << "self." << name << " = message" << endl;
-      indent_down();
-      indent(out) << "end" << endl << endl;
-
-      if (name != "message") {
-        indent(out) << "def message; " << name << " end" << endl << endl;
-      }
-    }
-  }
-}
-
-void t_rb_generator::generate_field_constants(std::ofstream& out, t_struct* tstruct) {
-  const vector<t_field*>& fields = tstruct->get_members();
-  vector<t_field*>::const_iterator f_iter;
-
-  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
-    std::string field_name = (*f_iter)->get_name();
-    std::string cap_field_name = upcase_string(field_name);
-    
-    indent(out) << cap_field_name << " = " << (*f_iter)->get_key() << endl;
-  }
-  out << endl;
-}
-
-void t_rb_generator::generate_field_defns(std::ofstream& out, t_struct* tstruct) {
-  const vector<t_field*>& fields = tstruct->get_members();
-  vector<t_field*>::const_iterator f_iter;
-
-  indent(out) << "FIELDS = {" << endl;
-  indent_up();
-  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
-    if (f_iter != fields.begin()) {
-      out << "," << endl;
-    }
-
-    // generate the field docstrings within the FIELDS constant. no real better place...
-    generate_rdoc(out, *f_iter);
-
-    indent(out) <<
-      upcase_string((*f_iter)->get_name()) << " => ";
-
-    generate_field_data(out, (*f_iter)->get_type(), (*f_iter)->get_name(), (*f_iter)->get_value(), 
-      (*f_iter)->get_req() == t_field::T_OPTIONAL);
-  }
-  indent_down();
-  out << endl;
-  indent(out) << "}" << endl << endl;
-  
-  indent(out) << "def struct_fields; FIELDS; end" << endl << endl;
-  
-}
-
-void t_rb_generator::generate_field_data(std::ofstream& out, t_type* field_type,
-    const std::string& field_name = "", t_const_value* field_value = NULL, bool optional = false) {
-  field_type = get_true_type(field_type);
-
-  // Begin this field's defn
-  out << "{:type => " << type_to_enum(field_type);
-
-  if (!field_name.empty()) {
-    out << ", :name => '" << field_name << "'";
-  }
-
-  if (field_value != NULL) {
-    out << ", :default => " << render_const_value(field_type, field_value);
-  }
-
-  if (!field_type->is_base_type()) {
-    if (field_type->is_struct() || field_type->is_xception()) {
-      out << ", :class => " << full_type_name((t_struct*)field_type);
-    } else if (field_type->is_list()) {
-      out << ", :element => ";
-      generate_field_data(out, ((t_list*)field_type)->get_elem_type());
-    } else if (field_type->is_map()) {
-      out << ", :key => ";
-      generate_field_data(out, ((t_map*)field_type)->get_key_type());
-      out << ", :value => ";
-      generate_field_data(out, ((t_map*)field_type)->get_val_type());
-    } else if (field_type->is_set()) {
-      out << ", :element => ";
-      generate_field_data(out, ((t_set*)field_type)->get_elem_type());
-    }
-  } else {
-    if (((t_base_type*)field_type)->is_binary()) {
-      out << ", :binary => true";
-    }
-  }
-  
-  if(optional) {
-    out << ", :optional => true";
-  }
-
-  if (field_type->is_enum()) {
-    out << ", :enum_class => " << full_type_name(field_type);
-  }
-
-  // End of this field's defn
-  out << "}";
-}
-
-void t_rb_generator::begin_namespace(std::ofstream& out, vector<std::string> modules) {
-  for (vector<std::string>::iterator m_iter = modules.begin(); m_iter != modules.end(); ++m_iter) {
-    indent(out) << "module " << *m_iter << endl;
-    indent_up();
-  }
-}
-
-void t_rb_generator::end_namespace(std::ofstream& out, vector<std::string> modules) {
-  for (vector<std::string>::reverse_iterator m_iter = modules.rbegin(); m_iter != modules.rend(); ++m_iter) {
-    indent_down();
-    indent(out) << "end" << endl;
-  }
-}
-
-
-/**
- * Generates a thrift service.
- *
- * @param tservice The service definition
- */
-void t_rb_generator::generate_service(t_service* tservice) {
-  string f_service_name = get_out_dir()+underscore(service_name_)+".rb";
-  f_service_.open(f_service_name.c_str());
-
-  f_service_ <<
-    rb_autogen_comment() << endl <<
-    "require 'thrift'" << endl;
-
-  if (tservice->get_extends() != NULL) {
-    f_service_ <<
-      "require '" << underscore(tservice->get_extends()->get_name()) << "'" << endl;
-  }
-
-  f_service_ <<
-    "require '" << underscore(program_name_) << "_types'" << endl <<
-    endl;
-
-  begin_namespace(f_service_, ruby_modules(tservice->get_program()));
-
-  indent(f_service_) << "module " << capitalize(tservice->get_name()) << endl;
-  indent_up();
-
-  // Generate the three main parts of the service (well, two for now in PHP)
-  generate_service_client(tservice);
-  generate_service_server(tservice);
-  generate_service_helpers(tservice);
-
-  indent_down();
-  indent(f_service_) << "end" << endl <<
-    endl;
-
-  end_namespace(f_service_, ruby_modules(tservice->get_program()));
-
-  // Close service file
-  f_service_.close();
-}
-
-/**
- * Generates helper functions for a service.
- *
- * @param tservice The service to generate a header definition for
- */
-void t_rb_generator::generate_service_helpers(t_service* tservice) {
-  vector<t_function*> functions = tservice->get_functions();
-  vector<t_function*>::iterator f_iter;
-
-  indent(f_service_) <<
-    "# HELPER FUNCTIONS AND STRUCTURES" << endl << endl;
-
-  for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
-    t_struct* ts = (*f_iter)->get_arglist();
-    generate_rb_struct(f_service_, ts);
-    generate_rb_function_helpers(*f_iter);
-  }
-}
-
-/**
- * Generates a struct and helpers for a function.
- *
- * @param tfunction The function
- */
-void t_rb_generator::generate_rb_function_helpers(t_function* tfunction) {
-  t_struct result(program_, tfunction->get_name() + "_result");
-  t_field success(tfunction->get_returntype(), "success", 0);
-  if (!tfunction->get_returntype()->is_void()) {
-    result.append(&success);
-  }
-
-  t_struct* xs = tfunction->get_xceptions();
-  const vector<t_field*>& fields = xs->get_members();
-  vector<t_field*>::const_iterator f_iter;
-  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
-    result.append(*f_iter);
-  }
-  generate_rb_struct(f_service_, &result);
-}
-
-/**
- * Generates a service client definition.
- *
- * @param tservice The service to generate a server for.
- */
-void t_rb_generator::generate_service_client(t_service* tservice) {
-  string extends = "";
-  string extends_client = "";
-  if (tservice->get_extends() != NULL) {
-    extends = full_type_name(tservice->get_extends());
-    extends_client = " < " + extends + "::Client ";
-  }
-
-  indent(f_service_) <<
-    "class Client" << extends_client << endl;
-  indent_up();
-
-  indent(f_service_) <<
-    "include ::Thrift::Client" << endl << endl;
-
-  // Generate client method implementations
-  vector<t_function*> functions = tservice->get_functions();
-  vector<t_function*>::const_iterator f_iter;
-  for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
-    t_struct* arg_struct = (*f_iter)->get_arglist();
-    const vector<t_field*>& fields = arg_struct->get_members();
-    vector<t_field*>::const_iterator fld_iter;
-    string funname = (*f_iter)->get_name();
-
-    // Open function
-    indent(f_service_) <<
-      "def " << function_signature(*f_iter) << endl;
-    indent_up();
-      indent(f_service_) <<
-        "send_" << funname << "(";
-
-      bool first = true;
-      for (fld_iter = fields.begin(); fld_iter != fields.end(); ++fld_iter) {
-        if (first) {
-          first = false;
-        } else {
-          f_service_ << ", ";
-        }
-        f_service_ << (*fld_iter)->get_name();
-      }
-      f_service_ << ")" << endl;
-
-      if (!(*f_iter)->is_oneway()) {
-        f_service_ << indent();
-        if (!(*f_iter)->get_returntype()->is_void()) {
-          f_service_ << "return ";
-        }
-        f_service_ <<
-          "recv_" << funname << "()" << endl;
-      }
-    indent_down();
-    indent(f_service_) << "end" << endl;
-    f_service_ << endl;
-
-    indent(f_service_) <<
-      "def send_" << function_signature(*f_iter) << endl;
-    indent_up();
-
-      std::string argsname = capitalize((*f_iter)->get_name() + "_args");
-
-      indent(f_service_) << "send_message('" << funname << "', " << argsname;
-
-      for (fld_iter = fields.begin(); fld_iter != fields.end(); ++fld_iter) {
-        f_service_ << ", :" << (*fld_iter)->get_name() << " => " << (*fld_iter)->get_name();
-      }
-
-      f_service_ << ")" << endl;
-
-    indent_down();
-    indent(f_service_) << "end" << endl;
-
-    if (!(*f_iter)->is_oneway()) {
-      std::string resultname = capitalize((*f_iter)->get_name() + "_result");
-      t_struct noargs(program_);
-
-      t_function recv_function((*f_iter)->get_returntype(),
-                               string("recv_") + (*f_iter)->get_name(),
-                               &noargs);
-      // Open function
-      f_service_ <<
-        endl <<
-        indent() << "def " << function_signature(&recv_function) << endl;
-      indent_up();
-
-      // TODO(mcslee): Validate message reply here, seq ids etc.
-
-      f_service_ <<
-        indent() << "result = receive_message(" << resultname << ")" << endl;
-
-      // Careful, only return _result if not a void function
-      if (!(*f_iter)->get_returntype()->is_void()) {
-        f_service_ <<
-          indent() << "return result.success unless result.success.nil?" << endl;
-      }
-
-      t_struct* xs = (*f_iter)->get_xceptions();
-      const std::vector<t_field*>& xceptions = xs->get_members();
-      vector<t_field*>::const_iterator x_iter;
-      for (x_iter = xceptions.begin(); x_iter != xceptions.end(); ++x_iter) {
-        indent(f_service_) <<
-          "raise result." << (*x_iter)->get_name() <<
-            " unless result." << (*x_iter)->get_name() << ".nil?" << endl;
-      }
-
-      // Careful, only return _result if not a void function
-      if ((*f_iter)->get_returntype()->is_void()) {
-        indent(f_service_) <<
-          "return" << endl;
-      } else {
-        f_service_ <<
-          indent() << "raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, '" << (*f_iter)->get_name() << " failed: unknown result')" << endl;
-      }
-
-      // Close function
-      indent_down();
-      indent(f_service_) << "end" << endl << endl;
-    }
-  }
-
-  indent_down();
-  indent(f_service_) << "end" << endl << endl;
-}
-
-/**
- * Generates a service server definition.
- *
- * @param tservice The service to generate a server for.
- */
-void t_rb_generator::generate_service_server(t_service* tservice) {
-  // Generate the dispatch methods
-  vector<t_function*> functions = tservice->get_functions();
-  vector<t_function*>::iterator f_iter;
-
-  string extends = "";
-  string extends_processor = "";
-  if (tservice->get_extends() != NULL) {
-    extends = full_type_name(tservice->get_extends());
-    extends_processor = " < " + extends + "::Processor ";
-  }
-
-  // Generate the header portion
-  indent(f_service_) <<
-    "class Processor" << extends_processor << endl;
-  indent_up();
-
-  f_service_ <<
-    indent() << "include ::Thrift::Processor" << endl <<
-    endl;
-
-  // Generate the process subfunctions
-  for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
-    generate_process_function(tservice, *f_iter);
-  }
-
-  indent_down();
-  indent(f_service_) << "end" << endl << endl;
-}
-
-/**
- * Generates a process function definition.
- *
- * @param tfunction The function to write a dispatcher for
- */
-void t_rb_generator::generate_process_function(t_service* tservice,
-                                               t_function* tfunction) {
-  (void) tservice;
-  // Open function
-  indent(f_service_) <<
-    "def process_" << tfunction->get_name() <<
-    "(seqid, iprot, oprot)" << endl;
-  indent_up();
-
-  string argsname = capitalize(tfunction->get_name()) + "_args";
-  string resultname = capitalize(tfunction->get_name()) + "_result";
-
-  f_service_ <<
-    indent() << "args = read_args(iprot, " << argsname << ")" << endl;
-
-  t_struct* xs = tfunction->get_xceptions();
-  const std::vector<t_field*>& xceptions = xs->get_members();
-  vector<t_field*>::const_iterator x_iter;
-
-  // Declare result for non oneway function
-  if (!tfunction->is_oneway()) {
-    f_service_ <<
-      indent() << "result = " << resultname << ".new()" << endl;
-  }
-
-  // Try block for a function with exceptions
-  if (xceptions.size() > 0) {
-    f_service_ <<
-      indent() << "begin" << endl;
-    indent_up();
-  }
-
-  // Generate the function call
-  t_struct* arg_struct = tfunction->get_arglist();
-  const std::vector<t_field*>& fields = arg_struct->get_members();
-  vector<t_field*>::const_iterator f_iter;
-
-  f_service_ << indent();
-  if (!tfunction->is_oneway() && !tfunction->get_returntype()->is_void()) {
-    f_service_ << "result.success = ";
-  }
-  f_service_ <<
-    "@handler." << tfunction->get_name() << "(";
-  bool first = true;
-  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
-    if (first) {
-      first = false;
-    } else {
-      f_service_ << ", ";
-    }
-    f_service_ << "args." << (*f_iter)->get_name();
-  }
-  f_service_ << ")" << endl;
-
-  if (!tfunction->is_oneway() && xceptions.size() > 0) {
-    indent_down();
-    for (x_iter = xceptions.begin(); x_iter != xceptions.end(); ++x_iter) {
-      f_service_ <<
-        indent() << "rescue " << full_type_name((*x_iter)->get_type()) << " => " << (*x_iter)->get_name() << endl;
-      if (!tfunction->is_oneway()) {
-        indent_up();
-        f_service_ <<
-          indent() << "result." << (*x_iter)->get_name() << " = " << (*x_iter)->get_name() << endl;
-        indent_down();
-      }
-    }
-    indent(f_service_) << "end" << endl;
-  }
-
-  // Shortcut out here for oneway functions
-  if (tfunction->is_oneway()) {
-    f_service_ <<
-      indent() << "return" << endl;
-    indent_down();
-    indent(f_service_) << "end" << endl << endl;
-    return;
-  }
-
-  f_service_ <<
-    indent() << "write_result(result, oprot, '" << tfunction->get_name() << "', seqid)" << endl;
-
-  // Close function
-  indent_down();
-  indent(f_service_) << "end" << endl << endl;
-}
-
-/**
- * Renders a function signature of the form 'type name(args)'
- *
- * @param tfunction Function definition
- * @return String of rendered function definition
- */
-string t_rb_generator::function_signature(t_function* tfunction,
-                                           string prefix) {
-  // TODO(mcslee): Nitpicky, no ',' if argument_list is empty
-  return
-    prefix + tfunction->get_name() +
-    "(" +  argument_list(tfunction->get_arglist()) + ")";
-}
-
-/**
- * Renders a field list
- */
-string t_rb_generator::argument_list(t_struct* tstruct) {
-  string result = "";
-
-  const vector<t_field*>& fields = tstruct->get_members();
-  vector<t_field*>::const_iterator f_iter;
-  bool first = true;
-  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
-    if (first) {
-      first = false;
-    } else {
-      result += ", ";
-    }
-    result += (*f_iter)->get_name();
-  }
-  return result;
-}
-
-string t_rb_generator::type_name(t_type* ttype) {
-  string prefix = "";
-
-  string name = ttype->get_name();
-  if (ttype->is_struct() || ttype->is_xception() || ttype->is_enum()) {
-    name = capitalize(ttype->get_name());
-  }
-
-  return prefix + name;
-}
-
-string t_rb_generator::full_type_name(t_type* ttype) {
-  string prefix = "";
-  vector<std::string> modules = ruby_modules(ttype->get_program());
-  for (vector<std::string>::iterator m_iter = modules.begin();
-       m_iter != modules.end(); ++m_iter) {
-    prefix += *m_iter + "::";
-  }
-  return prefix + type_name(ttype);
-}
-
-/**
- * Converts the parse type to a Ruby tyoe
- */
-string t_rb_generator::type_to_enum(t_type* type) {
-  type = get_true_type(type);
-
-  if (type->is_base_type()) {
-    t_base_type::t_base tbase = ((t_base_type*)type)->get_base();
-    switch (tbase) {
-    case t_base_type::TYPE_VOID:
-      throw "NO T_VOID CONSTRUCT";
-    case t_base_type::TYPE_STRING:
-      return "::Thrift::Types::STRING";
-    case t_base_type::TYPE_BOOL:
-      return "::Thrift::Types::BOOL";
-    case t_base_type::TYPE_BYTE:
-      return "::Thrift::Types::BYTE";
-    case t_base_type::TYPE_I16:
-      return "::Thrift::Types::I16";
-    case t_base_type::TYPE_I32:
-      return "::Thrift::Types::I32";
-    case t_base_type::TYPE_I64:
-      return "::Thrift::Types::I64";
-    case t_base_type::TYPE_DOUBLE:
-      return "::Thrift::Types::DOUBLE";
-    }
-  } else if (type->is_enum()) {
-    return "::Thrift::Types::I32";
-  } else if (type->is_struct() || type->is_xception()) {
-    return "::Thrift::Types::STRUCT";
-  } else if (type->is_map()) {
-    return "::Thrift::Types::MAP";
-  } else if (type->is_set()) {
-    return "::Thrift::Types::SET";
-  } else if (type->is_list()) {
-    return "::Thrift::Types::LIST";
-  }
-
-  throw "INVALID TYPE IN type_to_enum: " + type->get_name();
-}
-
-
-void t_rb_generator::generate_rdoc(std::ofstream& out, t_doc* tdoc) {
-  if (tdoc->has_doc()) {
-    generate_docstring_comment(out,
-      "", "# ", tdoc->get_doc(), "");
-  }
-}
-
-void t_rb_generator::generate_rb_struct_required_validator(std::ofstream& out, 
-                                                           t_struct* tstruct) {
-  indent(out) << "def validate" << endl;
-  indent_up();
-
-  const vector<t_field*>& fields = tstruct->get_members();
-  vector<t_field*>::const_iterator f_iter;
-
-  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
-    t_field* field = (*f_iter);
-    if (field->get_req() == t_field::T_REQUIRED) {
-      indent(out) << "raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field " << field->get_name() << " is unset!')";
-      if (field->get_type()->is_bool()) {
-        out << " if @" << field->get_name() << ".nil?";
-      } else {
-        out << " unless @" << field->get_name();
-      }
-      out << endl;
-    }
-  }
-
-  // if field is an enum, check that its value is valid
-  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
-    t_field* field = (*f_iter);
-
-    if (field->get_type()->is_enum()){      
-      indent(out) << "unless @" << field->get_name() << ".nil? || " << full_type_name(field->get_type()) << "::VALID_VALUES.include?(@" << field->get_name() << ")" << endl;
-      indent_up();
-      indent(out) << "raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field " << field->get_name() << "!')" << endl;  
-      indent_down();
-      indent(out) << "end" << endl;
-    }
-  }
-
-  indent_down();
-  indent(out) << "end" << endl << endl;
-}
-
-void t_rb_generator::generate_rb_union_validator(std::ofstream& out, 
-                                                 t_struct* tstruct) {
-  indent(out) << "def validate" << endl;
-  indent_up();
-
-  const vector<t_field*>& fields = tstruct->get_members();
-  vector<t_field*>::const_iterator f_iter;
-
-  indent(out) << "raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?" << endl;
-
-  // if field is an enum, check that its value is valid
-  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
-    const t_field* field = (*f_iter);
-
-    if (field->get_type()->is_enum()){      
-      indent(out) << "if get_set_field == :" << field->get_name() << endl;
-      indent(out) << "  raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field " << field->get_name() << "!') unless " << full_type_name(field->get_type()) << "::VALID_VALUES.include?(get_value)" << endl;  
-      indent(out) << "end" << endl;
-    }
-  }
-
-  indent_down();
-  indent(out) << "end" << endl << endl;
-}
-
-THRIFT_REGISTER_GENERATOR(rb, "Ruby", "")
-
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ * Contains some contributions under the Thrift Software License.
+ * Please see doc/old-thrift-license.txt in the Thrift distribution for
+ * details.
+ */
+
+#include <string>
+#include <fstream>
+#include <iostream>
+#include <vector>
+#include <algorithm>
+
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sstream>
+
+#include "t_oop_generator.h"
+#include "platform.h"
+#include "version.h"
+
+using namespace std;
+
+
+/**
+ * Ruby code generator.
+ *
+ */
+class t_rb_generator : public t_oop_generator {
+ public:
+  t_rb_generator(
+      t_program* program,
+      const std::map<std::string, std::string>& parsed_options,
+      const std::string& option_string)
+    : t_oop_generator(program)
+  {
+    (void) parsed_options;
+    (void) option_string;
+    out_dir_base_ = "gen-rb";
+  }
+
+  /**
+   * Init and close methods
+   */
+
+  void init_generator();
+  void close_generator();
+
+  /**
+   * Program-level generation functions
+   */
+
+  void generate_typedef     (t_typedef*  ttypedef);
+  void generate_enum        (t_enum*     tenum);
+  void generate_const       (t_const*    tconst);
+  void generate_struct      (t_struct*   tstruct);
+  void generate_union        (t_struct*   tunion);
+  void generate_xception    (t_struct*   txception);
+  void generate_service     (t_service*  tservice);
+
+  std::string render_const_value(t_type* type, t_const_value* value);
+
+  /**
+   * Struct generation code
+   */
+
+  void generate_rb_struct(std::ofstream& out, t_struct* tstruct, bool is_exception);
+  void generate_rb_struct_required_validator(std::ofstream& out, t_struct* tstruct);
+  void generate_rb_union(std::ofstream& out, t_struct* tstruct, bool is_exception);
+  void generate_rb_union_validator(std::ofstream& out, t_struct* tstruct);
+  void generate_rb_function_helpers(t_function* tfunction);
+  void generate_rb_simple_constructor(std::ofstream& out, t_struct* tstruct);
+  void generate_rb_simple_exception_constructor(std::ofstream& out, t_struct* tstruct);
+  void generate_field_constants (std::ofstream& out, t_struct* tstruct);
+  void generate_field_constructors (std::ofstream& out, t_struct* tstruct);
+  void generate_field_defns (std::ofstream& out, t_struct* tstruct);
+  void generate_field_data  (std::ofstream& out, t_type* field_type, const std::string& field_name, t_const_value* field_value, bool optional);
+
+  /**
+   * Service-level generation functions
+   */
+
+  void generate_service_helpers   (t_service*  tservice);
+  void generate_service_interface (t_service* tservice);
+  void generate_service_client    (t_service* tservice);
+  void generate_service_server    (t_service* tservice);
+  void generate_process_function  (t_service* tservice, t_function* tfunction);
+
+  /**
+   * Serialization constructs
+   */
+
+  void generate_deserialize_field        (std::ofstream &out,
+                                          t_field*    tfield,
+                                          std::string prefix="",
+                                          bool inclass=false);
+
+  void generate_deserialize_struct       (std::ofstream &out,
+                                          t_struct*   tstruct,
+                                          std::string prefix="");
+
+  void generate_deserialize_container    (std::ofstream &out,
+                                          t_type*     ttype,
+                                          std::string prefix="");
+
+  void generate_deserialize_set_element  (std::ofstream &out,
+                                          t_set*      tset,
+                                          std::string prefix="");
+
+  void generate_deserialize_map_element  (std::ofstream &out,
+                                          t_map*      tmap,
+                                          std::string prefix="");
+
+  void generate_deserialize_list_element (std::ofstream &out,
+                                          t_list*     tlist,
+                                          std::string prefix="");
+
+  void generate_serialize_field          (std::ofstream &out,
+                                          t_field*    tfield,
+                                          std::string prefix="");
+
+  void generate_serialize_struct         (std::ofstream &out,
+                                          t_struct*   tstruct,
+                                          std::string prefix="");
+
+  void generate_serialize_container      (std::ofstream &out,
+                                          t_type*     ttype,
+                                          std::string prefix="");
+
+  void generate_serialize_map_element    (std::ofstream &out,
+                                          t_map*      tmap,
+                                          std::string kiter,
+                                          std::string viter);
+
+  void generate_serialize_set_element    (std::ofstream &out,
+                                          t_set*      tmap,
+                                          std::string iter);
+
+  void generate_serialize_list_element   (std::ofstream &out,
+                                          t_list*     tlist,
+                                          std::string iter);
+
+  void generate_rdoc                     (std::ofstream& out, 
+                                          t_doc* tdoc);
+
+  /**
+   * Helper rendering functions
+   */
+
+  std::string rb_autogen_comment();
+  std::string render_includes();
+  std::string declare_field(t_field* tfield);
+  std::string type_name(t_type* ttype);
+  std::string full_type_name(t_type* ttype);
+  std::string function_signature(t_function* tfunction, std::string prefix="");
+  std::string argument_list(t_struct* tstruct);
+  std::string type_to_enum(t_type* ttype);
+
+
+
+  std::vector<std::string> ruby_modules(t_program* p) {
+    std::string ns = p->get_namespace("rb");
+    std::vector<std::string> modules;
+    if (ns.empty()) {
+      return modules;
+    }
+
+    std::string::iterator pos = ns.begin();
+    while (true) {
+      std::string::iterator delim = std::find(pos, ns.end(), '.');
+      modules.push_back(capitalize(std::string(pos, delim)));
+      pos = delim;
+      if (pos == ns.end()) {
+        break;
+      }
+      ++pos;
+    }
+
+    return modules;
+  }
+
+  void begin_namespace(std::ofstream&, std::vector<std::string>);
+  void end_namespace(std::ofstream&, std::vector<std::string>);
+
+ private:
+
+  /**
+   * File streams
+   */
+
+  std::ofstream f_types_;
+  std::ofstream f_consts_;
+  std::ofstream f_service_;
+
+};
+
+
+/**
+ * Prepares for file generation by opening up the necessary file output
+ * streams.
+ *
+ * @param tprogram The program to generate
+ */
+void t_rb_generator::init_generator() {
+  // Make output directory
+  MKDIR(get_out_dir().c_str());
+
+  // Make output file
+  string f_types_name = get_out_dir()+underscore(program_name_)+"_types.rb";
+  f_types_.open(f_types_name.c_str());
+
+  string f_consts_name = get_out_dir()+underscore(program_name_)+"_constants.rb";
+  f_consts_.open(f_consts_name.c_str());
+
+  // Print header
+  f_types_ <<
+    rb_autogen_comment() << endl <<
+    render_includes() << endl;
+    begin_namespace(f_types_, ruby_modules(program_));
+
+  f_consts_ <<
+    rb_autogen_comment() << endl <<
+    "require '" << underscore(program_name_) << "_types'" << endl <<
+    endl;
+    begin_namespace(f_consts_, ruby_modules(program_));
+
+}
+
+/**
+ * Renders all the imports necessary for including another Thrift program
+ */
+string t_rb_generator::render_includes() {
+  const vector<t_program*>& includes = program_->get_includes();
+  string result = "";
+  for (size_t i = 0; i < includes.size(); ++i) {
+    result += "require '" + underscore(includes[i]->get_name()) + "_types'\n";
+  }
+  if (includes.size() > 0) {
+    result += "\n";
+  }
+  return result;
+}
+
+/**
+ * Autogen'd comment
+ */
+string t_rb_generator::rb_autogen_comment() {
+  return
+    std::string("#\n") +
+    "# Autogenerated by Thrift Compiler (" + THRIFT_VERSION + ")\n" +
+    "#\n" +
+    "# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n" +
+    "#\n";
+}
+
+/**
+ * Closes the type files
+ */
+void t_rb_generator::close_generator() {
+  // Close types file
+  end_namespace(f_types_, ruby_modules(program_));
+  end_namespace(f_consts_, ruby_modules(program_));
+  f_types_.close();
+  f_consts_.close();
+}
+
+/**
+ * Generates a typedef. This is not done in Ruby, types are all implicit.
+ *
+ * @param ttypedef The type definition
+ */
+void t_rb_generator::generate_typedef(t_typedef* ttypedef) {
+  (void) ttypedef;
+}
+
+/**
+ * Generates code for an enumerated type. Done using a class to scope
+ * the values.
+ *
+ * @param tenum The enumeration
+ */
+void t_rb_generator::generate_enum(t_enum* tenum) {
+  indent(f_types_) <<
+    "module " << capitalize(tenum->get_name()) << endl;
+  indent_up();
+
+  vector<t_enum_value*> constants = tenum->get_constants();
+  vector<t_enum_value*>::iterator c_iter;
+  for (c_iter = constants.begin(); c_iter != constants.end(); ++c_iter) {
+    int value = (*c_iter)->get_value();
+
+    // Ruby class constants have to be capitalized... omg i am so on the fence
+    // about languages strictly enforcing capitalization why can't we just all
+    // agree and play nice.
+    string name = capitalize((*c_iter)->get_name());
+
+    generate_rdoc(f_types_, *c_iter);
+    indent(f_types_) << name << " = " << value << endl;
+  }
+  
+  // Create a hash mapping values back to their names (as strings) since ruby has no native enum type
+  indent(f_types_) << "VALUE_MAP = {";
+  bool first = true;
+  for(c_iter = constants.begin(); c_iter != constants.end(); ++c_iter) {
+    // Populate the hash
+    int value = (*c_iter)->get_value();
+    first ? first = false : static_cast<bool>(f_types_ << ", ");
+    f_types_ << value << " => \"" << capitalize((*c_iter)->get_name()) << "\"";
+  }
+  f_types_ << "}" << endl;
+  
+  // Create a set with valid values for this enum
+  indent(f_types_) << "VALID_VALUES = Set.new([";
+  first = true;
+  for (c_iter = constants.begin(); c_iter != constants.end(); ++c_iter) {
+    // Populate the set
+    first ? first = false : static_cast<bool>(f_types_ << ", ");
+    f_types_ << capitalize((*c_iter)->get_name());
+  }
+  f_types_ << "]).freeze" << endl;
+
+  indent_down();
+  indent(f_types_) <<
+    "end" << endl << endl;
+}
+
+/**
+ * Generate a constant value
+ */
+void t_rb_generator::generate_const(t_const* tconst) {
+  t_type* type = tconst->get_type();
+  string name = tconst->get_name();
+  t_const_value* value = tconst->get_value();
+
+  name[0] = toupper(name[0]);
+
+  indent(f_consts_) << name << " = " << render_const_value(type, value);
+  f_consts_ << endl << endl;
+}
+
+/**
+ * Prints the value of a constant with the given type. Note that type checking
+ * is NOT performed in this function as it is always run beforehand using the
+ * validate_types method in main.cc
+ */
+string t_rb_generator::render_const_value(t_type* type, t_const_value* value) {
+  type = get_true_type(type);
+  std::ostringstream out;
+  if (type->is_base_type()) {
+    t_base_type::t_base tbase = ((t_base_type*)type)->get_base();
+    switch (tbase) {
+    case t_base_type::TYPE_STRING:
+      out << "%q\"" << get_escaped_string(value) << '"';
+      break;
+    case t_base_type::TYPE_BOOL:
+      out << (value->get_integer() > 0 ? "true" : "false");
+      break;
+    case t_base_type::TYPE_BYTE:
+    case t_base_type::TYPE_I16:
+    case t_base_type::TYPE_I32:
+    case t_base_type::TYPE_I64:
+      out << value->get_integer();
+      break;
+    case t_base_type::TYPE_DOUBLE:
+      if (value->get_type() == t_const_value::CV_INTEGER) {
+        out << value->get_integer();
+      } else {
+        out << value->get_double();
+      }
+      break;
+    default:
+      throw "compiler error: no const of base type " + t_base_type::t_base_name(tbase);
+    }
+  } else if (type->is_enum()) {
+    indent(out) << value->get_integer();
+  } else if (type->is_struct() || type->is_xception()) {
+    out << full_type_name(type) << ".new({" << endl;
+    indent_up();
+    const vector<t_field*>& fields = ((t_struct*)type)->get_members();
+    vector<t_field*>::const_iterator f_iter;
+    const map<t_const_value*, t_const_value*>& val = value->get_map();
+    map<t_const_value*, t_const_value*>::const_iterator v_iter;
+    for (v_iter = val.begin(); v_iter != val.end(); ++v_iter) {
+      t_type* field_type = NULL;
+      for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
+        if ((*f_iter)->get_name() == v_iter->first->get_string()) {
+          field_type = (*f_iter)->get_type();
+        }
+      }
+      if (field_type == NULL) {
+        throw "type error: " + type->get_name() + " has no field " + v_iter->first->get_string();
+      }
+      out << indent();
+      out << render_const_value(g_type_string, v_iter->first);
+      out << " => ";
+      out << render_const_value(field_type, v_iter->second);
+      out << "," << endl;
+    }
+    indent_down();
+    indent(out) << "})";
+  } else if (type->is_map()) {
+    t_type* ktype = ((t_map*)type)->get_key_type();
+    t_type* vtype = ((t_map*)type)->get_val_type();
+    out << "{" << endl;
+    indent_up();
+    const map<t_const_value*, t_const_value*>& val = value->get_map();
+    map<t_const_value*, t_const_value*>::const_iterator v_iter;
+    for (v_iter = val.begin(); v_iter != val.end(); ++v_iter) {
+      out << indent();
+      out << render_const_value(ktype, v_iter->first);
+      out << " => ";
+      out << render_const_value(vtype, v_iter->second);
+      out << "," << endl;
+    }
+    indent_down();
+    indent(out) << "}";
+  } else if (type->is_list() || type->is_set()) {
+    t_type* etype;
+    if (type->is_list()) {
+      etype = ((t_list*)type)->get_elem_type();
+    } else {
+      etype = ((t_set*)type)->get_elem_type();
+    }
+    if (type->is_set()) {
+      out << "Set.new([" << endl;
+    } else {
+      out << "[" << endl;
+    }
+    indent_up();
+    const vector<t_const_value*>& val = value->get_list();
+    vector<t_const_value*>::const_iterator v_iter;
+    for (v_iter = val.begin(); v_iter != val.end(); ++v_iter) {
+      out << indent();
+      out << render_const_value(etype, *v_iter);
+      out << "," << endl;
+    }
+    indent_down();
+    if (type->is_set()) {
+      indent(out) << "])";
+    } else {
+      indent(out) << "]";
+    }
+  } else {
+    throw "CANNOT GENERATE CONSTANT FOR TYPE: " + type->get_name();
+  }
+  return out.str();
+}
+
+/**
+ * Generates a ruby struct
+ */
+void t_rb_generator::generate_struct(t_struct* tstruct) {
+  if (tstruct->is_union()) {
+    generate_rb_union(f_types_, tstruct, false);
+  } else {
+    generate_rb_struct(f_types_, tstruct, false);
+  }
+}
+
+/**
+ * Generates a struct definition for a thrift exception. Basically the same
+ * as a struct but extends the Exception class.
+ *
+ * @param txception The struct definition
+ */
+void t_rb_generator::generate_xception(t_struct* txception) {
+  generate_rb_struct(f_types_, txception, true);
+}
+
+/**
+ * Generates a ruby struct
+ */
+void t_rb_generator::generate_rb_struct(std::ofstream& out, t_struct* tstruct, bool is_exception = false) {
+  generate_rdoc(out, tstruct);
+  indent(out) << "class " << type_name(tstruct);
+  if (is_exception) {
+    out << " < ::Thrift::Exception";
+  }
+  out << endl;
+
+  indent_up();
+  indent(out) << "include ::Thrift::Struct, ::Thrift::Struct_Union" << endl;
+
+  if (is_exception) {
+    generate_rb_simple_exception_constructor(out, tstruct);
+  }
+
+  generate_field_constants(out, tstruct);
+  generate_field_defns(out, tstruct);
+  generate_rb_struct_required_validator(out, tstruct);
+
+  indent(out) << "::Thrift::Struct.generate_accessors self" << endl;
+
+  indent_down();
+  indent(out) << "end" << endl << endl;
+}
+
+
+/**
+ * Generates a ruby union
+ */
+void t_rb_generator::generate_rb_union(std::ofstream& out, t_struct* tstruct, bool is_exception = false) {
+  (void) is_exception;
+  generate_rdoc(out, tstruct);
+  indent(out) << "class " << type_name(tstruct) << " < ::Thrift::Union" << endl;
+
+  indent_up();
+  indent(out) << "include ::Thrift::Struct_Union" << endl;
+
+  generate_field_constructors(out, tstruct);
+
+  generate_field_constants(out, tstruct);
+  generate_field_defns(out, tstruct);
+  generate_rb_union_validator(out, tstruct);
+
+  indent(out) << "::Thrift::Union.generate_accessors self" << endl;
+
+  indent_down();
+  indent(out) << "end" << endl << endl;
+}
+
+void t_rb_generator::generate_field_constructors(std::ofstream& out, t_struct* tstruct) {
+
+  indent(out) << "class << self" << endl;
+  indent_up();
+
+  const vector<t_field*>& fields = tstruct->get_members();
+  vector<t_field*>::const_iterator f_iter;
+
+  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
+    if (f_iter != fields.begin()) {
+      out << endl;
+    }
+    std::string field_name = (*f_iter)->get_name();
+
+    indent(out) << "def " << field_name << "(val)" << endl;
+    indent(out) << "  " << tstruct->get_name() << ".new(:" << field_name << ", val)" << endl;
+    indent(out) << "end" << endl;
+  }
+  
+  indent_down();
+  indent(out) << "end" << endl;
+
+  out << endl;
+}
+
+void t_rb_generator::generate_rb_simple_exception_constructor(std::ofstream& out, t_struct* tstruct) {
+  const vector<t_field*>& members = tstruct->get_members();
+
+  if (members.size() == 1) {
+    vector<t_field*>::const_iterator m_iter = members.begin();
+
+    if ((*m_iter)->get_type()->is_string()) {
+      string name = (*m_iter)->get_name();
+
+      indent(out) << "def initialize(message=nil)" << endl;
+      indent_up();
+      indent(out) << "super()" << endl;
+      indent(out) << "self." << name << " = message" << endl;
+      indent_down();
+      indent(out) << "end" << endl << endl;
+
+      if (name != "message") {
+        indent(out) << "def message; " << name << " end" << endl << endl;
+      }
+    }
+  }
+}
+
+void t_rb_generator::generate_field_constants(std::ofstream& out, t_struct* tstruct) {
+  const vector<t_field*>& fields = tstruct->get_members();
+  vector<t_field*>::const_iterator f_iter;
+
+  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
+    std::string field_name = (*f_iter)->get_name();
+    std::string cap_field_name = upcase_string(field_name);
+    
+    indent(out) << cap_field_name << " = " << (*f_iter)->get_key() << endl;
+  }
+  out << endl;
+}
+
+void t_rb_generator::generate_field_defns(std::ofstream& out, t_struct* tstruct) {
+  const vector<t_field*>& fields = tstruct->get_members();
+  vector<t_field*>::const_iterator f_iter;
+
+  indent(out) << "FIELDS = {" << endl;
+  indent_up();
+  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
+    if (f_iter != fields.begin()) {
+      out << "," << endl;
+    }
+
+    // generate the field docstrings within the FIELDS constant. no real better place...
+    generate_rdoc(out, *f_iter);
+
+    indent(out) <<
+      upcase_string((*f_iter)->get_name()) << " => ";
+
+    generate_field_data(out, (*f_iter)->get_type(), (*f_iter)->get_name(), (*f_iter)->get_value(), 
+      (*f_iter)->get_req() == t_field::T_OPTIONAL);
+  }
+  indent_down();
+  out << endl;
+  indent(out) << "}" << endl << endl;
+  
+  indent(out) << "def struct_fields; FIELDS; end" << endl << endl;
+  
+}
+
+void t_rb_generator::generate_field_data(std::ofstream& out, t_type* field_type,
+    const std::string& field_name = "", t_const_value* field_value = NULL, bool optional = false) {
+  field_type = get_true_type(field_type);
+
+  // Begin this field's defn
+  out << "{:type => " << type_to_enum(field_type);
+
+  if (!field_name.empty()) {
+    out << ", :name => '" << field_name << "'";
+  }
+
+  if (field_value != NULL) {
+    out << ", :default => " << render_const_value(field_type, field_value);
+  }
+
+  if (!field_type->is_base_type()) {
+    if (field_type->is_struct() || field_type->is_xception()) {
+      out << ", :class => " << full_type_name((t_struct*)field_type);
+    } else if (field_type->is_list()) {
+      out << ", :element => ";
+      generate_field_data(out, ((t_list*)field_type)->get_elem_type());
+    } else if (field_type->is_map()) {
+      out << ", :key => ";
+      generate_field_data(out, ((t_map*)field_type)->get_key_type());
+      out << ", :value => ";
+      generate_field_data(out, ((t_map*)field_type)->get_val_type());
+    } else if (field_type->is_set()) {
+      out << ", :element => ";
+      generate_field_data(out, ((t_set*)field_type)->get_elem_type());
+    }
+  } else {
+    if (((t_base_type*)field_type)->is_binary()) {
+      out << ", :binary => true";
+    }
+  }
+  
+  if(optional) {
+    out << ", :optional => true";
+  }
+
+  if (field_type->is_enum()) {
+    out << ", :enum_class => " << full_type_name(field_type);
+  }
+
+  // End of this field's defn
+  out << "}";
+}
+
+void t_rb_generator::begin_namespace(std::ofstream& out, vector<std::string> modules) {
+  for (vector<std::string>::iterator m_iter = modules.begin(); m_iter != modules.end(); ++m_iter) {
+    indent(out) << "module " << *m_iter << endl;
+    indent_up();
+  }
+}
+
+void t_rb_generator::end_namespace(std::ofstream& out, vector<std::string> modules) {
+  for (vector<std::string>::reverse_iterator m_iter = modules.rbegin(); m_iter != modules.rend(); ++m_iter) {
+    indent_down();
+    indent(out) << "end" << endl;
+  }
+}
+
+
+/**
+ * Generates a thrift service.
+ *
+ * @param tservice The service definition
+ */
+void t_rb_generator::generate_service(t_service* tservice) {
+  string f_service_name = get_out_dir()+underscore(service_name_)+".rb";
+  f_service_.open(f_service_name.c_str());
+
+  f_service_ <<
+    rb_autogen_comment() << endl <<
+    "require 'thrift'" << endl;
+
+  if (tservice->get_extends() != NULL) {
+    f_service_ <<
+      "require '" << underscore(tservice->get_extends()->get_name()) << "'" << endl;
+  }
+
+  f_service_ <<
+    "require '" << underscore(program_name_) << "_types'" << endl <<
+    endl;
+
+  begin_namespace(f_service_, ruby_modules(tservice->get_program()));
+
+  indent(f_service_) << "module " << capitalize(tservice->get_name()) << endl;
+  indent_up();
+
+  // Generate the three main parts of the service (well, two for now in PHP)
+  generate_service_client(tservice);
+  generate_service_server(tservice);
+  generate_service_helpers(tservice);
+
+  indent_down();
+  indent(f_service_) << "end" << endl <<
+    endl;
+
+  end_namespace(f_service_, ruby_modules(tservice->get_program()));
+
+  // Close service file
+  f_service_.close();
+}
+
+/**
+ * Generates helper functions for a service.
+ *
+ * @param tservice The service to generate a header definition for
+ */
+void t_rb_generator::generate_service_helpers(t_service* tservice) {
+  vector<t_function*> functions = tservice->get_functions();
+  vector<t_function*>::iterator f_iter;
+
+  indent(f_service_) <<
+    "# HELPER FUNCTIONS AND STRUCTURES" << endl << endl;
+
+  for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
+    t_struct* ts = (*f_iter)->get_arglist();
+    generate_rb_struct(f_service_, ts);
+    generate_rb_function_helpers(*f_iter);
+  }
+}
+
+/**
+ * Generates a struct and helpers for a function.
+ *
+ * @param tfunction The function
+ */
+void t_rb_generator::generate_rb_function_helpers(t_function* tfunction) {
+  t_struct result(program_, tfunction->get_name() + "_result");
+  t_field success(tfunction->get_returntype(), "success", 0);
+  if (!tfunction->get_returntype()->is_void()) {
+    result.append(&success);
+  }
+
+  t_struct* xs = tfunction->get_xceptions();
+  const vector<t_field*>& fields = xs->get_members();
+  vector<t_field*>::const_iterator f_iter;
+  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
+    result.append(*f_iter);
+  }
+  generate_rb_struct(f_service_, &result);
+}
+
+/**
+ * Generates a service client definition.
+ *
+ * @param tservice The service to generate a server for.
+ */
+void t_rb_generator::generate_service_client(t_service* tservice) {
+  string extends = "";
+  string extends_client = "";
+  if (tservice->get_extends() != NULL) {
+    extends = full_type_name(tservice->get_extends());
+    extends_client = " < " + extends + "::Client ";
+  }
+
+  indent(f_service_) <<
+    "class Client" << extends_client << endl;
+  indent_up();
+
+  indent(f_service_) <<
+    "include ::Thrift::Client" << endl << endl;
+
+  // Generate client method implementations
+  vector<t_function*> functions = tservice->get_functions();
+  vector<t_function*>::const_iterator f_iter;
+  for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
+    t_struct* arg_struct = (*f_iter)->get_arglist();
+    const vector<t_field*>& fields = arg_struct->get_members();
+    vector<t_field*>::const_iterator fld_iter;
+    string funname = (*f_iter)->get_name();
+
+    // Open function
+    indent(f_service_) <<
+      "def " << function_signature(*f_iter) << endl;
+    indent_up();
+      indent(f_service_) <<
+        "send_" << funname << "(";
+
+      bool first = true;
+      for (fld_iter = fields.begin(); fld_iter != fields.end(); ++fld_iter) {
+        if (first) {
+          first = false;
+        } else {
+          f_service_ << ", ";
+        }
+        f_service_ << (*fld_iter)->get_name();
+      }
+      f_service_ << ")" << endl;
+
+      if (!(*f_iter)->is_oneway()) {
+        f_service_ << indent();
+        if (!(*f_iter)->get_returntype()->is_void()) {
+          f_service_ << "return ";
+        }
+        f_service_ <<
+          "recv_" << funname << "()" << endl;
+      }
+    indent_down();
+    indent(f_service_) << "end" << endl;
+    f_service_ << endl;
+
+    indent(f_service_) <<
+      "def send_" << function_signature(*f_iter) << endl;
+    indent_up();
+
+      std::string argsname = capitalize((*f_iter)->get_name() + "_args");
+
+      indent(f_service_) << "send_message('" << funname << "', " << argsname;
+
+      for (fld_iter = fields.begin(); fld_iter != fields.end(); ++fld_iter) {
+        f_service_ << ", :" << (*fld_iter)->get_name() << " => " << (*fld_iter)->get_name();
+      }
+
+      f_service_ << ")" << endl;
+
+    indent_down();
+    indent(f_service_) << "end" << endl;
+
+    if (!(*f_iter)->is_oneway()) {
+      std::string resultname = capitalize((*f_iter)->get_name() + "_result");
+      t_struct noargs(program_);
+
+      t_function recv_function((*f_iter)->get_returntype(),
+                               string("recv_") + (*f_iter)->get_name(),
+                               &noargs);
+      // Open function
+      f_service_ <<
+        endl <<
+        indent() << "def " << function_signature(&recv_function) << endl;
+      indent_up();
+
+      // TODO(mcslee): Validate message reply here, seq ids etc.
+
+      f_service_ <<
+        indent() << "result = receive_message(" << resultname << ")" << endl;
+
+      // Careful, only return _result if not a void function
+      if (!(*f_iter)->get_returntype()->is_void()) {
+        f_service_ <<
+          indent() << "return result.success unless result.success.nil?" << endl;
+      }
+
+      t_struct* xs = (*f_iter)->get_xceptions();
+      const std::vector<t_field*>& xceptions = xs->get_members();
+      vector<t_field*>::const_iterator x_iter;
+      for (x_iter = xceptions.begin(); x_iter != xceptions.end(); ++x_iter) {
+        indent(f_service_) <<
+          "raise result." << (*x_iter)->get_name() <<
+            " unless result." << (*x_iter)->get_name() << ".nil?" << endl;
+      }
+
+      // Careful, only return _result if not a void function
+      if ((*f_iter)->get_returntype()->is_void()) {
+        indent(f_service_) <<
+          "return" << endl;
+      } else {
+        f_service_ <<
+          indent() << "raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, '" << (*f_iter)->get_name() << " failed: unknown result')" << endl;
+      }
+
+      // Close function
+      indent_down();
+      indent(f_service_) << "end" << endl << endl;
+    }
+  }
+
+  indent_down();
+  indent(f_service_) << "end" << endl << endl;
+}
+
+/**
+ * Generates a service server definition.
+ *
+ * @param tservice The service to generate a server for.
+ */
+void t_rb_generator::generate_service_server(t_service* tservice) {
+  // Generate the dispatch methods
+  vector<t_function*> functions = tservice->get_functions();
+  vector<t_function*>::iterator f_iter;
+
+  string extends = "";
+  string extends_processor = "";
+  if (tservice->get_extends() != NULL) {
+    extends = full_type_name(tservice->get_extends());
+    extends_processor = " < " + extends + "::Processor ";
+  }
+
+  // Generate the header portion
+  indent(f_service_) <<
+    "class Processor" << extends_processor << endl;
+  indent_up();
+
+  f_service_ <<
+    indent() << "include ::Thrift::Processor" << endl <<
+    endl;
+
+  // Generate the process subfunctions
+  for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
+    generate_process_function(tservice, *f_iter);
+  }
+
+  indent_down();
+  indent(f_service_) << "end" << endl << endl;
+}
+
+/**
+ * Generates a process function definition.
+ *
+ * @param tfunction The function to write a dispatcher for
+ */
+void t_rb_generator::generate_process_function(t_service* tservice,
+                                               t_function* tfunction) {
+  (void) tservice;
+  // Open function
+  indent(f_service_) <<
+    "def process_" << tfunction->get_name() <<
+    "(seqid, iprot, oprot)" << endl;
+  indent_up();
+
+  string argsname = capitalize(tfunction->get_name()) + "_args";
+  string resultname = capitalize(tfunction->get_name()) + "_result";
+
+  f_service_ <<
+    indent() << "args = read_args(iprot, " << argsname << ")" << endl;
+
+  t_struct* xs = tfunction->get_xceptions();
+  const std::vector<t_field*>& xceptions = xs->get_members();
+  vector<t_field*>::const_iterator x_iter;
+
+  // Declare result for non oneway function
+  if (!tfunction->is_oneway()) {
+    f_service_ <<
+      indent() << "result = " << resultname << ".new()" << endl;
+  }
+
+  // Try block for a function with exceptions
+  if (xceptions.size() > 0) {
+    f_service_ <<
+      indent() << "begin" << endl;
+    indent_up();
+  }
+
+  // Generate the function call
+  t_struct* arg_struct = tfunction->get_arglist();
+  const std::vector<t_field*>& fields = arg_struct->get_members();
+  vector<t_field*>::const_iterator f_iter;
+
+  f_service_ << indent();
+  if (!tfunction->is_oneway() && !tfunction->get_returntype()->is_void()) {
+    f_service_ << "result.success = ";
+  }
+  f_service_ <<
+    "@handler." << tfunction->get_name() << "(";
+  bool first = true;
+  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
+    if (first) {
+      first = false;
+    } else {
+      f_service_ << ", ";
+    }
+    f_service_ << "args." << (*f_iter)->get_name();
+  }
+  f_service_ << ")" << endl;
+
+  if (!tfunction->is_oneway() && xceptions.size() > 0) {
+    indent_down();
+    for (x_iter = xceptions.begin(); x_iter != xceptions.end(); ++x_iter) {
+      f_service_ <<
+        indent() << "rescue " << full_type_name((*x_iter)->get_type()) << " => " << (*x_iter)->get_name() << endl;
+      if (!tfunction->is_oneway()) {
+        indent_up();
+        f_service_ <<
+          indent() << "result." << (*x_iter)->get_name() << " = " << (*x_iter)->get_name() << endl;
+        indent_down();
+      }
+    }
+    indent(f_service_) << "end" << endl;
+  }
+
+  // Shortcut out here for oneway functions
+  if (tfunction->is_oneway()) {
+    f_service_ <<
+      indent() << "return" << endl;
+    indent_down();
+    indent(f_service_) << "end" << endl << endl;
+    return;
+  }
+
+  f_service_ <<
+    indent() << "write_result(result, oprot, '" << tfunction->get_name() << "', seqid)" << endl;
+
+  // Close function
+  indent_down();
+  indent(f_service_) << "end" << endl << endl;
+}
+
+/**
+ * Renders a function signature of the form 'type name(args)'
+ *
+ * @param tfunction Function definition
+ * @return String of rendered function definition
+ */
+string t_rb_generator::function_signature(t_function* tfunction,
+                                           string prefix) {
+  // TODO(mcslee): Nitpicky, no ',' if argument_list is empty
+  return
+    prefix + tfunction->get_name() +
+    "(" +  argument_list(tfunction->get_arglist()) + ")";
+}
+
+/**
+ * Renders a field list
+ */
+string t_rb_generator::argument_list(t_struct* tstruct) {
+  string result = "";
+
+  const vector<t_field*>& fields = tstruct->get_members();
+  vector<t_field*>::const_iterator f_iter;
+  bool first = true;
+  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
+    if (first) {
+      first = false;
+    } else {
+      result += ", ";
+    }
+    result += (*f_iter)->get_name();
+  }
+  return result;
+}
+
+string t_rb_generator::type_name(t_type* ttype) {
+  string prefix = "";
+
+  string name = ttype->get_name();
+  if (ttype->is_struct() || ttype->is_xception() || ttype->is_enum()) {
+    name = capitalize(ttype->get_name());
+  }
+
+  return prefix + name;
+}
+
+string t_rb_generator::full_type_name(t_type* ttype) {
+  string prefix = "";
+  vector<std::string> modules = ruby_modules(ttype->get_program());
+  for (vector<std::string>::iterator m_iter = modules.begin();
+       m_iter != modules.end(); ++m_iter) {
+    prefix += *m_iter + "::";
+  }
+  return prefix + type_name(ttype);
+}
+
+/**
+ * Converts the parse type to a Ruby tyoe
+ */
+string t_rb_generator::type_to_enum(t_type* type) {
+  type = get_true_type(type);
+
+  if (type->is_base_type()) {
+    t_base_type::t_base tbase = ((t_base_type*)type)->get_base();
+    switch (tbase) {
+    case t_base_type::TYPE_VOID:
+      throw "NO T_VOID CONSTRUCT";
+    case t_base_type::TYPE_STRING:
+      return "::Thrift::Types::STRING";
+    case t_base_type::TYPE_BOOL:
+      return "::Thrift::Types::BOOL";
+    case t_base_type::TYPE_BYTE:
+      return "::Thrift::Types::BYTE";
+    case t_base_type::TYPE_I16:
+      return "::Thrift::Types::I16";
+    case t_base_type::TYPE_I32:
+      return "::Thrift::Types::I32";
+    case t_base_type::TYPE_I64:
+      return "::Thrift::Types::I64";
+    case t_base_type::TYPE_DOUBLE:
+      return "::Thrift::Types::DOUBLE";
+    }
+  } else if (type->is_enum()) {
+    return "::Thrift::Types::I32";
+  } else if (type->is_struct() || type->is_xception()) {
+    return "::Thrift::Types::STRUCT";
+  } else if (type->is_map()) {
+    return "::Thrift::Types::MAP";
+  } else if (type->is_set()) {
+    return "::Thrift::Types::SET";
+  } else if (type->is_list()) {
+    return "::Thrift::Types::LIST";
+  }
+
+  throw "INVALID TYPE IN type_to_enum: " + type->get_name();
+}
+
+
+void t_rb_generator::generate_rdoc(std::ofstream& out, t_doc* tdoc) {
+  if (tdoc->has_doc()) {
+    generate_docstring_comment(out,
+      "", "# ", tdoc->get_doc(), "");
+  }
+}
+
+void t_rb_generator::generate_rb_struct_required_validator(std::ofstream& out, 
+                                                           t_struct* tstruct) {
+  indent(out) << "def validate" << endl;
+  indent_up();
+
+  const vector<t_field*>& fields = tstruct->get_members();
+  vector<t_field*>::const_iterator f_iter;
+
+  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
+    t_field* field = (*f_iter);
+    if (field->get_req() == t_field::T_REQUIRED) {
+      indent(out) << "raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field " << field->get_name() << " is unset!')";
+      if (field->get_type()->is_bool()) {
+        out << " if @" << field->get_name() << ".nil?";
+      } else {
+        out << " unless @" << field->get_name();
+      }
+      out << endl;
+    }
+  }
+
+  // if field is an enum, check that its value is valid
+  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
+    t_field* field = (*f_iter);
+
+    if (field->get_type()->is_enum()){      
+      indent(out) << "unless @" << field->get_name() << ".nil? || " << full_type_name(field->get_type()) << "::VALID_VALUES.include?(@" << field->get_name() << ")" << endl;
+      indent_up();
+      indent(out) << "raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field " << field->get_name() << "!')" << endl;  
+      indent_down();
+      indent(out) << "end" << endl;
+    }
+  }
+
+  indent_down();
+  indent(out) << "end" << endl << endl;
+}
+
+void t_rb_generator::generate_rb_union_validator(std::ofstream& out, 
+                                                 t_struct* tstruct) {
+  indent(out) << "def validate" << endl;
+  indent_up();
+
+  const vector<t_field*>& fields = tstruct->get_members();
+  vector<t_field*>::const_iterator f_iter;
+
+  indent(out) << "raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?" << endl;
+
+  // if field is an enum, check that its value is valid
+  for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
+    const t_field* field = (*f_iter);
+
+    if (field->get_type()->is_enum()){      
+      indent(out) << "if get_set_field == :" << field->get_name() << endl;
+      indent(out) << "  raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field " << field->get_name() << "!') unless " << full_type_name(field->get_type()) << "::VALID_VALUES.include?(get_value)" << endl;  
+      indent(out) << "end" << endl;
+    }
+  }
+
+  indent_down();
+  indent(out) << "end" << endl << endl;
+}
+
+THRIFT_REGISTER_GENERATOR(rb, "Ruby", "")
+
--- lib/cpp/src/transport/TFileTransport.cpp	Sat Nov 26 11:00:42 2011
+++ lib/cpp/src/transport/TFileTransport.cpp	Thu Nov 30 14:26:50 2017
@@ -1,1122 +1,1122 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements. See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership. The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include "TFileTransport.h"
-#include "TTransportUtils.h"
-
-#ifdef HAVE_PTHREAD_H
-#include <pthread.h>
-#endif
-#ifdef HAVE_SYS_TIME_H
-#include <sys/time.h>
-#else
-#include <time.h>
-#endif
-#include <fcntl.h>
-#include <errno.h>
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#ifdef HAVE_STRINGS_H
-#include <strings.h>
-#endif
-#include <cstdlib>
-#include <cstring>
-#include <iostream>
-#ifdef HAVE_SYS_STAT_H
-#include <sys/stat.h>
-#endif
-
-#ifdef _WIN32
-#include <io.h>
-#endif
-
-namespace apache { namespace thrift { namespace transport {
-
-using boost::scoped_ptr;
-using boost::shared_ptr;
-using namespace std;
-using namespace apache::thrift::protocol;
-using namespace apache::thrift::concurrency;
-
-#ifndef HAVE_CLOCK_GETTIME
-
-/**
- * Fake clock_gettime for systems like darwin
- *
- */
-#define CLOCK_REALTIME 0
-static int clock_gettime(int clk_id /*ignored*/, struct timespec *tp) {
-  struct timeval now;
-
-  int rv = gettimeofday(&now, NULL);
-  if (rv != 0) {
-    return rv;
-  }
-
-  tp->tv_sec = now.tv_sec;
-  tp->tv_nsec = now.tv_usec * 1000;
-  return 0;
-}
-#endif
-
-TFileTransport::TFileTransport(string path, bool readOnly)
-  : readState_()
-  , readBuff_(NULL)
-  , currentEvent_(NULL)
-  , readBuffSize_(DEFAULT_READ_BUFF_SIZE)
-  , readTimeout_(NO_TAIL_READ_TIMEOUT)
-  , chunkSize_(DEFAULT_CHUNK_SIZE)
-  , eventBufferSize_(DEFAULT_EVENT_BUFFER_SIZE)
-  , flushMaxUs_(DEFAULT_FLUSH_MAX_US)
-  , flushMaxBytes_(DEFAULT_FLUSH_MAX_BYTES)
-  , maxEventSize_(DEFAULT_MAX_EVENT_SIZE)
-  , maxCorruptedEvents_(DEFAULT_MAX_CORRUPTED_EVENTS)
-  , eofSleepTime_(DEFAULT_EOF_SLEEP_TIME_US)
-  , corruptedEventSleepTime_(DEFAULT_CORRUPTED_SLEEP_TIME_US)
-  , writerThreadIOErrorSleepTime_(DEFAULT_WRITER_THREAD_SLEEP_TIME_US)
-  , writerThreadId_(0)
-  , dequeueBuffer_(NULL)
-  , enqueueBuffer_(NULL)
-  , notFull_(&mutex_)
-  , notEmpty_(&mutex_)
-  , closing_(false)
-  , flushed_(&mutex_)
-  , forceFlush_(false)
-  , filename_(path)
-  , fd_(0)
-  , bufferAndThreadInitialized_(false)
-  , offset_(0)
-  , lastBadChunk_(0)
-  , numCorruptedEventsInChunk_(0)
-  , readOnly_(readOnly)
-{
-  openLogFile();
-}
-
-void TFileTransport::resetOutputFile(int fd, string filename, int64_t offset) {
-  filename_ = filename;
-  offset_ = offset;
-
-  // check if current file is still open
-  if (fd_ > 0) {
-    // flush any events in the queue
-    flush();
-    GlobalOutput.printf("error, current file (%s) not closed", filename_.c_str());
-    if (-1 == ::close(fd_)) {
-      int errno_copy = errno;
-      GlobalOutput.perror("TFileTransport: resetOutputFile() ::close() ", errno_copy);
-      throw TTransportException(TTransportException::UNKNOWN, "TFileTransport: error in file close", errno_copy);
-    } else {
-      //successfully closed fd
-      fd_ = 0;
-    }
-  }
-
-  if (fd) {
-    fd_ = fd;
-  } else {
-    // open file if the input fd is 0
-    openLogFile();
-  }
-}
-
-
-TFileTransport::~TFileTransport() {
-  // flush the buffer if a writer thread is active
-#ifdef USE_BOOST_THREAD
-  if(writerThreadId_.get()) {
-#else
-  if (writerThreadId_ > 0) {
-#endif
-    // set state to closing
-    closing_ = true;
-
-    // wake up the writer thread
-    // Since closing_ is true, it will attempt to flush all data, then exit.
-	notEmpty_.notify();
-
-#ifdef USE_BOOST_THREAD
-    writerThreadId_->join();
-	writerThreadId_.reset();
-#else
-    pthread_join(writerThreadId_, NULL);
-    writerThreadId_ = 0;
-#endif
-  }
-
-  if (dequeueBuffer_) {
-    delete dequeueBuffer_;
-    dequeueBuffer_ = NULL;
-  }
-
-  if (enqueueBuffer_) {
-    delete enqueueBuffer_;
-    enqueueBuffer_ = NULL;
-  }
-
-  if (readBuff_) {
-    delete[] readBuff_;
-    readBuff_ = NULL;
-  }
-
-  if (currentEvent_) {
-    delete currentEvent_;
-    currentEvent_ = NULL;
-  }
-
-  // close logfile
-  if (fd_ > 0) {
-    if(-1 == ::close(fd_)) {
-      GlobalOutput.perror("TFileTransport: ~TFileTransport() ::close() ", errno);
-    } else {
-      //successfully closed fd
-      fd_ = 0;
-    }
-  }
-}
-
-bool TFileTransport::initBufferAndWriteThread() {
-  if (bufferAndThreadInitialized_) {
-    T_ERROR("%s", "Trying to double-init TFileTransport");
-    return false;
-  }
-
-#ifdef USE_BOOST_THREAD
-  if(!writerThreadId_.get()) {
-    writerThreadId_ = std::auto_ptr<boost::thread>(new boost::thread(boost::bind(startWriterThread, (void *)this)));
-  }
-#else
-  if (writerThreadId_ == 0) {
-    if (pthread_create(&writerThreadId_, NULL, startWriterThread, (void *)this) != 0) {
-      T_ERROR("%s", "Could not create writer thread");
-      return false;
-    }
-  }
-#endif
-
-  dequeueBuffer_ = new TFileTransportBuffer(eventBufferSize_);
-  enqueueBuffer_ = new TFileTransportBuffer(eventBufferSize_);
-  bufferAndThreadInitialized_ = true;
-
-  return true;
-}
-
-void TFileTransport::write(const uint8_t* buf, uint32_t len) {
-  if (readOnly_) {
-    throw TTransportException("TFileTransport: attempting to write to file opened readonly");
-  }
-
-  enqueueEvent(buf, len);
-}
-
-void TFileTransport::enqueueEvent(const uint8_t* buf, uint32_t eventLen) {
-  // can't enqueue more events if file is going to close
-  if (closing_) {
-    return;
-  }
-
-  // make sure that event size is valid
-  if ( (maxEventSize_ > 0) && (eventLen > maxEventSize_) ) {
-    T_ERROR("msg size is greater than max event size: %u > %u\n", eventLen, maxEventSize_);
-    return;
-  }
-
-  if (eventLen == 0) {
-    T_ERROR("%s", "cannot enqueue an empty event");
-    return;
-  }
-
-  eventInfo* toEnqueue = new eventInfo();
-  toEnqueue->eventBuff_ = (uint8_t *)std::malloc((sizeof(uint8_t) * eventLen) + 4);
-  if (toEnqueue->eventBuff_ == NULL) {
-    delete toEnqueue;
-    throw std::bad_alloc();
-  }
-  // first 4 bytes is the event length
-  memcpy(toEnqueue->eventBuff_, (void*)(&eventLen), 4);
-  // actual event contents
-  memcpy(toEnqueue->eventBuff_ + 4, buf, eventLen);
-  toEnqueue->eventSize_ = eventLen + 4;
-
-  // lock mutex
-  Guard g(mutex_);
-
-  // make sure that enqueue buffer is initialized and writer thread is running
-  if (!bufferAndThreadInitialized_) {
-    if (!initBufferAndWriteThread()) {
-      delete toEnqueue;
-      return;
-    }
-  }
-
-  // Can't enqueue while buffer is full
-  while (enqueueBuffer_->isFull()) {
-	  notFull_.wait();
-  }
-
-  // We shouldn't be trying to enqueue new data while a forced flush is
-  // requested.  (Otherwise the writer thread might not ever be able to finish
-  // the flush if more data keeps being enqueued.)
-  assert(!forceFlush_);
-
-  // add to the buffer
-  if (!enqueueBuffer_->addEvent(toEnqueue)) {
-    delete toEnqueue;
-    return;
-  }
-
-  // signal anybody who's waiting for the buffer to be non-empty
-  notEmpty_.notify();
-
-  // this really should be a loop where it makes sure it got flushed
-  // because condition variables can get triggered by the os for no reason
-  // it is probably a non-factor for the time being
-}
-
-bool TFileTransport::swapEventBuffers(struct timespec* deadline) {
-  bool swap;
-  Guard g(mutex_);
-
-  if (!enqueueBuffer_->isEmpty()) {
-    swap = true;
-  } else if (closing_) {
-    // even though there is no data to write,
-    // return immediately if the transport is closing
-    swap = false;
-  } else {
-    if (deadline != NULL) {
-      // if we were handed a deadline time struct, do a timed wait
-      notEmpty_.waitForTime(deadline);
-    } else {
-      // just wait until the buffer gets an item
-      notEmpty_.wait();
-    }
-
-    // could be empty if we timed out
-    swap = enqueueBuffer_->isEmpty();
-  }
-
-  if (swap) {
-    TFileTransportBuffer *temp = enqueueBuffer_;
-    enqueueBuffer_ = dequeueBuffer_;
-    dequeueBuffer_ = temp;
-  }
-
-
-  if (swap) {
-	  notFull_.notify();
-  }
-
-  return swap;
-}
-
-
-void TFileTransport::writerThread() {
-  bool hasIOError = false;
-
-  // open file if it is not open
-  if(!fd_) {
-    try {
-      openLogFile();
-    } catch (...) {
-      int errno_copy = errno;
-      GlobalOutput.perror("TFileTransport: writerThread() openLogFile() ", errno_copy);
-      fd_ = 0;
-      hasIOError = true;
-    }
-  }
-
-  // set the offset to the correct value (EOF)
-  if (!hasIOError) {
-    try {
-      seekToEnd();
-      // throw away any partial events
-      offset_ += readState_.lastDispatchPtr_;
-#ifndef _WIN32
-      ftruncate(fd_, offset_);
-#else
-      _chsize_s(fd_, offset_);
-#endif
-      readState_.resetAllValues();
-    } catch (...) {
-      int errno_copy = errno;
-      GlobalOutput.perror("TFileTransport: writerThread() initialization ", errno_copy);
-      hasIOError = true;
-    }
-  }
-
-  // Figure out the next time by which a flush must take place
-  struct timespec ts_next_flush;
-  getNextFlushTime(&ts_next_flush);
-  uint32_t unflushed = 0;
-
-  while (1) {
-    // this will only be true when the destructor is being invoked
-    if (closing_) {
-      if (hasIOError) {
-#ifndef USE_BOOST_THREAD
-		  pthread_exit(NULL);
-#else
-		  return;
-#endif
-      }
-
-      // Try to empty buffers before exit
-      if (enqueueBuffer_->isEmpty() && dequeueBuffer_->isEmpty()) {
-#ifndef _WIN32
-        fsync(fd_);
-#endif
-        if (-1 == ::close(fd_)) {
-          int errno_copy = errno;
-          GlobalOutput.perror("TFileTransport: writerThread() ::close() ", errno_copy);
-        } else {
-          //fd successfully closed
-          fd_ = 0;
-        }
-#ifndef USE_BOOST_THREAD
-        pthread_exit(NULL);
-#else
-        return;
-#endif
-	  }
-    }
-
-    if (swapEventBuffers(&ts_next_flush)) {
-      eventInfo* outEvent;
-      while (NULL != (outEvent = dequeueBuffer_->getNext())) {
-        // Remove an event from the buffer and write it out to disk. If there is any IO error, for instance,
-        // the output file is unmounted or deleted, then this event is dropped. However, the writer thread
-        // will: (1) sleep for a short while; (2) try to reopen the file; (3) if successful then start writing
-        // from the end.
-
-        while (hasIOError) {
-          T_ERROR("TFileTransport: writer thread going to sleep for %d microseconds due to IO errors", writerThreadIOErrorSleepTime_);
-          usleep(writerThreadIOErrorSleepTime_);
-          if (closing_) {
-#ifndef USE_BOOST_THREAD
-            pthread_exit(NULL);
-#else
-            return;
-#endif
-          }
-          if (!fd_) {
-            ::close(fd_);
-            fd_ = 0;
-          }
-          try {
-            openLogFile();
-            seekToEnd();
-            unflushed = 0;
-            hasIOError = false;
-            T_LOG_OPER("TFileTransport: log file %s reopened by writer thread during error recovery", filename_.c_str());
-          } catch (...) {
-            T_ERROR("TFileTransport: unable to reopen log file %s during error recovery", filename_.c_str());
-          }
-        }
-
-        // sanity check on event
-        if ((maxEventSize_ > 0) && (outEvent->eventSize_ > maxEventSize_)) {
-          T_ERROR("msg size is greater than max event size: %u > %u\n", outEvent->eventSize_, maxEventSize_);
-          continue;
-        }
-
-        // If chunking is required, then make sure that msg does not cross chunk boundary
-        if ((outEvent->eventSize_ > 0) && (chunkSize_ != 0)) {
-          // event size must be less than chunk size
-          if (outEvent->eventSize_ > chunkSize_) {
-            T_ERROR("TFileTransport: event size(%u) > chunk size(%u): skipping event", outEvent->eventSize_, chunkSize_);
-            continue;
-          }
-
-          int64_t chunk1 = offset_/chunkSize_;
-          int64_t chunk2 = (offset_ + outEvent->eventSize_ - 1)/chunkSize_;
-
-          // if adding this event will cross a chunk boundary, pad the chunk with zeros
-          if (chunk1 != chunk2) {
-            // refetch the offset to keep in sync
-            offset_ = lseek(fd_, 0, SEEK_CUR);
-            int32_t padding = (int32_t)((offset_ / chunkSize_ + 1) * chunkSize_ - offset_);
-
-            uint8_t* zeros = new uint8_t[padding];
-            memset(zeros, '\0', padding);
-            boost::scoped_array<uint8_t> array(zeros);
-            if (-1 == ::write(fd_, zeros, padding)) {
-              int errno_copy = errno;
-              GlobalOutput.perror("TFileTransport: writerThread() error while padding zeros ", errno_copy);
-              hasIOError = true;
-              continue;
-            }
-            unflushed += padding;
-            offset_ += padding;
-          }
-        }
-
-        // write the dequeued event to the file
-        if (outEvent->eventSize_ > 0) {
-          if (-1 == ::write(fd_, outEvent->eventBuff_, outEvent->eventSize_)) {
-            int errno_copy = errno;
-            GlobalOutput.perror("TFileTransport: error while writing event ", errno_copy);
-            hasIOError = true;
-            continue;
-          }
-          unflushed += outEvent->eventSize_;
-          offset_ += outEvent->eventSize_;
-        }
-      }
-      dequeueBuffer_->reset();
-    }
-
-    if (hasIOError) {
-      continue;
-    }
-
-    // Local variable to cache the state of forceFlush_.
-    //
-    // We only want to check the value of forceFlush_ once each time around the
-    // loop.  If we check it more than once without holding the lock the entire
-    // time, it could have changed state in between.  This will result in us
-    // making inconsistent decisions.
-    bool forced_flush = false;
-	{
-    Guard g(mutex_);
-    if (forceFlush_) {
-      if (!enqueueBuffer_->isEmpty()) {
-        // If forceFlush_ is true, we need to flush all available data.
-        // If enqueueBuffer_ is not empty, go back to the start of the loop to
-        // write it out.
-        //
-        // We know the main thread is waiting on forceFlush_ to be cleared,
-        // so no new events will be added to enqueueBuffer_ until we clear
-        // forceFlush_.  Therefore the next time around the loop enqueueBuffer_
-        // is guaranteed to be empty.  (I.e., we're guaranteed to make progress
-        // and clear forceFlush_ the next time around the loop.)
-        continue;
-      }
-      forced_flush = true;
-	}
-	}
-
-    // determine if we need to perform an fsync
-    bool flush = false;
-    if (forced_flush || unflushed > flushMaxBytes_) {
-      flush = true;
-    } else {
-      struct timespec current_time;
-      clock_gettime(CLOCK_REALTIME, &current_time);
-      if (current_time.tv_sec > ts_next_flush.tv_sec ||
-          (current_time.tv_sec == ts_next_flush.tv_sec &&
-           current_time.tv_nsec > ts_next_flush.tv_nsec)) {
-        if (unflushed > 0) {
-          flush = true;
-        } else {
-          // If there is no new data since the last fsync,
-          // don't perform the fsync, but do reset the timer.
-          getNextFlushTime(&ts_next_flush);
-        }
-      }
-    }
-
-    if (flush) {
-      // sync (force flush) file to disk
-#ifndef _WIN32
-      fsync(fd_);
-#endif
-      unflushed = 0;
-      getNextFlushTime(&ts_next_flush);
-
-      // notify anybody waiting for flush completion
-      if (forced_flush) {
-        Guard g(mutex_);
-        forceFlush_ = false;
-        assert(enqueueBuffer_->isEmpty());
-        assert(dequeueBuffer_->isEmpty());
-		flushed_.notifyAll();
-      }
-    }
-  }
-}
-
-void TFileTransport::flush() {
-  // file must be open for writing for any flushing to take place
-#ifdef USE_BOOST_THREAD
-  if (!writerThreadId_.get()) {
-    return;
-  }
-#else
-  if (writerThreadId_ <= 0) {
-    return;
-  }
-#endif
-  // wait for flush to take place
-  Guard g(mutex_);
-
-  // Indicate that we are requesting a flush
-  forceFlush_ = true;
-  // Wake up the writer thread so it will perform the flush immediately
-  notEmpty_.notify();
-
-  while (forceFlush_) {
-    flushed_.wait();
-  }
-}
-
-
-uint32_t TFileTransport::readAll(uint8_t* buf, uint32_t len) {
-  uint32_t have = 0;
-  uint32_t get = 0;
-
-  while (have < len) {
-    get = read(buf+have, len-have);
-    if (get <= 0) {
-      throw TEOFException();
-    }
-    have += get;
-  }
-
-  return have;
-}
-
-bool TFileTransport::peek() {
-  // check if there is an event ready to be read
-  if (!currentEvent_) {
-    currentEvent_ = readEvent();
-  }
-
-  // did not manage to read an event from the file. This could have happened
-  // if the timeout expired or there was some other error
-  if (!currentEvent_) {
-    return false;
-  }
-
-  // check if there is anything to read
-  return (currentEvent_->eventSize_ - currentEvent_->eventBuffPos_) > 0;
-}
-
-uint32_t TFileTransport::read(uint8_t* buf, uint32_t len) {
-  // check if there an event is ready to be read
-  if (!currentEvent_) {
-    currentEvent_ = readEvent();
-  }
-
-  // did not manage to read an event from the file. This could have happened
-  // if the timeout expired or there was some other error
-  if (!currentEvent_) {
-    return 0;
-  }
-
-  // read as much of the current event as possible
-  int32_t remaining = currentEvent_->eventSize_ - currentEvent_->eventBuffPos_;
-  if (remaining <= (int32_t)len) {
-    // copy over anything thats remaining
-    if (remaining > 0) {
-      memcpy(buf,
-             currentEvent_->eventBuff_ + currentEvent_->eventBuffPos_,
-             remaining);
-    }
-    delete(currentEvent_);
-    currentEvent_ = NULL;
-    return remaining;
-  }
-
-  // read as much as possible
-  memcpy(buf, currentEvent_->eventBuff_ + currentEvent_->eventBuffPos_, len);
-  currentEvent_->eventBuffPos_ += len;
-  return len;
-}
-
-// note caller is responsible for freeing returned events
-eventInfo* TFileTransport::readEvent() {
-  int readTries = 0;
-
-  if (!readBuff_) {
-    readBuff_ = new uint8_t[readBuffSize_];
-  }
-
-  while (1) {
-    // read from the file if read buffer is exhausted
-    if (readState_.bufferPtr_ == readState_.bufferLen_) {
-      // advance the offset pointer
-      offset_ += readState_.bufferLen_;
-      readState_.bufferLen_ = ::read(fd_, readBuff_, readBuffSize_);
-      //       if (readState_.bufferLen_) {
-      //         T_DEBUG_L(1, "Amount read: %u (offset: %lu)", readState_.bufferLen_, offset_);
-      //       }
-      readState_.bufferPtr_ = 0;
-      readState_.lastDispatchPtr_ = 0;
-
-      // read error
-      if (readState_.bufferLen_ == -1) {
-        readState_.resetAllValues();
-        GlobalOutput("TFileTransport: error while reading from file");
-        throw TTransportException("TFileTransport: error while reading from file");
-      } else if (readState_.bufferLen_ == 0) {  // EOF
-        // wait indefinitely if there is no timeout
-        if (readTimeout_ == TAIL_READ_TIMEOUT) {
-          usleep(eofSleepTime_);
-          continue;
-        } else if (readTimeout_ == NO_TAIL_READ_TIMEOUT) {
-          // reset state
-          readState_.resetState(0);
-          return NULL;
-        } else if (readTimeout_ > 0) {
-          // timeout already expired once
-          if (readTries > 0) {
-            readState_.resetState(0);
-            return NULL;
-          } else {
-            usleep(readTimeout_ * 1000);
-            readTries++;
-            continue;
-          }
-        }
-      }
-    }
-
-    readTries = 0;
-
-    // attempt to read an event from the buffer
-    while(readState_.bufferPtr_ < readState_.bufferLen_) {
-      if (readState_.readingSize_) {
-        if(readState_.eventSizeBuffPos_ == 0) {
-          if ( (offset_ + readState_.bufferPtr_)/chunkSize_ !=
-               ((offset_ + readState_.bufferPtr_ + 3)/chunkSize_)) {
-            // skip one byte towards chunk boundary
-            //            T_DEBUG_L(1, "Skipping a byte");
-            readState_.bufferPtr_++;
-            continue;
-          }
-        }
-
-        readState_.eventSizeBuff_[readState_.eventSizeBuffPos_++] =
-          readBuff_[readState_.bufferPtr_++];
-        if (readState_.eventSizeBuffPos_ == 4) {
-          // 0 length event indicates padding
-          if (*((uint32_t *)(readState_.eventSizeBuff_)) == 0) {
-            //            T_DEBUG_L(1, "Got padding");
-            readState_.resetState(readState_.lastDispatchPtr_);
-            continue;
-          }
-          // got a valid event
-          readState_.readingSize_ = false;
-          if (readState_.event_) {
-            delete(readState_.event_);
-          }
-          readState_.event_ = new eventInfo();
-          readState_.event_->eventSize_ = *((uint32_t *)(readState_.eventSizeBuff_));
-
-          // check if the event is corrupted and perform recovery if required
-          if (isEventCorrupted()) {
-            performRecovery();
-            // start from the top
-            break;
-          }
-        }
-      } else {
-        if (!readState_.event_->eventBuff_) {
-          readState_.event_->eventBuff_ = new uint8_t[readState_.event_->eventSize_];
-          readState_.event_->eventBuffPos_ = 0;
-        }
-        // take either the entire event or the remaining bytes in the buffer
-        int reclaimBuffer = min((uint32_t)(readState_.bufferLen_ - readState_.bufferPtr_),
-                                readState_.event_->eventSize_ - readState_.event_->eventBuffPos_);
-
-        // copy data from read buffer into event buffer
-        memcpy(readState_.event_->eventBuff_ + readState_.event_->eventBuffPos_,
-               readBuff_ + readState_.bufferPtr_,
-               reclaimBuffer);
-
-        // increment position ptrs
-        readState_.event_->eventBuffPos_ += reclaimBuffer;
-        readState_.bufferPtr_ += reclaimBuffer;
-
-        // check if the event has been read in full
-        if (readState_.event_->eventBuffPos_ == readState_.event_->eventSize_) {
-          // set the completed event to the current event
-          eventInfo* completeEvent = readState_.event_;
-          completeEvent->eventBuffPos_ = 0;
-
-          readState_.event_ = NULL;
-          readState_.resetState(readState_.bufferPtr_);
-
-          // exit criteria
-          return completeEvent;
-        }
-      }
-    }
-
-  }
-}
-
-bool TFileTransport::isEventCorrupted() {
-  // an error is triggered if:
-  if ( (maxEventSize_ > 0) &&  (readState_.event_->eventSize_ > maxEventSize_)) {
-    // 1. Event size is larger than user-speficied max-event size
-    T_ERROR("Read corrupt event. Event size(%u) greater than max event size (%u)",
-            readState_.event_->eventSize_, maxEventSize_);
-    return true;
-  } else if (readState_.event_->eventSize_ > chunkSize_) {
-    // 2. Event size is larger than chunk size
-    T_ERROR("Read corrupt event. Event size(%u) greater than chunk size (%u)",
-               readState_.event_->eventSize_, chunkSize_);
-    return true;
-  } else if( ((offset_ + readState_.bufferPtr_ - 4)/chunkSize_) !=
-             ((offset_ + readState_.bufferPtr_ + readState_.event_->eventSize_ - 1)/chunkSize_) ) {
-    // 3. size indicates that event crosses chunk boundary
-    T_ERROR("Read corrupt event. Event crosses chunk boundary. Event size:%u  Offset:%lu",
-            readState_.event_->eventSize_,
-            (offset_ + readState_.bufferPtr_ + 4));
-
-    return true;
-  }
-
-  return false;
-}
-
-void TFileTransport::performRecovery() {
-  // perform some kickass recovery
-  uint32_t curChunk = getCurChunk();
-  if (lastBadChunk_ == curChunk) {
-    numCorruptedEventsInChunk_++;
-  } else {
-    lastBadChunk_ = curChunk;
-    numCorruptedEventsInChunk_ = 1;
-  }
-
-  if (numCorruptedEventsInChunk_ < maxCorruptedEvents_) {
-    // maybe there was an error in reading the file from disk
-    // seek to the beginning of chunk and try again
-    seekToChunk(curChunk);
-  } else {
-
-    // just skip ahead to the next chunk if we not already at the last chunk
-    if (curChunk != (getNumChunks() - 1)) {
-      seekToChunk(curChunk + 1);
-    } else if (readTimeout_ == TAIL_READ_TIMEOUT) {
-      // if tailing the file, wait until there is enough data to start
-      // the next chunk
-      while(curChunk == (getNumChunks() - 1)) {
-        usleep(DEFAULT_CORRUPTED_SLEEP_TIME_US);
-      }
-      seekToChunk(curChunk + 1);
-    } else {
-      // pretty hosed at this stage, rewind the file back to the last successful
-      // point and punt on the error
-      readState_.resetState(readState_.lastDispatchPtr_);
-      currentEvent_ = NULL;
-      char errorMsg[1024];
-      sprintf(errorMsg, "TFileTransport: log file corrupted at offset: %lu",
-              (offset_ + readState_.lastDispatchPtr_));
-              
-      GlobalOutput(errorMsg);
-      throw TTransportException(errorMsg);
-    }
-  }
-
-}
-
-void TFileTransport::seekToChunk(int32_t chunk) {
-  if (fd_ <= 0) {
-    throw TTransportException("File not open");
-  }
-
-  int32_t numChunks = getNumChunks();
-
-  // file is empty, seeking to chunk is pointless
-  if (numChunks == 0) {
-    return;
-  }
-
-  // negative indicates reverse seek (from the end)
-  if (chunk < 0) {
-    chunk += numChunks;
-  }
-
-  // too large a value for reverse seek, just seek to beginning
-  if (chunk < 0) {
-    T_DEBUG("%s", "Incorrect value for reverse seek. Seeking to beginning...");
-    chunk = 0;
-  }
-
-  // cannot seek past EOF
-  bool seekToEnd = false;
-  off_t minEndOffset = 0;
-  if (chunk >= numChunks) {
-    T_DEBUG("%s", "Trying to seek past EOF. Seeking to EOF instead...");
-    seekToEnd = true;
-    chunk = numChunks - 1;
-    // this is the min offset to process events till
-    minEndOffset = lseek(fd_, 0, SEEK_END);
-  }
-
-  off_t newOffset = off_t(chunk) * chunkSize_;
-  offset_ = lseek(fd_, newOffset, SEEK_SET);
-  readState_.resetAllValues();
-  currentEvent_ = NULL;
-  if (offset_ == -1) {
-    GlobalOutput("TFileTransport: lseek error in seekToChunk");
-    throw TTransportException("TFileTransport: lseek error in seekToChunk");
-  }
-
-  // seek to EOF if user wanted to go to last chunk
-  if (seekToEnd) {
-    uint32_t oldReadTimeout = getReadTimeout();
-    setReadTimeout(NO_TAIL_READ_TIMEOUT);
-    // keep on reading unti the last event at point of seekChunk call
-    boost::scoped_ptr<eventInfo> event;
-    while ((offset_ + readState_.bufferPtr_) < minEndOffset) {
-      event.reset(readEvent());
-      if (event.get() == NULL) {
-        break;
-      }
-    }
-    setReadTimeout(oldReadTimeout);
-  }
-
-}
-
-void TFileTransport::seekToEnd() {
-  seekToChunk(getNumChunks());
-}
-
-uint32_t TFileTransport::getNumChunks() {
-  if (fd_ <= 0) {
-    return 0;
-  }
-
-  struct stat f_info;
-  int rv = fstat(fd_, &f_info);
-
-  if (rv < 0) {
-    int errno_copy = errno;
-    throw TTransportException(TTransportException::UNKNOWN,
-                              "TFileTransport::getNumChunks() (fstat)",
-                              errno_copy);
-  }
-
-  if (f_info.st_size > 0) {
-    return ((f_info.st_size)/chunkSize_) + 1;
-  }
-
-  // empty file has no chunks
-  return 0;
-}
-
-uint32_t TFileTransport::getCurChunk() {
-  return offset_/chunkSize_;
-}
-
-// Utility Functions
-void TFileTransport::openLogFile() {
-#ifndef _WIN32
-  mode_t mode = readOnly_ ? S_IRUSR | S_IRGRP | S_IROTH : S_IRUSR | S_IWUSR| S_IRGRP | S_IROTH;
-  int flags = readOnly_ ? O_RDONLY : O_RDWR | O_CREAT | O_APPEND;
-  fd_ = ::open(filename_.c_str(), flags, mode);
-#else
-  int mode = readOnly_ ? _S_IREAD : _S_IREAD | _S_IWRITE;
-  int flags = readOnly_ ? _O_RDONLY : _O_RDWR | _O_CREAT | _O_APPEND;
-  fd_ = ::_open(filename_.c_str(), flags, mode);
-#endif
-  offset_ = 0;
-
-  // make sure open call was successful
-  if(fd_ == -1) {
-    int errno_copy = errno;
-    GlobalOutput.perror("TFileTransport: openLogFile() ::open() file: " + filename_, errno_copy);
-    throw TTransportException(TTransportException::NOT_OPEN, filename_, errno_copy);
-  }
-
-}
-
-void TFileTransport::getNextFlushTime(struct timespec* ts_next_flush) {
-  clock_gettime(CLOCK_REALTIME, ts_next_flush);
-  ts_next_flush->tv_nsec += (flushMaxUs_ % 1000000) * 1000;
-  if (ts_next_flush->tv_nsec > 1000000000) {
-    ts_next_flush->tv_nsec -= 1000000000;
-    ts_next_flush->tv_sec += 1;
-  }
-  ts_next_flush->tv_sec += flushMaxUs_ / 1000000;
-}
-
-TFileTransportBuffer::TFileTransportBuffer(uint32_t size)
-  : bufferMode_(WRITE)
-  , writePoint_(0)
-  , readPoint_(0)
-  , size_(size)
-{
-  buffer_ = new eventInfo*[size];
-}
-
-TFileTransportBuffer::~TFileTransportBuffer() {
-  if (buffer_) {
-    for (uint32_t i = 0; i < writePoint_; i++) {
-      delete buffer_[i];
-    }
-    delete[] buffer_;
-    buffer_ = NULL;
-  }
-}
-
-bool TFileTransportBuffer::addEvent(eventInfo *event) {
-  if (bufferMode_ == READ) {
-    GlobalOutput("Trying to write to a buffer in read mode");
-  }
-  if (writePoint_ < size_) {
-    buffer_[writePoint_++] = event;
-    return true;
-  } else {
-    // buffer is full
-    return false;
-  }
-}
-
-eventInfo* TFileTransportBuffer::getNext() {
-  if (bufferMode_ == WRITE) {
-    bufferMode_ = READ;
-  }
-  if (readPoint_ < writePoint_) {
-    return buffer_[readPoint_++];
-  } else {
-    // no more entries
-    return NULL;
-  }
-}
-
-void TFileTransportBuffer::reset() {
-  if (bufferMode_ == WRITE || writePoint_ > readPoint_) {
-    T_DEBUG("%s", "Resetting a buffer with unread entries");
-  }
-  // Clean up the old entries
-  for (uint32_t i = 0; i < writePoint_; i++) {
-    delete buffer_[i];
-  }
-  bufferMode_ = WRITE;
-  writePoint_ = 0;
-  readPoint_ = 0;
-}
-
-bool TFileTransportBuffer::isFull() {
-  return writePoint_ == size_;
-}
-
-bool TFileTransportBuffer::isEmpty() {
-  return writePoint_ == 0;
-}
-
-TFileProcessor::TFileProcessor(shared_ptr<TProcessor> processor,
-                               shared_ptr<TProtocolFactory> protocolFactory,
-                               shared_ptr<TFileReaderTransport> inputTransport):
-  processor_(processor),
-  inputProtocolFactory_(protocolFactory),
-  outputProtocolFactory_(protocolFactory),
-  inputTransport_(inputTransport) {
-
-  // default the output transport to a null transport (common case)
-  outputTransport_ = shared_ptr<TNullTransport>(new TNullTransport());
-}
-
-TFileProcessor::TFileProcessor(shared_ptr<TProcessor> processor,
-                               shared_ptr<TProtocolFactory> inputProtocolFactory,
-                               shared_ptr<TProtocolFactory> outputProtocolFactory,
-                               shared_ptr<TFileReaderTransport> inputTransport):
-  processor_(processor),
-  inputProtocolFactory_(inputProtocolFactory),
-  outputProtocolFactory_(outputProtocolFactory),
-  inputTransport_(inputTransport) {
-
-  // default the output transport to a null transport (common case)
-  outputTransport_ = shared_ptr<TNullTransport>(new TNullTransport());
-}
-
-TFileProcessor::TFileProcessor(shared_ptr<TProcessor> processor,
-                               shared_ptr<TProtocolFactory> protocolFactory,
-                               shared_ptr<TFileReaderTransport> inputTransport,
-                               shared_ptr<TTransport> outputTransport):
-  processor_(processor),
-  inputProtocolFactory_(protocolFactory),
-  outputProtocolFactory_(protocolFactory),
-  inputTransport_(inputTransport),
-  outputTransport_(outputTransport) {}
-
-void TFileProcessor::process(uint32_t numEvents, bool tail) {
-  shared_ptr<TProtocol> inputProtocol = inputProtocolFactory_->getProtocol(inputTransport_);
-  shared_ptr<TProtocol> outputProtocol = outputProtocolFactory_->getProtocol(outputTransport_);
-
-  // set the read timeout to 0 if tailing is required
-  int32_t oldReadTimeout = inputTransport_->getReadTimeout();
-  if (tail) {
-    // save old read timeout so it can be restored
-    inputTransport_->setReadTimeout(TFileTransport::TAIL_READ_TIMEOUT);
-  }
-
-  uint32_t numProcessed = 0;
-  while(1) {
-    // bad form to use exceptions for flow control but there is really
-    // no other way around it
-    try {
-      processor_->process(inputProtocol, outputProtocol, NULL);
-      numProcessed++;
-      if ( (numEvents > 0) && (numProcessed == numEvents)) {
-        return;
-      }
-    } catch (TEOFException& teof) {
-      if (!tail) {
-        break;
-      }
-    } catch (TException &te) {
-      cerr << te.what() << endl;
-      break;
-    }
-  }
-
-  // restore old read timeout
-  if (tail) {
-    inputTransport_->setReadTimeout(oldReadTimeout);
-  }
-
-}
-
-void TFileProcessor::processChunk() {
-  shared_ptr<TProtocol> inputProtocol = inputProtocolFactory_->getProtocol(inputTransport_);
-  shared_ptr<TProtocol> outputProtocol = outputProtocolFactory_->getProtocol(outputTransport_);
-
-  uint32_t curChunk = inputTransport_->getCurChunk();
-
-  while(1) {
-    // bad form to use exceptions for flow control but there is really
-    // no other way around it
-    try {
-      processor_->process(inputProtocol, outputProtocol, NULL);
-      if (curChunk != inputTransport_->getCurChunk()) {
-        break;
-      }
-    } catch (TEOFException& teof) {
-      break;
-    } catch (TException &te) {
-      cerr << te.what() << endl;
-      break;
-    }
-  }
-}
-
-}}} // apache::thrift::transport
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "TFileTransport.h"
+#include "TTransportUtils.h"
+
+#ifdef HAVE_PTHREAD_H
+#include <pthread.h>
+#endif
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#else
+#include <time.h>
+#endif
+#include <fcntl.h>
+#include <errno.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif
+#include <cstdlib>
+#include <cstring>
+#include <iostream>
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+
+#ifdef _WIN32
+#include <io.h>
+#endif
+
+namespace apache { namespace thrift { namespace transport {
+
+using boost::scoped_ptr;
+using boost::shared_ptr;
+using namespace std;
+using namespace apache::thrift::protocol;
+using namespace apache::thrift::concurrency;
+
+#ifndef HAVE_CLOCK_GETTIME
+
+/**
+ * Fake clock_gettime for systems like darwin
+ *
+ */
+#define CLOCK_REALTIME 0
+static int clock_gettime(int clk_id /*ignored*/, struct timespec *tp) {
+  struct timeval now;
+
+  int rv = gettimeofday(&now, NULL);
+  if (rv != 0) {
+    return rv;
+  }
+
+  tp->tv_sec = now.tv_sec;
+  tp->tv_nsec = now.tv_usec * 1000;
+  return 0;
+}
+#endif
+
+TFileTransport::TFileTransport(string path, bool readOnly)
+  : readState_()
+  , readBuff_(NULL)
+  , currentEvent_(NULL)
+  , readBuffSize_(DEFAULT_READ_BUFF_SIZE)
+  , readTimeout_(NO_TAIL_READ_TIMEOUT)
+  , chunkSize_(DEFAULT_CHUNK_SIZE)
+  , eventBufferSize_(DEFAULT_EVENT_BUFFER_SIZE)
+  , flushMaxUs_(DEFAULT_FLUSH_MAX_US)
+  , flushMaxBytes_(DEFAULT_FLUSH_MAX_BYTES)
+  , maxEventSize_(DEFAULT_MAX_EVENT_SIZE)
+  , maxCorruptedEvents_(DEFAULT_MAX_CORRUPTED_EVENTS)
+  , eofSleepTime_(DEFAULT_EOF_SLEEP_TIME_US)
+  , corruptedEventSleepTime_(DEFAULT_CORRUPTED_SLEEP_TIME_US)
+  , writerThreadIOErrorSleepTime_(DEFAULT_WRITER_THREAD_SLEEP_TIME_US)
+  , writerThreadId_(0)
+  , dequeueBuffer_(NULL)
+  , enqueueBuffer_(NULL)
+  , notFull_(&mutex_)
+  , notEmpty_(&mutex_)
+  , closing_(false)
+  , flushed_(&mutex_)
+  , forceFlush_(false)
+  , filename_(path)
+  , fd_(0)
+  , bufferAndThreadInitialized_(false)
+  , offset_(0)
+  , lastBadChunk_(0)
+  , numCorruptedEventsInChunk_(0)
+  , readOnly_(readOnly)
+{
+  openLogFile();
+}
+
+void TFileTransport::resetOutputFile(int fd, string filename, int64_t offset) {
+  filename_ = filename;
+  offset_ = offset;
+
+  // check if current file is still open
+  if (fd_ > 0) {
+    // flush any events in the queue
+    flush();
+    GlobalOutput.printf("error, current file (%s) not closed", filename_.c_str());
+    if (-1 == ::close(fd_)) {
+      int errno_copy = errno;
+      GlobalOutput.perror("TFileTransport: resetOutputFile() ::close() ", errno_copy);
+      throw TTransportException(TTransportException::UNKNOWN, "TFileTransport: error in file close", errno_copy);
+    } else {
+      //successfully closed fd
+      fd_ = 0;
+    }
+  }
+
+  if (fd) {
+    fd_ = fd;
+  } else {
+    // open file if the input fd is 0
+    openLogFile();
+  }
+}
+
+
+TFileTransport::~TFileTransport() {
+  // flush the buffer if a writer thread is active
+#ifdef USE_BOOST_THREAD
+  if(writerThreadId_.get()) {
+#else
+  if (writerThreadId_ > 0) {
+#endif
+    // set state to closing
+    closing_ = true;
+
+    // wake up the writer thread
+    // Since closing_ is true, it will attempt to flush all data, then exit.
+	notEmpty_.notify();
+
+#ifdef USE_BOOST_THREAD
+    writerThreadId_->join();
+	writerThreadId_.reset();
+#else
+    pthread_join(writerThreadId_, NULL);
+    writerThreadId_ = 0;
+#endif
+  }
+
+  if (dequeueBuffer_) {
+    delete dequeueBuffer_;
+    dequeueBuffer_ = NULL;
+  }
+
+  if (enqueueBuffer_) {
+    delete enqueueBuffer_;
+    enqueueBuffer_ = NULL;
+  }
+
+  if (readBuff_) {
+    delete[] readBuff_;
+    readBuff_ = NULL;
+  }
+
+  if (currentEvent_) {
+    delete currentEvent_;
+    currentEvent_ = NULL;
+  }
+
+  // close logfile
+  if (fd_ > 0) {
+    if(-1 == ::close(fd_)) {
+      GlobalOutput.perror("TFileTransport: ~TFileTransport() ::close() ", errno);
+    } else {
+      //successfully closed fd
+      fd_ = 0;
+    }
+  }
+}
+
+bool TFileTransport::initBufferAndWriteThread() {
+  if (bufferAndThreadInitialized_) {
+    T_ERROR("%s", "Trying to double-init TFileTransport");
+    return false;
+  }
+
+#ifdef USE_BOOST_THREAD
+  if(!writerThreadId_.get()) {
+    writerThreadId_ = std::auto_ptr<boost::thread>(new boost::thread(boost::bind(startWriterThread, (void *)this)));
+  }
+#else
+  if (writerThreadId_ == 0) {
+    if (pthread_create(&writerThreadId_, NULL, startWriterThread, (void *)this) != 0) {
+      T_ERROR("%s", "Could not create writer thread");
+      return false;
+    }
+  }
+#endif
+
+  dequeueBuffer_ = new TFileTransportBuffer(eventBufferSize_);
+  enqueueBuffer_ = new TFileTransportBuffer(eventBufferSize_);
+  bufferAndThreadInitialized_ = true;
+
+  return true;
+}
+
+void TFileTransport::write(const uint8_t* buf, uint32_t len) {
+  if (readOnly_) {
+    throw TTransportException("TFileTransport: attempting to write to file opened readonly");
+  }
+
+  enqueueEvent(buf, len);
+}
+
+void TFileTransport::enqueueEvent(const uint8_t* buf, uint32_t eventLen) {
+  // can't enqueue more events if file is going to close
+  if (closing_) {
+    return;
+  }
+
+  // make sure that event size is valid
+  if ( (maxEventSize_ > 0) && (eventLen > maxEventSize_) ) {
+    T_ERROR("msg size is greater than max event size: %u > %u\n", eventLen, maxEventSize_);
+    return;
+  }
+
+  if (eventLen == 0) {
+    T_ERROR("%s", "cannot enqueue an empty event");
+    return;
+  }
+
+  eventInfo* toEnqueue = new eventInfo();
+  toEnqueue->eventBuff_ = (uint8_t *)std::malloc((sizeof(uint8_t) * eventLen) + 4);
+  if (toEnqueue->eventBuff_ == NULL) {
+    delete toEnqueue;
+    throw std::bad_alloc();
+  }
+  // first 4 bytes is the event length
+  memcpy(toEnqueue->eventBuff_, (void*)(&eventLen), 4);
+  // actual event contents
+  memcpy(toEnqueue->eventBuff_ + 4, buf, eventLen);
+  toEnqueue->eventSize_ = eventLen + 4;
+
+  // lock mutex
+  Guard g(mutex_);
+
+  // make sure that enqueue buffer is initialized and writer thread is running
+  if (!bufferAndThreadInitialized_) {
+    if (!initBufferAndWriteThread()) {
+      delete toEnqueue;
+      return;
+    }
+  }
+
+  // Can't enqueue while buffer is full
+  while (enqueueBuffer_->isFull()) {
+	  notFull_.wait();
+  }
+
+  // We shouldn't be trying to enqueue new data while a forced flush is
+  // requested.  (Otherwise the writer thread might not ever be able to finish
+  // the flush if more data keeps being enqueued.)
+  assert(!forceFlush_);
+
+  // add to the buffer
+  if (!enqueueBuffer_->addEvent(toEnqueue)) {
+    delete toEnqueue;
+    return;
+  }
+
+  // signal anybody who's waiting for the buffer to be non-empty
+  notEmpty_.notify();
+
+  // this really should be a loop where it makes sure it got flushed
+  // because condition variables can get triggered by the os for no reason
+  // it is probably a non-factor for the time being
+}
+
+bool TFileTransport::swapEventBuffers(struct timespec* deadline) {
+  bool swap;
+  Guard g(mutex_);
+
+  if (!enqueueBuffer_->isEmpty()) {
+    swap = true;
+  } else if (closing_) {
+    // even though there is no data to write,
+    // return immediately if the transport is closing
+    swap = false;
+  } else {
+    if (deadline != NULL) {
+      // if we were handed a deadline time struct, do a timed wait
+      notEmpty_.waitForTime(deadline);
+    } else {
+      // just wait until the buffer gets an item
+      notEmpty_.wait();
+    }
+
+    // could be empty if we timed out
+    swap = enqueueBuffer_->isEmpty();
+  }
+
+  if (swap) {
+    TFileTransportBuffer *temp = enqueueBuffer_;
+    enqueueBuffer_ = dequeueBuffer_;
+    dequeueBuffer_ = temp;
+  }
+
+
+  if (swap) {
+	  notFull_.notify();
+  }
+
+  return swap;
+}
+
+
+void TFileTransport::writerThread() {
+  bool hasIOError = false;
+
+  // open file if it is not open
+  if(!fd_) {
+    try {
+      openLogFile();
+    } catch (...) {
+      int errno_copy = errno;
+      GlobalOutput.perror("TFileTransport: writerThread() openLogFile() ", errno_copy);
+      fd_ = 0;
+      hasIOError = true;
+    }
+  }
+
+  // set the offset to the correct value (EOF)
+  if (!hasIOError) {
+    try {
+      seekToEnd();
+      // throw away any partial events
+      offset_ += readState_.lastDispatchPtr_;
+#ifndef _WIN32
+      ftruncate(fd_, offset_);
+#else
+      _chsize_s(fd_, offset_);
+#endif
+      readState_.resetAllValues();
+    } catch (...) {
+      int errno_copy = errno;
+      GlobalOutput.perror("TFileTransport: writerThread() initialization ", errno_copy);
+      hasIOError = true;
+    }
+  }
+
+  // Figure out the next time by which a flush must take place
+  struct timespec ts_next_flush;
+  getNextFlushTime(&ts_next_flush);
+  uint32_t unflushed = 0;
+
+  while (1) {
+    // this will only be true when the destructor is being invoked
+    if (closing_) {
+      if (hasIOError) {
+#ifndef USE_BOOST_THREAD
+		  pthread_exit(NULL);
+#else
+		  return;
+#endif
+      }
+
+      // Try to empty buffers before exit
+      if (enqueueBuffer_->isEmpty() && dequeueBuffer_->isEmpty()) {
+#ifndef _WIN32
+        fsync(fd_);
+#endif
+        if (-1 == ::close(fd_)) {
+          int errno_copy = errno;
+          GlobalOutput.perror("TFileTransport: writerThread() ::close() ", errno_copy);
+        } else {
+          //fd successfully closed
+          fd_ = 0;
+        }
+#ifndef USE_BOOST_THREAD
+        pthread_exit(NULL);
+#else
+        return;
+#endif
+	  }
+    }
+
+    if (swapEventBuffers(&ts_next_flush)) {
+      eventInfo* outEvent;
+      while (NULL != (outEvent = dequeueBuffer_->getNext())) {
+        // Remove an event from the buffer and write it out to disk. If there is any IO error, for instance,
+        // the output file is unmounted or deleted, then this event is dropped. However, the writer thread
+        // will: (1) sleep for a short while; (2) try to reopen the file; (3) if successful then start writing
+        // from the end.
+
+        while (hasIOError) {
+          T_ERROR("TFileTransport: writer thread going to sleep for %d microseconds due to IO errors", writerThreadIOErrorSleepTime_);
+          thrift_usleep(writerThreadIOErrorSleepTime_);
+          if (closing_) {
+#ifndef USE_BOOST_THREAD
+            pthread_exit(NULL);
+#else
+            return;
+#endif
+          }
+          if (!fd_) {
+            ::close(fd_);
+            fd_ = 0;
+          }
+          try {
+            openLogFile();
+            seekToEnd();
+            unflushed = 0;
+            hasIOError = false;
+            T_LOG_OPER("TFileTransport: log file %s reopened by writer thread during error recovery", filename_.c_str());
+          } catch (...) {
+            T_ERROR("TFileTransport: unable to reopen log file %s during error recovery", filename_.c_str());
+          }
+        }
+
+        // sanity check on event
+        if ((maxEventSize_ > 0) && (outEvent->eventSize_ > maxEventSize_)) {
+          T_ERROR("msg size is greater than max event size: %u > %u\n", outEvent->eventSize_, maxEventSize_);
+          continue;
+        }
+
+        // If chunking is required, then make sure that msg does not cross chunk boundary
+        if ((outEvent->eventSize_ > 0) && (chunkSize_ != 0)) {
+          // event size must be less than chunk size
+          if (outEvent->eventSize_ > chunkSize_) {
+            T_ERROR("TFileTransport: event size(%u) > chunk size(%u): skipping event", outEvent->eventSize_, chunkSize_);
+            continue;
+          }
+
+          int64_t chunk1 = offset_/chunkSize_;
+          int64_t chunk2 = (offset_ + outEvent->eventSize_ - 1)/chunkSize_;
+
+          // if adding this event will cross a chunk boundary, pad the chunk with zeros
+          if (chunk1 != chunk2) {
+            // refetch the offset to keep in sync
+            offset_ = lseek(fd_, 0, SEEK_CUR);
+            int32_t padding = (int32_t)((offset_ / chunkSize_ + 1) * chunkSize_ - offset_);
+
+            uint8_t* zeros = new uint8_t[padding];
+            memset(zeros, '\0', padding);
+            boost::scoped_array<uint8_t> array(zeros);
+            if (-1 == ::write(fd_, zeros, padding)) {
+              int errno_copy = errno;
+              GlobalOutput.perror("TFileTransport: writerThread() error while padding zeros ", errno_copy);
+              hasIOError = true;
+              continue;
+            }
+            unflushed += padding;
+            offset_ += padding;
+          }
+        }
+
+        // write the dequeued event to the file
+        if (outEvent->eventSize_ > 0) {
+          if (-1 == ::write(fd_, outEvent->eventBuff_, outEvent->eventSize_)) {
+            int errno_copy = errno;
+            GlobalOutput.perror("TFileTransport: error while writing event ", errno_copy);
+            hasIOError = true;
+            continue;
+          }
+          unflushed += outEvent->eventSize_;
+          offset_ += outEvent->eventSize_;
+        }
+      }
+      dequeueBuffer_->reset();
+    }
+
+    if (hasIOError) {
+      continue;
+    }
+
+    // Local variable to cache the state of forceFlush_.
+    //
+    // We only want to check the value of forceFlush_ once each time around the
+    // loop.  If we check it more than once without holding the lock the entire
+    // time, it could have changed state in between.  This will result in us
+    // making inconsistent decisions.
+    bool forced_flush = false;
+	{
+    Guard g(mutex_);
+    if (forceFlush_) {
+      if (!enqueueBuffer_->isEmpty()) {
+        // If forceFlush_ is true, we need to flush all available data.
+        // If enqueueBuffer_ is not empty, go back to the start of the loop to
+        // write it out.
+        //
+        // We know the main thread is waiting on forceFlush_ to be cleared,
+        // so no new events will be added to enqueueBuffer_ until we clear
+        // forceFlush_.  Therefore the next time around the loop enqueueBuffer_
+        // is guaranteed to be empty.  (I.e., we're guaranteed to make progress
+        // and clear forceFlush_ the next time around the loop.)
+        continue;
+      }
+      forced_flush = true;
+	}
+	}
+
+    // determine if we need to perform an fsync
+    bool flush = false;
+    if (forced_flush || unflushed > flushMaxBytes_) {
+      flush = true;
+    } else {
+      struct timespec current_time;
+      clock_gettime(CLOCK_REALTIME, &current_time);
+      if (current_time.tv_sec > ts_next_flush.tv_sec ||
+          (current_time.tv_sec == ts_next_flush.tv_sec &&
+           current_time.tv_nsec > ts_next_flush.tv_nsec)) {
+        if (unflushed > 0) {
+          flush = true;
+        } else {
+          // If there is no new data since the last fsync,
+          // don't perform the fsync, but do reset the timer.
+          getNextFlushTime(&ts_next_flush);
+        }
+      }
+    }
+
+    if (flush) {
+      // sync (force flush) file to disk
+#ifndef _WIN32
+      fsync(fd_);
+#endif
+      unflushed = 0;
+      getNextFlushTime(&ts_next_flush);
+
+      // notify anybody waiting for flush completion
+      if (forced_flush) {
+        Guard g(mutex_);
+        forceFlush_ = false;
+        assert(enqueueBuffer_->isEmpty());
+        assert(dequeueBuffer_->isEmpty());
+		flushed_.notifyAll();
+      }
+    }
+  }
+}
+
+void TFileTransport::flush() {
+  // file must be open for writing for any flushing to take place
+#ifdef USE_BOOST_THREAD
+  if (!writerThreadId_.get()) {
+    return;
+  }
+#else
+  if (writerThreadId_ <= 0) {
+    return;
+  }
+#endif
+  // wait for flush to take place
+  Guard g(mutex_);
+
+  // Indicate that we are requesting a flush
+  forceFlush_ = true;
+  // Wake up the writer thread so it will perform the flush immediately
+  notEmpty_.notify();
+
+  while (forceFlush_) {
+    flushed_.wait();
+  }
+}
+
+
+uint32_t TFileTransport::readAll(uint8_t* buf, uint32_t len) {
+  uint32_t have = 0;
+  uint32_t get = 0;
+
+  while (have < len) {
+    get = read(buf+have, len-have);
+    if (get <= 0) {
+      throw TEOFException();
+    }
+    have += get;
+  }
+
+  return have;
+}
+
+bool TFileTransport::peek() {
+  // check if there is an event ready to be read
+  if (!currentEvent_) {
+    currentEvent_ = readEvent();
+  }
+
+  // did not manage to read an event from the file. This could have happened
+  // if the timeout expired or there was some other error
+  if (!currentEvent_) {
+    return false;
+  }
+
+  // check if there is anything to read
+  return (currentEvent_->eventSize_ - currentEvent_->eventBuffPos_) > 0;
+}
+
+uint32_t TFileTransport::read(uint8_t* buf, uint32_t len) {
+  // check if there an event is ready to be read
+  if (!currentEvent_) {
+    currentEvent_ = readEvent();
+  }
+
+  // did not manage to read an event from the file. This could have happened
+  // if the timeout expired or there was some other error
+  if (!currentEvent_) {
+    return 0;
+  }
+
+  // read as much of the current event as possible
+  int32_t remaining = currentEvent_->eventSize_ - currentEvent_->eventBuffPos_;
+  if (remaining <= (int32_t)len) {
+    // copy over anything thats remaining
+    if (remaining > 0) {
+      memcpy(buf,
+             currentEvent_->eventBuff_ + currentEvent_->eventBuffPos_,
+             remaining);
+    }
+    delete(currentEvent_);
+    currentEvent_ = NULL;
+    return remaining;
+  }
+
+  // read as much as possible
+  memcpy(buf, currentEvent_->eventBuff_ + currentEvent_->eventBuffPos_, len);
+  currentEvent_->eventBuffPos_ += len;
+  return len;
+}
+
+// note caller is responsible for freeing returned events
+eventInfo* TFileTransport::readEvent() {
+  int readTries = 0;
+
+  if (!readBuff_) {
+    readBuff_ = new uint8_t[readBuffSize_];
+  }
+
+  while (1) {
+    // read from the file if read buffer is exhausted
+    if (readState_.bufferPtr_ == readState_.bufferLen_) {
+      // advance the offset pointer
+      offset_ += readState_.bufferLen_;
+      readState_.bufferLen_ = ::read(fd_, readBuff_, readBuffSize_);
+      //       if (readState_.bufferLen_) {
+      //         T_DEBUG_L(1, "Amount read: %u (offset: %lu)", readState_.bufferLen_, offset_);
+      //       }
+      readState_.bufferPtr_ = 0;
+      readState_.lastDispatchPtr_ = 0;
+
+      // read error
+      if (readState_.bufferLen_ == -1) {
+        readState_.resetAllValues();
+        GlobalOutput("TFileTransport: error while reading from file");
+        throw TTransportException("TFileTransport: error while reading from file");
+      } else if (readState_.bufferLen_ == 0) {  // EOF
+        // wait indefinitely if there is no timeout
+        if (readTimeout_ == TAIL_READ_TIMEOUT) {
+          thrift_usleep(eofSleepTime_);
+          continue;
+        } else if (readTimeout_ == NO_TAIL_READ_TIMEOUT) {
+          // reset state
+          readState_.resetState(0);
+          return NULL;
+        } else if (readTimeout_ > 0) {
+          // timeout already expired once
+          if (readTries > 0) {
+            readState_.resetState(0);
+            return NULL;
+          } else {
+            thrift_usleep(readTimeout_ * 1000);
+            readTries++;
+            continue;
+          }
+        }
+      }
+    }
+
+    readTries = 0;
+
+    // attempt to read an event from the buffer
+    while(readState_.bufferPtr_ < readState_.bufferLen_) {
+      if (readState_.readingSize_) {
+        if(readState_.eventSizeBuffPos_ == 0) {
+          if ( (offset_ + readState_.bufferPtr_)/chunkSize_ !=
+               ((offset_ + readState_.bufferPtr_ + 3)/chunkSize_)) {
+            // skip one byte towards chunk boundary
+            //            T_DEBUG_L(1, "Skipping a byte");
+            readState_.bufferPtr_++;
+            continue;
+          }
+        }
+
+        readState_.eventSizeBuff_[readState_.eventSizeBuffPos_++] =
+          readBuff_[readState_.bufferPtr_++];
+        if (readState_.eventSizeBuffPos_ == 4) {
+          // 0 length event indicates padding
+          if (*((uint32_t *)(readState_.eventSizeBuff_)) == 0) {
+            //            T_DEBUG_L(1, "Got padding");
+            readState_.resetState(readState_.lastDispatchPtr_);
+            continue;
+          }
+          // got a valid event
+          readState_.readingSize_ = false;
+          if (readState_.event_) {
+            delete(readState_.event_);
+          }
+          readState_.event_ = new eventInfo();
+          readState_.event_->eventSize_ = *((uint32_t *)(readState_.eventSizeBuff_));
+
+          // check if the event is corrupted and perform recovery if required
+          if (isEventCorrupted()) {
+            performRecovery();
+            // start from the top
+            break;
+          }
+        }
+      } else {
+        if (!readState_.event_->eventBuff_) {
+          readState_.event_->eventBuff_ = new uint8_t[readState_.event_->eventSize_];
+          readState_.event_->eventBuffPos_ = 0;
+        }
+        // take either the entire event or the remaining bytes in the buffer
+        int reclaimBuffer = min((uint32_t)(readState_.bufferLen_ - readState_.bufferPtr_),
+                                readState_.event_->eventSize_ - readState_.event_->eventBuffPos_);
+
+        // copy data from read buffer into event buffer
+        memcpy(readState_.event_->eventBuff_ + readState_.event_->eventBuffPos_,
+               readBuff_ + readState_.bufferPtr_,
+               reclaimBuffer);
+
+        // increment position ptrs
+        readState_.event_->eventBuffPos_ += reclaimBuffer;
+        readState_.bufferPtr_ += reclaimBuffer;
+
+        // check if the event has been read in full
+        if (readState_.event_->eventBuffPos_ == readState_.event_->eventSize_) {
+          // set the completed event to the current event
+          eventInfo* completeEvent = readState_.event_;
+          completeEvent->eventBuffPos_ = 0;
+
+          readState_.event_ = NULL;
+          readState_.resetState(readState_.bufferPtr_);
+
+          // exit criteria
+          return completeEvent;
+        }
+      }
+    }
+
+  }
+}
+
+bool TFileTransport::isEventCorrupted() {
+  // an error is triggered if:
+  if ( (maxEventSize_ > 0) &&  (readState_.event_->eventSize_ > maxEventSize_)) {
+    // 1. Event size is larger than user-speficied max-event size
+    T_ERROR("Read corrupt event. Event size(%u) greater than max event size (%u)",
+            readState_.event_->eventSize_, maxEventSize_);
+    return true;
+  } else if (readState_.event_->eventSize_ > chunkSize_) {
+    // 2. Event size is larger than chunk size
+    T_ERROR("Read corrupt event. Event size(%u) greater than chunk size (%u)",
+               readState_.event_->eventSize_, chunkSize_);
+    return true;
+  } else if( ((offset_ + readState_.bufferPtr_ - 4)/chunkSize_) !=
+             ((offset_ + readState_.bufferPtr_ + readState_.event_->eventSize_ - 1)/chunkSize_) ) {
+    // 3. size indicates that event crosses chunk boundary
+    T_ERROR("Read corrupt event. Event crosses chunk boundary. Event size:%u  Offset:%lu",
+            readState_.event_->eventSize_,
+            (offset_ + readState_.bufferPtr_ + 4));
+
+    return true;
+  }
+
+  return false;
+}
+
+void TFileTransport::performRecovery() {
+  // perform some kickass recovery
+  uint32_t curChunk = getCurChunk();
+  if (lastBadChunk_ == curChunk) {
+    numCorruptedEventsInChunk_++;
+  } else {
+    lastBadChunk_ = curChunk;
+    numCorruptedEventsInChunk_ = 1;
+  }
+
+  if (numCorruptedEventsInChunk_ < maxCorruptedEvents_) {
+    // maybe there was an error in reading the file from disk
+    // seek to the beginning of chunk and try again
+    seekToChunk(curChunk);
+  } else {
+
+    // just skip ahead to the next chunk if we not already at the last chunk
+    if (curChunk != (getNumChunks() - 1)) {
+      seekToChunk(curChunk + 1);
+    } else if (readTimeout_ == TAIL_READ_TIMEOUT) {
+      // if tailing the file, wait until there is enough data to start
+      // the next chunk
+      while(curChunk == (getNumChunks() - 1)) {
+        thrift_usleep(DEFAULT_CORRUPTED_SLEEP_TIME_US);
+      }
+      seekToChunk(curChunk + 1);
+    } else {
+      // pretty hosed at this stage, rewind the file back to the last successful
+      // point and punt on the error
+      readState_.resetState(readState_.lastDispatchPtr_);
+      currentEvent_ = NULL;
+      char errorMsg[1024];
+      sprintf(errorMsg, "TFileTransport: log file corrupted at offset: %lu",
+              (offset_ + readState_.lastDispatchPtr_));
+              
+      GlobalOutput(errorMsg);
+      throw TTransportException(errorMsg);
+    }
+  }
+
+}
+
+void TFileTransport::seekToChunk(int32_t chunk) {
+  if (fd_ <= 0) {
+    throw TTransportException("File not open");
+  }
+
+  int32_t numChunks = getNumChunks();
+
+  // file is empty, seeking to chunk is pointless
+  if (numChunks == 0) {
+    return;
+  }
+
+  // negative indicates reverse seek (from the end)
+  if (chunk < 0) {
+    chunk += numChunks;
+  }
+
+  // too large a value for reverse seek, just seek to beginning
+  if (chunk < 0) {
+    T_DEBUG("%s", "Incorrect value for reverse seek. Seeking to beginning...");
+    chunk = 0;
+  }
+
+  // cannot seek past EOF
+  bool seekToEnd = false;
+  off_t minEndOffset = 0;
+  if (chunk >= numChunks) {
+    T_DEBUG("%s", "Trying to seek past EOF. Seeking to EOF instead...");
+    seekToEnd = true;
+    chunk = numChunks - 1;
+    // this is the min offset to process events till
+    minEndOffset = lseek(fd_, 0, SEEK_END);
+  }
+
+  off_t newOffset = off_t(chunk) * chunkSize_;
+  offset_ = lseek(fd_, newOffset, SEEK_SET);
+  readState_.resetAllValues();
+  currentEvent_ = NULL;
+  if (offset_ == -1) {
+    GlobalOutput("TFileTransport: lseek error in seekToChunk");
+    throw TTransportException("TFileTransport: lseek error in seekToChunk");
+  }
+
+  // seek to EOF if user wanted to go to last chunk
+  if (seekToEnd) {
+    uint32_t oldReadTimeout = getReadTimeout();
+    setReadTimeout(NO_TAIL_READ_TIMEOUT);
+    // keep on reading unti the last event at point of seekChunk call
+    boost::scoped_ptr<eventInfo> event;
+    while ((offset_ + readState_.bufferPtr_) < minEndOffset) {
+      event.reset(readEvent());
+      if (event.get() == NULL) {
+        break;
+      }
+    }
+    setReadTimeout(oldReadTimeout);
+  }
+
+}
+
+void TFileTransport::seekToEnd() {
+  seekToChunk(getNumChunks());
+}
+
+uint32_t TFileTransport::getNumChunks() {
+  if (fd_ <= 0) {
+    return 0;
+  }
+
+  struct stat f_info;
+  int rv = fstat(fd_, &f_info);
+
+  if (rv < 0) {
+    int errno_copy = errno;
+    throw TTransportException(TTransportException::UNKNOWN,
+                              "TFileTransport::getNumChunks() (fstat)",
+                              errno_copy);
+  }
+
+  if (f_info.st_size > 0) {
+    return ((f_info.st_size)/chunkSize_) + 1;
+  }
+
+  // empty file has no chunks
+  return 0;
+}
+
+uint32_t TFileTransport::getCurChunk() {
+  return offset_/chunkSize_;
+}
+
+// Utility Functions
+void TFileTransport::openLogFile() {
+#ifndef _WIN32
+  mode_t mode = readOnly_ ? S_IRUSR | S_IRGRP | S_IROTH : S_IRUSR | S_IWUSR| S_IRGRP | S_IROTH;
+  int flags = readOnly_ ? O_RDONLY : O_RDWR | O_CREAT | O_APPEND;
+  fd_ = ::open(filename_.c_str(), flags, mode);
+#else
+  int mode = readOnly_ ? _S_IREAD : _S_IREAD | _S_IWRITE;
+  int flags = readOnly_ ? _O_RDONLY : _O_RDWR | _O_CREAT | _O_APPEND;
+  fd_ = ::_open(filename_.c_str(), flags, mode);
+#endif
+  offset_ = 0;
+
+  // make sure open call was successful
+  if(fd_ == -1) {
+    int errno_copy = errno;
+    GlobalOutput.perror("TFileTransport: openLogFile() ::open() file: " + filename_, errno_copy);
+    throw TTransportException(TTransportException::NOT_OPEN, filename_, errno_copy);
+  }
+
+}
+
+void TFileTransport::getNextFlushTime(struct timespec* ts_next_flush) {
+  clock_gettime(CLOCK_REALTIME, ts_next_flush);
+  ts_next_flush->tv_nsec += (flushMaxUs_ % 1000000) * 1000;
+  if (ts_next_flush->tv_nsec > 1000000000) {
+    ts_next_flush->tv_nsec -= 1000000000;
+    ts_next_flush->tv_sec += 1;
+  }
+  ts_next_flush->tv_sec += flushMaxUs_ / 1000000;
+}
+
+TFileTransportBuffer::TFileTransportBuffer(uint32_t size)
+  : bufferMode_(WRITE)
+  , writePoint_(0)
+  , readPoint_(0)
+  , size_(size)
+{
+  buffer_ = new eventInfo*[size];
+}
+
+TFileTransportBuffer::~TFileTransportBuffer() {
+  if (buffer_) {
+    for (uint32_t i = 0; i < writePoint_; i++) {
+      delete buffer_[i];
+    }
+    delete[] buffer_;
+    buffer_ = NULL;
+  }
+}
+
+bool TFileTransportBuffer::addEvent(eventInfo *event) {
+  if (bufferMode_ == READ) {
+    GlobalOutput("Trying to write to a buffer in read mode");
+  }
+  if (writePoint_ < size_) {
+    buffer_[writePoint_++] = event;
+    return true;
+  } else {
+    // buffer is full
+    return false;
+  }
+}
+
+eventInfo* TFileTransportBuffer::getNext() {
+  if (bufferMode_ == WRITE) {
+    bufferMode_ = READ;
+  }
+  if (readPoint_ < writePoint_) {
+    return buffer_[readPoint_++];
+  } else {
+    // no more entries
+    return NULL;
+  }
+}
+
+void TFileTransportBuffer::reset() {
+  if (bufferMode_ == WRITE || writePoint_ > readPoint_) {
+    T_DEBUG("%s", "Resetting a buffer with unread entries");
+  }
+  // Clean up the old entries
+  for (uint32_t i = 0; i < writePoint_; i++) {
+    delete buffer_[i];
+  }
+  bufferMode_ = WRITE;
+  writePoint_ = 0;
+  readPoint_ = 0;
+}
+
+bool TFileTransportBuffer::isFull() {
+  return writePoint_ == size_;
+}
+
+bool TFileTransportBuffer::isEmpty() {
+  return writePoint_ == 0;
+}
+
+TFileProcessor::TFileProcessor(shared_ptr<TProcessor> processor,
+                               shared_ptr<TProtocolFactory> protocolFactory,
+                               shared_ptr<TFileReaderTransport> inputTransport):
+  processor_(processor),
+  inputProtocolFactory_(protocolFactory),
+  outputProtocolFactory_(protocolFactory),
+  inputTransport_(inputTransport) {
+
+  // default the output transport to a null transport (common case)
+  outputTransport_ = shared_ptr<TNullTransport>(new TNullTransport());
+}
+
+TFileProcessor::TFileProcessor(shared_ptr<TProcessor> processor,
+                               shared_ptr<TProtocolFactory> inputProtocolFactory,
+                               shared_ptr<TProtocolFactory> outputProtocolFactory,
+                               shared_ptr<TFileReaderTransport> inputTransport):
+  processor_(processor),
+  inputProtocolFactory_(inputProtocolFactory),
+  outputProtocolFactory_(outputProtocolFactory),
+  inputTransport_(inputTransport) {
+
+  // default the output transport to a null transport (common case)
+  outputTransport_ = shared_ptr<TNullTransport>(new TNullTransport());
+}
+
+TFileProcessor::TFileProcessor(shared_ptr<TProcessor> processor,
+                               shared_ptr<TProtocolFactory> protocolFactory,
+                               shared_ptr<TFileReaderTransport> inputTransport,
+                               shared_ptr<TTransport> outputTransport):
+  processor_(processor),
+  inputProtocolFactory_(protocolFactory),
+  outputProtocolFactory_(protocolFactory),
+  inputTransport_(inputTransport),
+  outputTransport_(outputTransport) {}
+
+void TFileProcessor::process(uint32_t numEvents, bool tail) {
+  shared_ptr<TProtocol> inputProtocol = inputProtocolFactory_->getProtocol(inputTransport_);
+  shared_ptr<TProtocol> outputProtocol = outputProtocolFactory_->getProtocol(outputTransport_);
+
+  // set the read timeout to 0 if tailing is required
+  int32_t oldReadTimeout = inputTransport_->getReadTimeout();
+  if (tail) {
+    // save old read timeout so it can be restored
+    inputTransport_->setReadTimeout(TFileTransport::TAIL_READ_TIMEOUT);
+  }
+
+  uint32_t numProcessed = 0;
+  while(1) {
+    // bad form to use exceptions for flow control but there is really
+    // no other way around it
+    try {
+      processor_->process(inputProtocol, outputProtocol, NULL);
+      numProcessed++;
+      if ( (numEvents > 0) && (numProcessed == numEvents)) {
+        return;
+      }
+    } catch (TEOFException& teof) {
+      if (!tail) {
+        break;
+      }
+    } catch (TException &te) {
+      cerr << te.what() << endl;
+      break;
+    }
+  }
+
+  // restore old read timeout
+  if (tail) {
+    inputTransport_->setReadTimeout(oldReadTimeout);
+  }
+
+}
+
+void TFileProcessor::processChunk() {
+  shared_ptr<TProtocol> inputProtocol = inputProtocolFactory_->getProtocol(inputTransport_);
+  shared_ptr<TProtocol> outputProtocol = outputProtocolFactory_->getProtocol(outputTransport_);
+
+  uint32_t curChunk = inputTransport_->getCurChunk();
+
+  while(1) {
+    // bad form to use exceptions for flow control but there is really
+    // no other way around it
+    try {
+      processor_->process(inputProtocol, outputProtocol, NULL);
+      if (curChunk != inputTransport_->getCurChunk()) {
+        break;
+      }
+    } catch (TEOFException& teof) {
+      break;
+    } catch (TException &te) {
+      cerr << te.what() << endl;
+      break;
+    }
+  }
+}
+
+}}} // apache::thrift::transport
--- lib/cpp/src/transport/TSocket.cpp	Sat Nov 26 11:00:42 2011
+++ lib/cpp/src/transport/TSocket.cpp	Thu Nov 30 14:26:50 2017
@@ -1,823 +1,823 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements. See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership. The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-#include <cstring>
-#include <sstream>
-#ifdef HAVE_SYS_SOCKET_H
-#include <sys/socket.h>
-#endif
-#ifdef HAVE_SYS_UN_H
-#include <sys/un.h>
-#endif
-#ifdef HAVE_SYS_POLL_H
-#include <sys/poll.h>
-#endif
-#include <sys/types.h>
-#ifdef HAVE_ARPA_INET_H
-#include <arpa/inet.h>
-#endif
-#ifdef HAVE_NETINET_IN_H
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-#endif
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#include <errno.h>
-#include <fcntl.h>
-
-#include "concurrency/Monitor.h"
-#include "TSocket.h"
-#include "TTransportException.h"
-
-#ifndef SOCKOPT_CAST_T
-#   ifndef _WIN32
-#       define SOCKOPT_CAST_T void
-#   else
-#       define SOCKOPT_CAST_T char
-#   endif // _WIN32
-#endif
-
-template<class T>
-inline const SOCKOPT_CAST_T* const_cast_sockopt(const T* v) {
-    return reinterpret_cast<const SOCKOPT_CAST_T*>(v);
-}
-
-template<class T>
-inline SOCKOPT_CAST_T* cast_sockopt(T* v) {
-    return reinterpret_cast<SOCKOPT_CAST_T*>(v);
-}
-
-namespace apache { namespace thrift { namespace transport {
-
-using namespace std;
-
-// Global var to track total socket sys calls
-uint32_t g_socket_syscalls = 0;
-
-/**
- * TSocket implementation.
- *
- */
-
-TSocket::TSocket(string host, int port) :
-  host_(host),
-  port_(port),
-  path_(""),
-  socket_(-1),
-  connTimeout_(0),
-  sendTimeout_(0),
-  recvTimeout_(0),
-  lingerOn_(1),
-  lingerVal_(0),
-  noDelay_(1),
-  maxRecvRetries_(5) {
-  recvTimeval_.tv_sec = (int)(recvTimeout_/1000);
-  recvTimeval_.tv_usec = (int)((recvTimeout_%1000)*1000);
-}
-
-TSocket::TSocket(string path) :
-  host_(""),
-  port_(0),
-  path_(path),
-  socket_(-1),
-  connTimeout_(0),
-  sendTimeout_(0),
-  recvTimeout_(0),
-  lingerOn_(1),
-  lingerVal_(0),
-  noDelay_(1),
-  maxRecvRetries_(5) {
-  recvTimeval_.tv_sec = (int)(recvTimeout_/1000);
-  recvTimeval_.tv_usec = (int)((recvTimeout_%1000)*1000);
-  cachedPeerAddr_.ipv4.sin_family = AF_UNSPEC;
-}
-
-TSocket::TSocket() :
-  host_(""),
-  port_(0),
-  path_(""),
-  socket_(-1),
-  connTimeout_(0),
-  sendTimeout_(0),
-  recvTimeout_(0),
-  lingerOn_(1),
-  lingerVal_(0),
-  noDelay_(1),
-  maxRecvRetries_(5) {
-  recvTimeval_.tv_sec = (int)(recvTimeout_/1000);
-  recvTimeval_.tv_usec = (int)((recvTimeout_%1000)*1000);
-  cachedPeerAddr_.ipv4.sin_family = AF_UNSPEC;
-}
-
-TSocket::TSocket(int socket) :
-  host_(""),
-  port_(0),
-  path_(""),
-  socket_(socket),
-  connTimeout_(0),
-  sendTimeout_(0),
-  recvTimeout_(0),
-  lingerOn_(1),
-  lingerVal_(0),
-  noDelay_(1),
-  maxRecvRetries_(5) {
-  recvTimeval_.tv_sec = (int)(recvTimeout_/1000);
-  recvTimeval_.tv_usec = (int)((recvTimeout_%1000)*1000);
-  cachedPeerAddr_.ipv4.sin_family = AF_UNSPEC;
-}
-
-TSocket::~TSocket() {
-  close();
-}
-
-bool TSocket::isOpen() {
-  return (socket_ >= 0);
-}
-
-bool TSocket::peek() {
-  if (!isOpen()) {
-    return false;
-  }
-  uint8_t buf;
-  int r = recv(socket_, cast_sockopt(&buf), 1, MSG_PEEK);
-  if (r == -1) {
-    int errno_copy = errno;
-    #if defined __FreeBSD__ || defined __MACH__
-    /* shigin:
-     * freebsd returns -1 and ECONNRESET if socket was closed by 
-     * the other side
-     */
-    if (errno_copy == ECONNRESET)
-    {
-      close();
-      return false;
-    }
-    #endif
-    GlobalOutput.perror("TSocket::peek() recv() " + getSocketInfo(), errno_copy);
-    throw TTransportException(TTransportException::UNKNOWN, "recv()", errno_copy);
-  }
-  return (r > 0);
-}
-
-void TSocket::openConnection(struct addrinfo *res) {
-
-  if (isOpen()) {
-    return;
-  }
-
-  if (! path_.empty()) {
-    socket_ = socket(PF_UNIX, SOCK_STREAM, IPPROTO_IP);
-  } else {
-    socket_ = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
-  }
-
-  if (socket_ == -1) {
-    int errno_copy = errno;
-    GlobalOutput.perror("TSocket::open() socket() " + getSocketInfo(), errno_copy);
-    throw TTransportException(TTransportException::NOT_OPEN, "socket()", errno_copy);
-  }
-
-  // Send timeout
-  if (sendTimeout_ > 0) {
-    setSendTimeout(sendTimeout_);
-  }
-
-  // Recv timeout
-  if (recvTimeout_ > 0) {
-    setRecvTimeout(recvTimeout_);
-  }
-
-  // Linger
-  setLinger(lingerOn_, lingerVal_);
-
-  // No delay
-  setNoDelay(noDelay_);
-
-  // Uses a low min RTO if asked to.
-#ifdef TCP_LOW_MIN_RTO
-  if (getUseLowMinRto()) {
-    int one = 1;
-    setsockopt(socket_, IPPROTO_TCP, TCP_LOW_MIN_RTO, &one, sizeof(one));
-  }
-#endif
-
-
-  // Set the socket to be non blocking for connect if a timeout exists
-  int flags = fcntl(socket_, F_GETFL, 0);
-  if (connTimeout_ > 0) {
-    if (-1 == fcntl(socket_, F_SETFL, flags | O_NONBLOCK)) {
-      int errno_copy = errno;
-      GlobalOutput.perror("TSocket::open() fcntl() " + getSocketInfo(), errno_copy);
-      throw TTransportException(TTransportException::NOT_OPEN, "fcntl() failed", errno_copy);
-    }
-  } else {
-    if (-1 == fcntl(socket_, F_SETFL, flags & ~O_NONBLOCK)) {
-      int errno_copy = errno;
-      GlobalOutput.perror("TSocket::open() fcntl " + getSocketInfo(), errno_copy);
-      throw TTransportException(TTransportException::NOT_OPEN, "fcntl() failed", errno_copy);
-    }
-  }
-
-  // Connect the socket
-  int ret;
-  if (! path_.empty()) {
-
-#ifndef _WIN32
-
-    struct sockaddr_un address;
-    socklen_t len;
-
-    if (path_.length() > sizeof(address.sun_path)) {
-      int errno_copy = errno;
-      GlobalOutput.perror("TSocket::open() Unix Domain socket path too long", errno_copy);
-      throw TTransportException(TTransportException::NOT_OPEN, " Unix Domain socket path too long");
-    }
-
-    address.sun_family = AF_UNIX;
-    snprintf(address.sun_path, sizeof(address.sun_path), "%s", path_.c_str());
-    len = sizeof(address);
-    ret = connect(socket_, (struct sockaddr *) &address, len);
-
-#else
-      GlobalOutput.perror("TSocket::open() Unix Domain socket path not supported on windows", -99);
-      throw TTransportException(TTransportException::NOT_OPEN, " Unix Domain socket path not supported");
-#endif
-
-  } else {
-    ret = connect(socket_, res->ai_addr, res->ai_addrlen);
-  }
-
-  // success case
-  if (ret == 0) {
-    goto done;
-  }
-
-  if ((errno != EINPROGRESS) && (errno != EWOULDBLOCK)) {
-    int errno_copy = errno;
-    GlobalOutput.perror("TSocket::open() connect() " + getSocketInfo(), errno_copy);
-    throw TTransportException(TTransportException::NOT_OPEN, "connect() failed", errno_copy);
-  }
-
-
-  struct pollfd fds[1];
-  std::memset(fds, 0 , sizeof(fds));
-  fds[0].fd = socket_;
-  fds[0].events = POLLOUT;
-  ret = poll(fds, 1, connTimeout_);
-
-  if (ret > 0) {
-    // Ensure the socket is connected and that there are no errors set
-    int val;
-    socklen_t lon;
-    lon = sizeof(int);
-    int ret2 = getsockopt(socket_, SOL_SOCKET, SO_ERROR, cast_sockopt(&val), &lon);
-    if (ret2 == -1) {
-      int errno_copy = errno;
-      GlobalOutput.perror("TSocket::open() getsockopt() " + getSocketInfo(), errno_copy);
-      throw TTransportException(TTransportException::NOT_OPEN, "getsockopt()", errno_copy);
-    }
-    // no errors on socket, go to town
-    if (val == 0) {
-      goto done;
-    }
-    GlobalOutput.perror("TSocket::open() error on socket (after poll) " + getSocketInfo(), val);
-    throw TTransportException(TTransportException::NOT_OPEN, "socket open() error", val);
-  } else if (ret == 0) {
-    // socket timed out
-    string errStr = "TSocket::open() timed out " + getSocketInfo();
-    GlobalOutput(errStr.c_str());
-    throw TTransportException(TTransportException::NOT_OPEN, "open() timed out");
-  } else {
-    // error on poll()
-    int errno_copy = errno;
-    GlobalOutput.perror("TSocket::open() poll() " + getSocketInfo(), errno_copy);
-    throw TTransportException(TTransportException::NOT_OPEN, "poll() failed", errno_copy);
-  }
-
- done:
-  // Set socket back to normal mode (blocking)
-  fcntl(socket_, F_SETFL, flags);
-
-  if (path_.empty()) {
-    setCachedAddress(res->ai_addr, res->ai_addrlen);
-  }
-}
-
-void TSocket::open() {
-  if (isOpen()) {
-    return;
-  }
-  if (! path_.empty()) {
-    unix_open();
-  } else {
-    local_open();
-  }
-}
-
-void TSocket::unix_open(){
-  if (! path_.empty()) {
-    // Unix Domain SOcket does not need addrinfo struct, so we pass NULL
-    openConnection(NULL);
-  }
-}
-
-void TSocket::local_open(){
-
-#ifdef _WIN32
-    TWinsockSingleton::create();
-#endif // _WIN32
-
-  if (isOpen()) {
-    return;
-  }
-
-  // Validate port number
-  if (port_ < 0 || port_ > 0xFFFF) {
-    throw TTransportException(TTransportException::NOT_OPEN, "Specified port is invalid");
-  }
-
-  struct addrinfo hints, *res, *res0;
-  res = NULL;
-  res0 = NULL;
-  int error;
-  char port[sizeof("65535")];
-  std::memset(&hints, 0, sizeof(hints));
-  hints.ai_family = PF_UNSPEC;
-  hints.ai_socktype = SOCK_STREAM;
-  hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;
-  sprintf(port, "%d", port_);
-
-  error = getaddrinfo(host_.c_str(), port, &hints, &res0);
-
-  if (error) {
-    string errStr = "TSocket::open() getaddrinfo() " + getSocketInfo() + string(gai_strerror(error));
-    GlobalOutput(errStr.c_str());
-    close();
-    throw TTransportException(TTransportException::NOT_OPEN, "Could not resolve host for client socket.");
-  }
-
-  // Cycle through all the returned addresses until one
-  // connects or push the exception up.
-  for (res = res0; res; res = res->ai_next) {
-    try {
-      openConnection(res);
-      break;
-    } catch (TTransportException& ttx) {
-      if (res->ai_next) {
-        close();
-      } else {
-        close();
-        freeaddrinfo(res0); // cleanup on failure
-        throw;
-      }
-    }
-  }
-
-  // Free address structure memory
-  freeaddrinfo(res0);
-}
-
-void TSocket::close() {
-  if (socket_ >= 0) {
-
-#ifdef _WIN32
-      shutdown(socket_, SD_BOTH);
-      ::closesocket(socket_);
-#else
-      shutdown(socket_, SHUT_RDWR);
-      ::close(socket_);
-#endif
-
-  }
-  socket_ = -1;
-}
-
-void TSocket::setSocketFD(int socket) {
-  if (socket_ >= 0) {
-    close();
-  }
-  socket_ = socket;
-}
-
-uint32_t TSocket::read(uint8_t* buf, uint32_t len) {
-  if (socket_ < 0) {
-    throw TTransportException(TTransportException::NOT_OPEN, "Called read on non-open socket");
-  }
-
-  int32_t retries = 0;
-
-  // EAGAIN can be signalled both when a timeout has occurred and when
-  // the system is out of resources (an awesome undocumented feature).
-  // The following is an approximation of the time interval under which
-  // EAGAIN is taken to indicate an out of resources error.
-  uint32_t eagainThresholdMicros = 0;
-  if (recvTimeout_) {
-    // if a readTimeout is specified along with a max number of recv retries, then
-    // the threshold will ensure that the read timeout is not exceeded even in the
-    // case of resource errors
-    eagainThresholdMicros = (recvTimeout_*1000)/ ((maxRecvRetries_>0) ? maxRecvRetries_ : 2);
-  }
-
- try_again:
-  // Read from the socket
-  struct timeval begin;
-  if (recvTimeout_ > 0) {
-    gettimeofday(&begin, NULL);
-  } else {
-    // if there is no read timeout we don't need the TOD to determine whether
-    // an EAGAIN is due to a timeout or an out-of-resource condition.
-    begin.tv_sec = begin.tv_usec = 0;
-  }
-  int got = recv(socket_, cast_sockopt(buf), len, 0);
-  int errno_copy = errno; //gettimeofday can change errno
-  ++g_socket_syscalls;
-
-  // Check for error on read
-  if (got < 0) {
-    if (errno_copy == EAGAIN) {
-      // if no timeout we can assume that resource exhaustion has occurred.
-      if (recvTimeout_ == 0) {
-        throw TTransportException(TTransportException::TIMED_OUT,
-                                    "EAGAIN (unavailable resources)");
-      }
-      // check if this is the lack of resources or timeout case
-      struct timeval end;
-      gettimeofday(&end, NULL);
-      uint32_t readElapsedMicros =  (((end.tv_sec - begin.tv_sec) * 1000 * 1000)
-                                     + (((uint64_t)(end.tv_usec - begin.tv_usec))));
-
-      if (!eagainThresholdMicros || (readElapsedMicros < eagainThresholdMicros)) {
-        if (retries++ < maxRecvRetries_) {
-          usleep(50);
-          goto try_again;
-        } else {
-          throw TTransportException(TTransportException::TIMED_OUT,
-                                    "EAGAIN (unavailable resources)");
-        }
-      } else {
-        // infer that timeout has been hit
-        throw TTransportException(TTransportException::TIMED_OUT,
-                                  "EAGAIN (timed out)");
-      }
-    }
-
-    // If interrupted, try again
-    if (errno_copy == EINTR && retries++ < maxRecvRetries_) {
-      goto try_again;
-    }
-
-    #if defined __FreeBSD__ || defined __MACH__
-    if (errno_copy == ECONNRESET) {
-      /* shigin: freebsd doesn't follow POSIX semantic of recv and fails with
-       * ECONNRESET if peer performed shutdown 
-       * edhall: eliminated close() since we do that in the destructor.
-       */
-      return 0;
-    }
-    #endif
-
-#ifdef _WIN32
-    if(errno_copy == WSAECONNRESET) {
-      return 0; // EOF
-    }
-#endif
-
-    // Now it's not a try again case, but a real probblez
-    GlobalOutput.perror("TSocket::read() recv() " + getSocketInfo(), errno_copy);
-
-    // If we disconnect with no linger time
-    if (errno_copy == ECONNRESET) {
-      throw TTransportException(TTransportException::NOT_OPEN, "ECONNRESET");
-    }
-
-    // This ish isn't open
-    if (errno_copy == ENOTCONN) {
-      throw TTransportException(TTransportException::NOT_OPEN, "ENOTCONN");
-    }
-
-    // Timed out!
-    if (errno_copy == ETIMEDOUT) {
-      throw TTransportException(TTransportException::TIMED_OUT, "ETIMEDOUT");
-    }
-
-    // Some other error, whatevz
-    throw TTransportException(TTransportException::UNKNOWN, "Unknown", errno_copy);
-  }
-
-  // The remote host has closed the socket
-  if (got == 0) {
-    // edhall: we used to call close() here, but our caller may want to deal
-    // with the socket fd and we'll close() in our destructor in any case.
-    return 0;
-  }
-
-  // Pack data into string
-  return got;
-}
-
-void TSocket::write(const uint8_t* buf, uint32_t len) {
-  uint32_t sent = 0;
-
-  while (sent < len) {
-    uint32_t b = write_partial(buf + sent, len - sent);
-    if (b == 0) {
-      // This should only happen if the timeout set with SO_SNDTIMEO expired.
-      // Raise an exception.
-      throw TTransportException(TTransportException::TIMED_OUT,
-                                "send timeout expired");
-    }
-    sent += b;
-  }
-}
-
-uint32_t TSocket::write_partial(const uint8_t* buf, uint32_t len) {
-  if (socket_ < 0) {
-    throw TTransportException(TTransportException::NOT_OPEN, "Called write on non-open socket");
-  }
-
-  uint32_t sent = 0;
-
-  int flags = 0;
-#ifdef MSG_NOSIGNAL
-  // Note the use of MSG_NOSIGNAL to suppress SIGPIPE errors, instead we
-  // check for the EPIPE return condition and close the socket in that case
-  flags |= MSG_NOSIGNAL;
-#endif // ifdef MSG_NOSIGNAL
-
-  int b = send(socket_, const_cast_sockopt(buf + sent), len - sent, flags);
-  ++g_socket_syscalls;
-
-  if (b < 0) {
-    if (errno == EWOULDBLOCK || errno == EAGAIN) {
-      return 0;
-    }
-    // Fail on a send error
-    int errno_copy = errno;
-    GlobalOutput.perror("TSocket::write_partial() send() " + getSocketInfo(), errno_copy);
-
-    if (errno_copy == EPIPE || errno_copy == ECONNRESET || errno_copy == ENOTCONN) {
-      close();
-      throw TTransportException(TTransportException::NOT_OPEN, "write() send()", errno_copy);
-    }
-
-    throw TTransportException(TTransportException::UNKNOWN, "write() send()", errno_copy);
-  }
-  
-  // Fail on blocked send
-  if (b == 0) {
-    throw TTransportException(TTransportException::NOT_OPEN, "Socket send returned 0.");
-  }
-  return b;
-}
-
-std::string TSocket::getHost() {
-  return host_;
-}
-
-int TSocket::getPort() {
-  return port_;
-}
-
-void TSocket::setHost(string host) {
-  host_ = host;
-}
-
-void TSocket::setPort(int port) {
-  port_ = port;
-}
-
-void TSocket::setLinger(bool on, int linger) {
-  lingerOn_ = on;
-  lingerVal_ = linger;
-  if (socket_ < 0) {
-    return;
-  }
-
-  struct linger l = {(lingerOn_ ? 1 : 0), lingerVal_};
-  int ret = setsockopt(socket_, SOL_SOCKET, SO_LINGER, cast_sockopt(&l), sizeof(l));
-  if (ret == -1) {
-    int errno_copy = errno;  // Copy errno because we're allocating memory.
-    GlobalOutput.perror("TSocket::setLinger() setsockopt() " + getSocketInfo(), errno_copy);
-  }
-}
-
-void TSocket::setNoDelay(bool noDelay) {
-  noDelay_ = noDelay;
-  if (socket_ < 0 || !path_.empty()) {
-    return;
-  }
-
-  // Set socket to NODELAY
-  int v = noDelay_ ? 1 : 0;
-  int ret = setsockopt(socket_, IPPROTO_TCP, TCP_NODELAY, cast_sockopt(&v), sizeof(v));
-  if (ret == -1) {
-    int errno_copy = errno;  // Copy errno because we're allocating memory.
-    GlobalOutput.perror("TSocket::setNoDelay() setsockopt() " + getSocketInfo(), errno_copy);
-  }
-}
-
-void TSocket::setConnTimeout(int ms) {
-  connTimeout_ = ms;
-}
-
-void TSocket::setRecvTimeout(int ms) {
-  if (ms < 0) {
-    char errBuf[512];
-    sprintf(errBuf, "TSocket::setRecvTimeout with negative input: %d\n", ms);
-    GlobalOutput(errBuf);
-    return;
-  }
-  recvTimeout_ = ms;
-
-  if (socket_ < 0) {
-    return;
-  }
-
-  recvTimeval_.tv_sec = (int)(recvTimeout_/1000);
-  recvTimeval_.tv_usec = (int)((recvTimeout_%1000)*1000);
-
-  // Copy because poll may modify
-  struct timeval r = recvTimeval_;
-  int ret = setsockopt(socket_, SOL_SOCKET, SO_RCVTIMEO, cast_sockopt(&r), sizeof(r));
-  if (ret == -1) {
-    int errno_copy = errno;  // Copy errno because we're allocating memory.
-    GlobalOutput.perror("TSocket::setRecvTimeout() setsockopt() " + getSocketInfo(), errno_copy);
-  }
-}
-
-void TSocket::setSendTimeout(int ms) {
-  if (ms < 0) {
-    char errBuf[512];
-    sprintf(errBuf, "TSocket::setSendTimeout with negative input: %d\n", ms);
-    GlobalOutput(errBuf);
-    return;
-  }
-  sendTimeout_ = ms;
-
-  if (socket_ < 0) {
-    return;
-  }
-
-  struct timeval s = {(int)(sendTimeout_/1000),
-                      (int)((sendTimeout_%1000)*1000)};
-  int ret = setsockopt(socket_, SOL_SOCKET, SO_SNDTIMEO, cast_sockopt(&s), sizeof(s));
-  if (ret == -1) {
-    int errno_copy = errno;  // Copy errno because we're allocating memory.
-    GlobalOutput.perror("TSocket::setSendTimeout() setsockopt() " + getSocketInfo(), errno_copy);
-  }
-}
-
-void TSocket::setMaxRecvRetries(int maxRecvRetries) {
-  maxRecvRetries_ = maxRecvRetries;
-}
-
-string TSocket::getSocketInfo() {
-  std::ostringstream oss;
-  if (host_.empty() || port_ == 0) {
-    oss << "<Host: " << getPeerAddress();
-    oss << " Port: " << getPeerPort() << ">";
-  } else {
-    oss << "<Host: " << host_ << " Port: " << port_ << ">";
-  }
-  return oss.str();
-}
-
-std::string TSocket::getPeerHost() {
-  if (peerHost_.empty() && path_.empty()) {
-    struct sockaddr_storage addr;
-    struct sockaddr* addrPtr;
-    socklen_t addrLen;
-
-    if (socket_ < 0) {
-      return host_;
-    }
-
-    addrPtr = getCachedAddress(&addrLen);
-
-    if (addrPtr == NULL) {
-      addrLen = sizeof(addr);
-      if (getpeername(socket_, (sockaddr*) &addr, &addrLen) != 0) {
-        return peerHost_;
-      }
-      addrPtr = (sockaddr*)&addr;
-
-      setCachedAddress(addrPtr, addrLen);
-    }
-
-    char clienthost[NI_MAXHOST];
-    char clientservice[NI_MAXSERV];
-
-    getnameinfo((sockaddr*) addrPtr, addrLen,
-                clienthost, sizeof(clienthost),
-                clientservice, sizeof(clientservice), 0);
-
-    peerHost_ = clienthost;
-  }
-  return peerHost_;
-}
-
-std::string TSocket::getPeerAddress() {
-  if (peerAddress_.empty() && path_.empty()) {
-    struct sockaddr_storage addr;
-    struct sockaddr* addrPtr;
-    socklen_t addrLen;
-
-    if (socket_ < 0) {
-      return peerAddress_;
-    }
-
-    addrPtr = getCachedAddress(&addrLen);
-
-    if (addrPtr == NULL) {
-      addrLen = sizeof(addr);
-      if (getpeername(socket_, (sockaddr*) &addr, &addrLen) != 0) {
-        return peerAddress_;
-      }
-      addrPtr = (sockaddr*)&addr;
-
-      setCachedAddress(addrPtr, addrLen);
-    }
-
-    char clienthost[NI_MAXHOST];
-    char clientservice[NI_MAXSERV];
-
-    getnameinfo(addrPtr, addrLen,
-                clienthost, sizeof(clienthost),
-                clientservice, sizeof(clientservice),
-                NI_NUMERICHOST|NI_NUMERICSERV);
-
-    peerAddress_ = clienthost;
-    peerPort_ = std::atoi(clientservice);
-  }
-  return peerAddress_;
-}
-
-int TSocket::getPeerPort() {
-  getPeerAddress();
-  return peerPort_;
-}
-
-void TSocket::setCachedAddress(const sockaddr* addr, socklen_t len) {
-  if (!path_.empty()) {
-    return;
-  }
-
-  switch (addr->sa_family) {
-  case AF_INET:
-    if (len == sizeof(sockaddr_in)) {
-      memcpy((void*)&cachedPeerAddr_.ipv4, (void*)addr, len);
-    }
-    break;
-
-  case AF_INET6:
-    if (len == sizeof(sockaddr_in6)) {
-      memcpy((void*)&cachedPeerAddr_.ipv6, (void*)addr, len);
-    }
-    break;
-  }
-}
-
-sockaddr* TSocket::getCachedAddress(socklen_t* len) const {
-  switch (cachedPeerAddr_.ipv4.sin_family) {
-  case AF_INET:
-    *len = sizeof(sockaddr_in);
-    return (sockaddr*) &cachedPeerAddr_.ipv4;
-
-  case AF_INET6:
-    *len = sizeof(sockaddr_in6);
-    return (sockaddr*) &cachedPeerAddr_.ipv6;
-
-  default:
-    return NULL;
-  }
-} 
-
-bool TSocket::useLowMinRto_ = false;
-void TSocket::setUseLowMinRto(bool useLowMinRto) {
-  useLowMinRto_ = useLowMinRto;
-}
-bool TSocket::getUseLowMinRto() {
-  return useLowMinRto_;
-}
-
-}}} // apache::thrift::transport
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <cstring>
+#include <sstream>
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#ifdef HAVE_SYS_UN_H
+#include <sys/un.h>
+#endif
+#ifdef HAVE_SYS_POLL_H
+#include <sys/poll.h>
+#endif
+#include <sys/types.h>
+#ifdef HAVE_ARPA_INET_H
+#include <arpa/inet.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include <errno.h>
+#include <fcntl.h>
+
+#include "concurrency/Monitor.h"
+#include "TSocket.h"
+#include "TTransportException.h"
+
+#ifndef SOCKOPT_CAST_T
+#   ifndef _WIN32
+#       define SOCKOPT_CAST_T void
+#   else
+#       define SOCKOPT_CAST_T char
+#   endif // _WIN32
+#endif
+
+template<class T>
+inline const SOCKOPT_CAST_T* const_cast_sockopt(const T* v) {
+    return reinterpret_cast<const SOCKOPT_CAST_T*>(v);
+}
+
+template<class T>
+inline SOCKOPT_CAST_T* cast_sockopt(T* v) {
+    return reinterpret_cast<SOCKOPT_CAST_T*>(v);
+}
+
+namespace apache { namespace thrift { namespace transport {
+
+using namespace std;
+
+// Global var to track total socket sys calls
+uint32_t g_socket_syscalls = 0;
+
+/**
+ * TSocket implementation.
+ *
+ */
+
+TSocket::TSocket(string host, int port) :
+  host_(host),
+  port_(port),
+  path_(""),
+  socket_(-1),
+  connTimeout_(0),
+  sendTimeout_(0),
+  recvTimeout_(0),
+  lingerOn_(1),
+  lingerVal_(0),
+  noDelay_(1),
+  maxRecvRetries_(5) {
+  recvTimeval_.tv_sec = (int)(recvTimeout_/1000);
+  recvTimeval_.tv_usec = (int)((recvTimeout_%1000)*1000);
+}
+
+TSocket::TSocket(string path) :
+  host_(""),
+  port_(0),
+  path_(path),
+  socket_(-1),
+  connTimeout_(0),
+  sendTimeout_(0),
+  recvTimeout_(0),
+  lingerOn_(1),
+  lingerVal_(0),
+  noDelay_(1),
+  maxRecvRetries_(5) {
+  recvTimeval_.tv_sec = (int)(recvTimeout_/1000);
+  recvTimeval_.tv_usec = (int)((recvTimeout_%1000)*1000);
+  cachedPeerAddr_.ipv4.sin_family = AF_UNSPEC;
+}
+
+TSocket::TSocket() :
+  host_(""),
+  port_(0),
+  path_(""),
+  socket_(-1),
+  connTimeout_(0),
+  sendTimeout_(0),
+  recvTimeout_(0),
+  lingerOn_(1),
+  lingerVal_(0),
+  noDelay_(1),
+  maxRecvRetries_(5) {
+  recvTimeval_.tv_sec = (int)(recvTimeout_/1000);
+  recvTimeval_.tv_usec = (int)((recvTimeout_%1000)*1000);
+  cachedPeerAddr_.ipv4.sin_family = AF_UNSPEC;
+}
+
+TSocket::TSocket(int socket) :
+  host_(""),
+  port_(0),
+  path_(""),
+  socket_(socket),
+  connTimeout_(0),
+  sendTimeout_(0),
+  recvTimeout_(0),
+  lingerOn_(1),
+  lingerVal_(0),
+  noDelay_(1),
+  maxRecvRetries_(5) {
+  recvTimeval_.tv_sec = (int)(recvTimeout_/1000);
+  recvTimeval_.tv_usec = (int)((recvTimeout_%1000)*1000);
+  cachedPeerAddr_.ipv4.sin_family = AF_UNSPEC;
+}
+
+TSocket::~TSocket() {
+  close();
+}
+
+bool TSocket::isOpen() {
+  return (socket_ >= 0);
+}
+
+bool TSocket::peek() {
+  if (!isOpen()) {
+    return false;
+  }
+  uint8_t buf;
+  int r = recv(socket_, cast_sockopt(&buf), 1, MSG_PEEK);
+  if (r == -1) {
+    int errno_copy = errno;
+    #if defined __FreeBSD__ || defined __MACH__
+    /* shigin:
+     * freebsd returns -1 and ECONNRESET if socket was closed by 
+     * the other side
+     */
+    if (errno_copy == ECONNRESET)
+    {
+      close();
+      return false;
+    }
+    #endif
+    GlobalOutput.perror("TSocket::peek() recv() " + getSocketInfo(), errno_copy);
+    throw TTransportException(TTransportException::UNKNOWN, "recv()", errno_copy);
+  }
+  return (r > 0);
+}
+
+void TSocket::openConnection(struct addrinfo *res) {
+
+  if (isOpen()) {
+    return;
+  }
+
+  if (! path_.empty()) {
+    socket_ = socket(PF_UNIX, SOCK_STREAM, IPPROTO_IP);
+  } else {
+    socket_ = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+  }
+
+  if (socket_ == -1) {
+    int errno_copy = errno;
+    GlobalOutput.perror("TSocket::open() socket() " + getSocketInfo(), errno_copy);
+    throw TTransportException(TTransportException::NOT_OPEN, "socket()", errno_copy);
+  }
+
+  // Send timeout
+  if (sendTimeout_ > 0) {
+    setSendTimeout(sendTimeout_);
+  }
+
+  // Recv timeout
+  if (recvTimeout_ > 0) {
+    setRecvTimeout(recvTimeout_);
+  }
+
+  // Linger
+  setLinger(lingerOn_, lingerVal_);
+
+  // No delay
+  setNoDelay(noDelay_);
+
+  // Uses a low min RTO if asked to.
+#ifdef TCP_LOW_MIN_RTO
+  if (getUseLowMinRto()) {
+    int one = 1;
+    setsockopt(socket_, IPPROTO_TCP, TCP_LOW_MIN_RTO, &one, sizeof(one));
+  }
+#endif
+
+
+  // Set the socket to be non blocking for connect if a timeout exists
+  int flags = fcntl(socket_, F_GETFL, 0);
+  if (connTimeout_ > 0) {
+    if (-1 == fcntl(socket_, F_SETFL, flags | O_NONBLOCK)) {
+      int errno_copy = errno;
+      GlobalOutput.perror("TSocket::open() fcntl() " + getSocketInfo(), errno_copy);
+      throw TTransportException(TTransportException::NOT_OPEN, "fcntl() failed", errno_copy);
+    }
+  } else {
+    if (-1 == fcntl(socket_, F_SETFL, flags & ~O_NONBLOCK)) {
+      int errno_copy = errno;
+      GlobalOutput.perror("TSocket::open() fcntl " + getSocketInfo(), errno_copy);
+      throw TTransportException(TTransportException::NOT_OPEN, "fcntl() failed", errno_copy);
+    }
+  }
+
+  // Connect the socket
+  int ret;
+  if (! path_.empty()) {
+
+#ifndef _WIN32
+
+    struct sockaddr_un address;
+    socklen_t len;
+
+    if (path_.length() > sizeof(address.sun_path)) {
+      int errno_copy = errno;
+      GlobalOutput.perror("TSocket::open() Unix Domain socket path too long", errno_copy);
+      throw TTransportException(TTransportException::NOT_OPEN, " Unix Domain socket path too long");
+    }
+
+    address.sun_family = AF_UNIX;
+    snprintf(address.sun_path, sizeof(address.sun_path), "%s", path_.c_str());
+    len = sizeof(address);
+    ret = connect(socket_, (struct sockaddr *) &address, len);
+
+#else
+      GlobalOutput.perror("TSocket::open() Unix Domain socket path not supported on windows", -99);
+      throw TTransportException(TTransportException::NOT_OPEN, " Unix Domain socket path not supported");
+#endif
+
+  } else {
+    ret = connect(socket_, res->ai_addr, res->ai_addrlen);
+  }
+
+  // success case
+  if (ret == 0) {
+    goto done;
+  }
+
+  if ((errno != EINPROGRESS) && (errno != EWOULDBLOCK)) {
+    int errno_copy = errno;
+    GlobalOutput.perror("TSocket::open() connect() " + getSocketInfo(), errno_copy);
+    throw TTransportException(TTransportException::NOT_OPEN, "connect() failed", errno_copy);
+  }
+
+
+  struct pollfd fds[1];
+  std::memset(fds, 0 , sizeof(fds));
+  fds[0].fd = socket_;
+  fds[0].events = POLLOUT;
+  ret = poll(fds, 1, connTimeout_);
+
+  if (ret > 0) {
+    // Ensure the socket is connected and that there are no errors set
+    int val;
+    socklen_t lon;
+    lon = sizeof(int);
+    int ret2 = getsockopt(socket_, SOL_SOCKET, SO_ERROR, cast_sockopt(&val), &lon);
+    if (ret2 == -1) {
+      int errno_copy = errno;
+      GlobalOutput.perror("TSocket::open() getsockopt() " + getSocketInfo(), errno_copy);
+      throw TTransportException(TTransportException::NOT_OPEN, "getsockopt()", errno_copy);
+    }
+    // no errors on socket, go to town
+    if (val == 0) {
+      goto done;
+    }
+    GlobalOutput.perror("TSocket::open() error on socket (after poll) " + getSocketInfo(), val);
+    throw TTransportException(TTransportException::NOT_OPEN, "socket open() error", val);
+  } else if (ret == 0) {
+    // socket timed out
+    string errStr = "TSocket::open() timed out " + getSocketInfo();
+    GlobalOutput(errStr.c_str());
+    throw TTransportException(TTransportException::NOT_OPEN, "open() timed out");
+  } else {
+    // error on poll()
+    int errno_copy = errno;
+    GlobalOutput.perror("TSocket::open() poll() " + getSocketInfo(), errno_copy);
+    throw TTransportException(TTransportException::NOT_OPEN, "poll() failed", errno_copy);
+  }
+
+ done:
+  // Set socket back to normal mode (blocking)
+  fcntl(socket_, F_SETFL, flags);
+
+  if (path_.empty()) {
+    setCachedAddress(res->ai_addr, res->ai_addrlen);
+  }
+}
+
+void TSocket::open() {
+  if (isOpen()) {
+    return;
+  }
+  if (! path_.empty()) {
+    unix_open();
+  } else {
+    local_open();
+  }
+}
+
+void TSocket::unix_open(){
+  if (! path_.empty()) {
+    // Unix Domain SOcket does not need addrinfo struct, so we pass NULL
+    openConnection(NULL);
+  }
+}
+
+void TSocket::local_open(){
+
+#ifdef _WIN32
+    TWinsockSingleton::create();
+#endif // _WIN32
+
+  if (isOpen()) {
+    return;
+  }
+
+  // Validate port number
+  if (port_ < 0 || port_ > 0xFFFF) {
+    throw TTransportException(TTransportException::NOT_OPEN, "Specified port is invalid");
+  }
+
+  struct addrinfo hints, *res, *res0;
+  res = NULL;
+  res0 = NULL;
+  int error;
+  char port[sizeof("65535")];
+  std::memset(&hints, 0, sizeof(hints));
+  hints.ai_family = PF_UNSPEC;
+  hints.ai_socktype = SOCK_STREAM;
+  hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;
+  sprintf(port, "%d", port_);
+
+  error = getaddrinfo(host_.c_str(), port, &hints, &res0);
+
+  if (error) {
+    string errStr = "TSocket::open() getaddrinfo() " + getSocketInfo() + string(gai_strerror(error));
+    GlobalOutput(errStr.c_str());
+    close();
+    throw TTransportException(TTransportException::NOT_OPEN, "Could not resolve host for client socket.");
+  }
+
+  // Cycle through all the returned addresses until one
+  // connects or push the exception up.
+  for (res = res0; res; res = res->ai_next) {
+    try {
+      openConnection(res);
+      break;
+    } catch (TTransportException& ttx) {
+      if (res->ai_next) {
+        close();
+      } else {
+        close();
+        freeaddrinfo(res0); // cleanup on failure
+        throw;
+      }
+    }
+  }
+
+  // Free address structure memory
+  freeaddrinfo(res0);
+}
+
+void TSocket::close() {
+  if (socket_ >= 0) {
+
+#ifdef _WIN32
+      shutdown(socket_, SD_BOTH);
+      ::closesocket(socket_);
+#else
+      shutdown(socket_, SHUT_RDWR);
+      ::close(socket_);
+#endif
+
+  }
+  socket_ = -1;
+}
+
+void TSocket::setSocketFD(int socket) {
+  if (socket_ >= 0) {
+    close();
+  }
+  socket_ = socket;
+}
+
+uint32_t TSocket::read(uint8_t* buf, uint32_t len) {
+  if (socket_ < 0) {
+    throw TTransportException(TTransportException::NOT_OPEN, "Called read on non-open socket");
+  }
+
+  int32_t retries = 0;
+
+  // EAGAIN can be signalled both when a timeout has occurred and when
+  // the system is out of resources (an awesome undocumented feature).
+  // The following is an approximation of the time interval under which
+  // EAGAIN is taken to indicate an out of resources error.
+  uint32_t eagainThresholdMicros = 0;
+  if (recvTimeout_) {
+    // if a readTimeout is specified along with a max number of recv retries, then
+    // the threshold will ensure that the read timeout is not exceeded even in the
+    // case of resource errors
+    eagainThresholdMicros = (recvTimeout_*1000)/ ((maxRecvRetries_>0) ? maxRecvRetries_ : 2);
+  }
+
+ try_again:
+  // Read from the socket
+  struct timeval begin;
+  if (recvTimeout_ > 0) {
+    gettimeofday(&begin, NULL);
+  } else {
+    // if there is no read timeout we don't need the TOD to determine whether
+    // an EAGAIN is due to a timeout or an out-of-resource condition.
+    begin.tv_sec = begin.tv_usec = 0;
+  }
+  int got = recv(socket_, cast_sockopt(buf), len, 0);
+  int errno_copy = errno; //gettimeofday can change errno
+  ++g_socket_syscalls;
+
+  // Check for error on read
+  if (got < 0) {
+    if (errno_copy == EAGAIN) {
+      // if no timeout we can assume that resource exhaustion has occurred.
+      if (recvTimeout_ == 0) {
+        throw TTransportException(TTransportException::TIMED_OUT,
+                                    "EAGAIN (unavailable resources)");
+      }
+      // check if this is the lack of resources or timeout case
+      struct timeval end;
+      gettimeofday(&end, NULL);
+      uint32_t readElapsedMicros =  (((end.tv_sec - begin.tv_sec) * 1000 * 1000)
+                                     + (((uint64_t)(end.tv_usec - begin.tv_usec))));
+
+      if (!eagainThresholdMicros || (readElapsedMicros < eagainThresholdMicros)) {
+        if (retries++ < maxRecvRetries_) {
+          thrift_usleep(50);
+          goto try_again;
+        } else {
+          throw TTransportException(TTransportException::TIMED_OUT,
+                                    "EAGAIN (unavailable resources)");
+        }
+      } else {
+        // infer that timeout has been hit
+        throw TTransportException(TTransportException::TIMED_OUT,
+                                  "EAGAIN (timed out)");
+      }
+    }
+
+    // If interrupted, try again
+    if (errno_copy == EINTR && retries++ < maxRecvRetries_) {
+      goto try_again;
+    }
+
+    #if defined __FreeBSD__ || defined __MACH__
+    if (errno_copy == ECONNRESET) {
+      /* shigin: freebsd doesn't follow POSIX semantic of recv and fails with
+       * ECONNRESET if peer performed shutdown 
+       * edhall: eliminated close() since we do that in the destructor.
+       */
+      return 0;
+    }
+    #endif
+
+#ifdef _WIN32
+    if(errno_copy == WSAECONNRESET) {
+      return 0; // EOF
+    }
+#endif
+
+    // Now it's not a try again case, but a real probblez
+    GlobalOutput.perror("TSocket::read() recv() " + getSocketInfo(), errno_copy);
+
+    // If we disconnect with no linger time
+    if (errno_copy == ECONNRESET) {
+      throw TTransportException(TTransportException::NOT_OPEN, "ECONNRESET");
+    }
+
+    // This ish isn't open
+    if (errno_copy == ENOTCONN) {
+      throw TTransportException(TTransportException::NOT_OPEN, "ENOTCONN");
+    }
+
+    // Timed out!
+    if (errno_copy == ETIMEDOUT) {
+      throw TTransportException(TTransportException::TIMED_OUT, "ETIMEDOUT");
+    }
+
+    // Some other error, whatevz
+    throw TTransportException(TTransportException::UNKNOWN, "Unknown", errno_copy);
+  }
+
+  // The remote host has closed the socket
+  if (got == 0) {
+    // edhall: we used to call close() here, but our caller may want to deal
+    // with the socket fd and we'll close() in our destructor in any case.
+    return 0;
+  }
+
+  // Pack data into string
+  return got;
+}
+
+void TSocket::write(const uint8_t* buf, uint32_t len) {
+  uint32_t sent = 0;
+
+  while (sent < len) {
+    uint32_t b = write_partial(buf + sent, len - sent);
+    if (b == 0) {
+      // This should only happen if the timeout set with SO_SNDTIMEO expired.
+      // Raise an exception.
+      throw TTransportException(TTransportException::TIMED_OUT,
+                                "send timeout expired");
+    }
+    sent += b;
+  }
+}
+
+uint32_t TSocket::write_partial(const uint8_t* buf, uint32_t len) {
+  if (socket_ < 0) {
+    throw TTransportException(TTransportException::NOT_OPEN, "Called write on non-open socket");
+  }
+
+  uint32_t sent = 0;
+
+  int flags = 0;
+#ifdef MSG_NOSIGNAL
+  // Note the use of MSG_NOSIGNAL to suppress SIGPIPE errors, instead we
+  // check for the EPIPE return condition and close the socket in that case
+  flags |= MSG_NOSIGNAL;
+#endif // ifdef MSG_NOSIGNAL
+
+  int b = send(socket_, const_cast_sockopt(buf + sent), len - sent, flags);
+  ++g_socket_syscalls;
+
+  if (b < 0) {
+    if (errno == EWOULDBLOCK || errno == EAGAIN) {
+      return 0;
+    }
+    // Fail on a send error
+    int errno_copy = errno;
+    GlobalOutput.perror("TSocket::write_partial() send() " + getSocketInfo(), errno_copy);
+
+    if (errno_copy == EPIPE || errno_copy == ECONNRESET || errno_copy == ENOTCONN) {
+      close();
+      throw TTransportException(TTransportException::NOT_OPEN, "write() send()", errno_copy);
+    }
+
+    throw TTransportException(TTransportException::UNKNOWN, "write() send()", errno_copy);
+  }
+  
+  // Fail on blocked send
+  if (b == 0) {
+    throw TTransportException(TTransportException::NOT_OPEN, "Socket send returned 0.");
+  }
+  return b;
+}
+
+std::string TSocket::getHost() {
+  return host_;
+}
+
+int TSocket::getPort() {
+  return port_;
+}
+
+void TSocket::setHost(string host) {
+  host_ = host;
+}
+
+void TSocket::setPort(int port) {
+  port_ = port;
+}
+
+void TSocket::setLinger(bool on, int linger) {
+  lingerOn_ = on;
+  lingerVal_ = linger;
+  if (socket_ < 0) {
+    return;
+  }
+
+  struct linger l = {(lingerOn_ ? 1 : 0), lingerVal_};
+  int ret = setsockopt(socket_, SOL_SOCKET, SO_LINGER, cast_sockopt(&l), sizeof(l));
+  if (ret == -1) {
+    int errno_copy = errno;  // Copy errno because we're allocating memory.
+    GlobalOutput.perror("TSocket::setLinger() setsockopt() " + getSocketInfo(), errno_copy);
+  }
+}
+
+void TSocket::setNoDelay(bool noDelay) {
+  noDelay_ = noDelay;
+  if (socket_ < 0 || !path_.empty()) {
+    return;
+  }
+
+  // Set socket to NODELAY
+  int v = noDelay_ ? 1 : 0;
+  int ret = setsockopt(socket_, IPPROTO_TCP, TCP_NODELAY, cast_sockopt(&v), sizeof(v));
+  if (ret == -1) {
+    int errno_copy = errno;  // Copy errno because we're allocating memory.
+    GlobalOutput.perror("TSocket::setNoDelay() setsockopt() " + getSocketInfo(), errno_copy);
+  }
+}
+
+void TSocket::setConnTimeout(int ms) {
+  connTimeout_ = ms;
+}
+
+void TSocket::setRecvTimeout(int ms) {
+  if (ms < 0) {
+    char errBuf[512];
+    sprintf(errBuf, "TSocket::setRecvTimeout with negative input: %d\n", ms);
+    GlobalOutput(errBuf);
+    return;
+  }
+  recvTimeout_ = ms;
+
+  if (socket_ < 0) {
+    return;
+  }
+
+  recvTimeval_.tv_sec = (int)(recvTimeout_/1000);
+  recvTimeval_.tv_usec = (int)((recvTimeout_%1000)*1000);
+
+  // Copy because poll may modify
+  struct timeval r = recvTimeval_;
+  int ret = setsockopt(socket_, SOL_SOCKET, SO_RCVTIMEO, cast_sockopt(&r), sizeof(r));
+  if (ret == -1) {
+    int errno_copy = errno;  // Copy errno because we're allocating memory.
+    GlobalOutput.perror("TSocket::setRecvTimeout() setsockopt() " + getSocketInfo(), errno_copy);
+  }
+}
+
+void TSocket::setSendTimeout(int ms) {
+  if (ms < 0) {
+    char errBuf[512];
+    sprintf(errBuf, "TSocket::setSendTimeout with negative input: %d\n", ms);
+    GlobalOutput(errBuf);
+    return;
+  }
+  sendTimeout_ = ms;
+
+  if (socket_ < 0) {
+    return;
+  }
+
+  struct timeval s = {(int)(sendTimeout_/1000),
+                      (int)((sendTimeout_%1000)*1000)};
+  int ret = setsockopt(socket_, SOL_SOCKET, SO_SNDTIMEO, cast_sockopt(&s), sizeof(s));
+  if (ret == -1) {
+    int errno_copy = errno;  // Copy errno because we're allocating memory.
+    GlobalOutput.perror("TSocket::setSendTimeout() setsockopt() " + getSocketInfo(), errno_copy);
+  }
+}
+
+void TSocket::setMaxRecvRetries(int maxRecvRetries) {
+  maxRecvRetries_ = maxRecvRetries;
+}
+
+string TSocket::getSocketInfo() {
+  std::ostringstream oss;
+  if (host_.empty() || port_ == 0) {
+    oss << "<Host: " << getPeerAddress();
+    oss << " Port: " << getPeerPort() << ">";
+  } else {
+    oss << "<Host: " << host_ << " Port: " << port_ << ">";
+  }
+  return oss.str();
+}
+
+std::string TSocket::getPeerHost() {
+  if (peerHost_.empty() && path_.empty()) {
+    struct sockaddr_storage addr;
+    struct sockaddr* addrPtr;
+    socklen_t addrLen;
+
+    if (socket_ < 0) {
+      return host_;
+    }
+
+    addrPtr = getCachedAddress(&addrLen);
+
+    if (addrPtr == NULL) {
+      addrLen = sizeof(addr);
+      if (getpeername(socket_, (sockaddr*) &addr, &addrLen) != 0) {
+        return peerHost_;
+      }
+      addrPtr = (sockaddr*)&addr;
+
+      setCachedAddress(addrPtr, addrLen);
+    }
+
+    char clienthost[NI_MAXHOST];
+    char clientservice[NI_MAXSERV];
+
+    getnameinfo((sockaddr*) addrPtr, addrLen,
+                clienthost, sizeof(clienthost),
+                clientservice, sizeof(clientservice), 0);
+
+    peerHost_ = clienthost;
+  }
+  return peerHost_;
+}
+
+std::string TSocket::getPeerAddress() {
+  if (peerAddress_.empty() && path_.empty()) {
+    struct sockaddr_storage addr;
+    struct sockaddr* addrPtr;
+    socklen_t addrLen;
+
+    if (socket_ < 0) {
+      return peerAddress_;
+    }
+
+    addrPtr = getCachedAddress(&addrLen);
+
+    if (addrPtr == NULL) {
+      addrLen = sizeof(addr);
+      if (getpeername(socket_, (sockaddr*) &addr, &addrLen) != 0) {
+        return peerAddress_;
+      }
+      addrPtr = (sockaddr*)&addr;
+
+      setCachedAddress(addrPtr, addrLen);
+    }
+
+    char clienthost[NI_MAXHOST];
+    char clientservice[NI_MAXSERV];
+
+    getnameinfo(addrPtr, addrLen,
+                clienthost, sizeof(clienthost),
+                clientservice, sizeof(clientservice),
+                NI_NUMERICHOST|NI_NUMERICSERV);
+
+    peerAddress_ = clienthost;
+    peerPort_ = std::atoi(clientservice);
+  }
+  return peerAddress_;
+}
+
+int TSocket::getPeerPort() {
+  getPeerAddress();
+  return peerPort_;
+}
+
+void TSocket::setCachedAddress(const sockaddr* addr, socklen_t len) {
+  if (!path_.empty()) {
+    return;
+  }
+
+  switch (addr->sa_family) {
+  case AF_INET:
+    if (len == sizeof(sockaddr_in)) {
+      memcpy((void*)&cachedPeerAddr_.ipv4, (void*)addr, len);
+    }
+    break;
+
+  case AF_INET6:
+    if (len == sizeof(sockaddr_in6)) {
+      memcpy((void*)&cachedPeerAddr_.ipv6, (void*)addr, len);
+    }
+    break;
+  }
+}
+
+sockaddr* TSocket::getCachedAddress(socklen_t* len) const {
+  switch (cachedPeerAddr_.ipv4.sin_family) {
+  case AF_INET:
+    *len = sizeof(sockaddr_in);
+    return (sockaddr*) &cachedPeerAddr_.ipv4;
+
+  case AF_INET6:
+    *len = sizeof(sockaddr_in6);
+    return (sockaddr*) &cachedPeerAddr_.ipv6;
+
+  default:
+    return NULL;
+  }
+} 
+
+bool TSocket::useLowMinRto_ = false;
+void TSocket::setUseLowMinRto(bool useLowMinRto) {
+  useLowMinRto_ = useLowMinRto;
+}
+bool TSocket::getUseLowMinRto() {
+  return useLowMinRto_;
+}
+
+}}} // apache::thrift::transport
--- lib/cpp/src/concurrency/FunctionRunner.h	Sat Nov 26 11:00:42 2011
+++ lib/cpp/src/concurrency/FunctionRunner.h	Thu Nov 30 14:26:50 2017
@@ -1,102 +1,102 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements. See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership. The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-#ifndef _THRIFT_CONCURRENCY_FUNCTION_RUNNER_H
-#define _THRIFT_CONCURRENCY_FUNCTION_RUNNER_H 1
-
-#include <tr1/functional>
-#include "thrift/lib/cpp/concurrency/Thread.h"
-
-namespace apache { namespace thrift { namespace concurrency {
-
-/**
- * Convenient implementation of Runnable that will execute arbitrary callbacks.
- * Interfaces are provided to accept both a generic 'void(void)' callback, and
- * a 'void* (void*)' pthread_create-style callback.
- *
- * Example use:
- *  void* my_thread_main(void* arg);
- *  shared_ptr<ThreadFactory> factory = ...;
- *  // To create a thread that executes my_thread_main once:
- *  shared_ptr<Thread> thread =
- *    factory->newThread(shared_ptr<FunctionRunner>(
- *      new FunctionRunner(my_thread_main, some_argument)));
- *  thread->start();
- *
- *  bool A::foo();
- *  A* a = new A();
- *  // To create a thread that executes a.foo() every 100 milliseconds:
- *  factory->newThread(shared_ptr<FunctionRunner>(
- *    new FunctionRunner(std::tr1::bind(&A::foo, a), 100)))->start();
- *
- */
-
-class FunctionRunner : public Runnable {
- public:
-  // This is the type of callback 'pthread_create()' expects.
-  typedef void* (*PthreadFuncPtr)(void *arg);
-  // This a fully-generic void(void) callback for custom bindings.
-  typedef std::tr1::function<void()> VoidFunc;
-
-  typedef std::tr1::function<bool()> BoolFunc;
-
-  /**
-   * Given a 'pthread_create' style callback, this FunctionRunner will
-   * execute the given callback.  Note that the 'void*' return value is ignored.
-   */
-  FunctionRunner(PthreadFuncPtr func, void* arg)
-   : func_(std::tr1::bind(func, arg)), repFunc_(0)
-  { }
-
-  /**
-   * Given a generic callback, this FunctionRunner will execute it.
-   */
-  FunctionRunner(const VoidFunc& cob)
-   : func_(cob), repFunc_(0)
-  { }
-
-  /**
-   * Given a bool foo(...) type callback, FunctionRunner will execute
-   * the callback repeatedly with 'intervalMs' milliseconds between the calls,
-   * until it returns false. Note that the actual interval between calls will
-   * be intervalMs plus execution time of the callback.
-   */
-  FunctionRunner(const BoolFunc& cob, int intervalMs)
-   : func_(0), repFunc_(cob), intervalMs_(intervalMs)
-  { }
-
-  void run() {
-    if (repFunc_) {
-      while(repFunc_()) {
-        usleep(intervalMs_*1000);
-      }
-    } else {
-      func_();
-    }
-  }
-
- private:
-  VoidFunc func_;
-  BoolFunc repFunc_;
-  int intervalMs_;
-};
-
-}}} // apache::thrift::concurrency
-
-#endif // #ifndef _THRIFT_CONCURRENCY_FUNCTION_RUNNER_H
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#ifndef _THRIFT_CONCURRENCY_FUNCTION_RUNNER_H
+#define _THRIFT_CONCURRENCY_FUNCTION_RUNNER_H 1
+
+#include <tr1/functional>
+#include "thrift/lib/cpp/concurrency/Thread.h"
+
+namespace apache { namespace thrift { namespace concurrency {
+
+/**
+ * Convenient implementation of Runnable that will execute arbitrary callbacks.
+ * Interfaces are provided to accept both a generic 'void(void)' callback, and
+ * a 'void* (void*)' pthread_create-style callback.
+ *
+ * Example use:
+ *  void* my_thread_main(void* arg);
+ *  shared_ptr<ThreadFactory> factory = ...;
+ *  // To create a thread that executes my_thread_main once:
+ *  shared_ptr<Thread> thread =
+ *    factory->newThread(shared_ptr<FunctionRunner>(
+ *      new FunctionRunner(my_thread_main, some_argument)));
+ *  thread->start();
+ *
+ *  bool A::foo();
+ *  A* a = new A();
+ *  // To create a thread that executes a.foo() every 100 milliseconds:
+ *  factory->newThread(shared_ptr<FunctionRunner>(
+ *    new FunctionRunner(std::tr1::bind(&A::foo, a), 100)))->start();
+ *
+ */
+
+class FunctionRunner : public Runnable {
+ public:
+  // This is the type of callback 'pthread_create()' expects.
+  typedef void* (*PthreadFuncPtr)(void *arg);
+  // This a fully-generic void(void) callback for custom bindings.
+  typedef std::tr1::function<void()> VoidFunc;
+
+  typedef std::tr1::function<bool()> BoolFunc;
+
+  /**
+   * Given a 'pthread_create' style callback, this FunctionRunner will
+   * execute the given callback.  Note that the 'void*' return value is ignored.
+   */
+  FunctionRunner(PthreadFuncPtr func, void* arg)
+   : func_(std::tr1::bind(func, arg)), repFunc_(0)
+  { }
+
+  /**
+   * Given a generic callback, this FunctionRunner will execute it.
+   */
+  FunctionRunner(const VoidFunc& cob)
+   : func_(cob), repFunc_(0)
+  { }
+
+  /**
+   * Given a bool foo(...) type callback, FunctionRunner will execute
+   * the callback repeatedly with 'intervalMs' milliseconds between the calls,
+   * until it returns false. Note that the actual interval between calls will
+   * be intervalMs plus execution time of the callback.
+   */
+  FunctionRunner(const BoolFunc& cob, int intervalMs)
+   : func_(0), repFunc_(cob), intervalMs_(intervalMs)
+  { }
+
+  void run() {
+    if (repFunc_) {
+      while(repFunc_()) {
+        thrift_usleep(intervalMs_*1000);
+      }
+    } else {
+      func_();
+    }
+  }
+
+ private:
+  VoidFunc func_;
+  BoolFunc repFunc_;
+  int intervalMs_;
+};
+
+}}} // apache::thrift::concurrency
+
+#endif // #ifndef _THRIFT_CONCURRENCY_FUNCTION_RUNNER_H
--- lib/cpp/src/windows/config.h	Sat Nov 26 11:47:26 2011
+++ lib/cpp/src/windows/config.h	Thu Nov 30 14:26:50 2017
@@ -1,108 +1,110 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements. See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership. The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-#ifndef _THRIFT_WINDOWS_CONFIG_H_
-#define _THRIFT_WINDOWS_CONFIG_H_ 1
-
-#if defined(_MSC_VER) && (_MSC_VER > 1200)
-#pragma once
-#endif // _MSC_VER
-
-#ifndef _WIN32
-#error This is a MSVC header only.
-#endif
-
-#pragma warning(disable: 4996) // Depreciated posix name.
-#pragma warning(disable: 4250) // Inherits via dominance.
-
-#define VERSION "0.8.0"
-#define HAVE_GETTIMEOFDAY 1
-#define HAVE_SYS_STAT_H 1
-
-#include "TargetVersion.h"
-#include "GetTimeOfDay.h"
-#include "Operators.h"
-#include "TWinsockSingleton.h"
-#include "WinFcntl.h"
-#include "SocketPair.h"
-
-// boost
-#include <boost/cstdint.hpp>
-
-typedef boost::int64_t  int64_t;
-typedef boost::uint32_t uint32_t;
-typedef boost::uint8_t  uint8_t;
-
-// windows
-#include <Winsock2.h>
-#include <ws2tcpip.h>
-#pragma comment(lib, "Ws2_32.lib")
-
-// pthreads
-#if 0
-#	include <pthread.h>
-#else
-struct timespec {
-	int64_t tv_sec;
-	int64_t tv_nsec;
-};
-#	define USE_BOOST_THREAD 1
-#	define ctime_r( _clock, _buf ) \
-        ( strcpy( (_buf), ctime( (_clock) ) ),  \
-          (_buf) )
-#endif
-
-typedef ptrdiff_t ssize_t;
-
-// Missing functions.
-#define usleep(ms) Sleep(ms)
-
-#if WINVER <= 0x0502
-#define poll(fds, nfds, timeout) \
-    poll_win32(fds, nfds, timeout)
-
-inline int poll_win32(LPWSAPOLLFD fdArray, ULONG fds, INT timeout)
-{
-    fd_set read_fds;
-    fd_set write_fds;
-    fd_set except_fds;
-
-    FD_ZERO(&read_fds);
-    FD_ZERO(&write_fds);
-    FD_ZERO(&except_fds);
-
-    FD_SET(fdArray[0].fd, &read_fds);
-    FD_SET(fdArray[0].fd, &write_fds);
-    FD_SET(fdArray[0].fd, &except_fds);
-
-    timeval time_out = {timeout * 0.001, timeout * 1000};
-    return select(1, &read_fds, &write_fds, &except_fds, &time_out);
-}
-#else
-	inline int poll(struct pollfd* fdArray, ULONG fds, INT timeout) {
-		return WSAPoll(fdArray, fds, timeout);
-	}
-#endif // WINVER
-
-inline void close(SOCKET socket)
-{
-    ::closesocket(socket);
-}
-
-#endif // _THRIFT_WINDOWS_CONFIG_H_
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#ifndef _THRIFT_WINDOWS_CONFIG_H_
+#define _THRIFT_WINDOWS_CONFIG_H_ 1
+
+#if defined(_MSC_VER) && (_MSC_VER > 1200)
+#pragma once
+#endif // _MSC_VER
+
+#ifndef _WIN32
+#error This is a MSVC header only.
+#endif
+
+#pragma warning(disable: 4996) // Depreciated posix name.
+#pragma warning(disable: 4250) // Inherits via dominance.
+
+#define VERSION "0.8.0"
+#define HAVE_GETTIMEOFDAY 1
+#define HAVE_SYS_STAT_H 1
+
+#include "TargetVersion.h"
+#include "GetTimeOfDay.h"
+#include "Operators.h"
+#include "TWinsockSingleton.h"
+#include "WinFcntl.h"
+#include "SocketPair.h"
+
+// boost
+#include <boost/cstdint.hpp>
+
+typedef boost::int64_t  int64_t;
+typedef boost::uint32_t uint32_t;
+typedef boost::uint8_t  uint8_t;
+
+// windows
+#include <Winsock2.h>
+#include <ws2tcpip.h>
+#pragma comment(lib, "Ws2_32.lib")
+
+// pthreads
+#if 0
+#	include <pthread.h>
+#else
+#ifndef _WINDOWS
+struct timespec {
+	int64_t tv_sec;
+	int64_t tv_nsec;
+};
+#endif
+#	define USE_BOOST_THREAD 1
+#	define ctime_r( _clock, _buf ) \
+        ( strcpy( (_buf), ctime( (_clock) ) ),  \
+          (_buf) )
+#endif
+
+typedef ptrdiff_t ssize_t;
+
+// Missing functions.
+#define thrift_usleep(ms) Sleep(ms)
+
+#if WINVER <= 0x0502
+#define poll(fds, nfds, timeout) \
+    poll_win32(fds, nfds, timeout)
+
+inline int poll_win32(LPWSAPOLLFD fdArray, ULONG fds, INT timeout)
+{
+    fd_set read_fds;
+    fd_set write_fds;
+    fd_set except_fds;
+
+    FD_ZERO(&read_fds);
+    FD_ZERO(&write_fds);
+    FD_ZERO(&except_fds);
+
+    FD_SET(fdArray[0].fd, &read_fds);
+    FD_SET(fdArray[0].fd, &write_fds);
+    FD_SET(fdArray[0].fd, &except_fds);
+
+    timeval time_out = {timeout * 0.001, timeout * 1000};
+    return select(1, &read_fds, &write_fds, &except_fds, &time_out);
+}
+#else
+	inline int poll(struct pollfd* fdArray, ULONG fds, INT timeout) {
+		return WSAPoll(fdArray, fds, timeout);
+	}
+#endif // WINVER
+
+inline void close(SOCKET socket)
+{
+    ::closesocket(socket);
+}
+
+#endif // _THRIFT_WINDOWS_CONFIG_H_
--- lib/cpp/src/windows/TWinsockSingleton.h	Sat Nov 26 11:00:42 2011
+++ lib/cpp/src/windows/TWinsockSingleton.h	Wed Oct 11 15:45:33 2017
@@ -1,77 +1,77 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements. See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership. The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-#ifndef _THRIFT_TRANSPORT_WINDOWS_TWINSOCKSINGLETON_H_
-#define _THRIFT_TRANSPORT_WINDOWS_TWINSOCKSINGLETON_H_ 1
-
-#if defined(_MSC_VER) && (_MSC_VER > 1200)
-#pragma once
-#endif // _MSC_VER
-
-#ifndef _WIN32
-#error This is a MSVC header only.
-#endif
-
-// boost
-#include <boost/noncopyable.hpp>
-#include <boost/scoped_ptr.hpp>
-#include <boost/thread/once.hpp>
-
-namespace apache { namespace thrift { namespace transport {
-
-/**
- * Winsock2 must be intialised once only in order to create sockets. This class
- * performs a one time initialisation when create is called.
- */
-class TWinsockSingleton : private boost::noncopyable
-{
-
-public:
-
-    typedef boost::scoped_ptr<TWinsockSingleton> instance_ptr;
-
-private:
-
-    friend void boost::call_once(void (*func)(void), boost::once_flag& flag);
-
-private:
-
-    TWinsockSingleton(void);
-
-public:
-
-    ~TWinsockSingleton(void);
-
-public:
-
-    static void create(void);
-
-private:
-
-    static void init(void);
-
-private:
-
-    static instance_ptr     instance_ptr_;
-    static boost::once_flag flags_;
-};
-
-}}} // apache::thrift::transport
-
-#endif // _THRIFT_TRANSPORT_WINDOWS_TWINSOCKSINGLETON_H_
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#ifndef _THRIFT_TRANSPORT_WINDOWS_TWINSOCKSINGLETON_H_
+#define _THRIFT_TRANSPORT_WINDOWS_TWINSOCKSINGLETON_H_ 1
+
+#if defined(_MSC_VER) && (_MSC_VER > 1200)
+#pragma once
+#endif // _MSC_VER
+
+#ifndef _WIN32
+#error This is a MSVC header only.
+#endif
+
+// boost
+#include <boost/noncopyable.hpp>
+#include <boost/scoped_ptr.hpp>
+#include <boost/thread/once.hpp>
+
+namespace apache { namespace thrift { namespace transport {
+
+/**
+ * Winsock2 must be intialised once only in order to create sockets. This class
+ * performs a one time initialisation when create is called.
+ */
+class TWinsockSingleton : private boost::noncopyable
+{
+
+public:
+
+    typedef boost::scoped_ptr<TWinsockSingleton> instance_ptr;
+
+private:
+#ifndef _WINDOWS
+    friend void boost::call_once(void (*func)(void), boost::once_flag& flag);
+#endif
+private:
+
+    TWinsockSingleton(void);
+
+public:
+
+    ~TWinsockSingleton(void);
+
+public:
+
+    static void create(void);
+
+private:
+
+    static void init(void);
+
+private:
+
+    static instance_ptr     instance_ptr_;
+    static boost::once_flag flags_;
+};
+
+}}} // apache::thrift::transport
+
+#endif // _THRIFT_TRANSPORT_WINDOWS_TWINSOCKSINGLETON_H_
--- lib/cpp/src/Thrift.h	Wed Sep 21 13:52:44 2016
+++ lib/cpp/src/Thrift.h	Wed Oct 11 15:45:33 2017
@@ -1,217 +1,220 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements. See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership. The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-#ifndef _THRIFT_THRIFT_H_
-#define _THRIFT_THRIFT_H_ 1
-
-#ifdef _WIN32
-#include "windows/config.h"
-#endif
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-#include <stdio.h>
-#include <assert.h>
-
-#include <sys/types.h>
-#ifdef HAVE_NETINET_IN_H
-#include <netinet/in.h>
-#endif
-#ifdef HAVE_INTTYPES_H
-#include <inttypes.h>
-#endif
-
-/**
- * CONTRAIL-CUSTOM
- */
-#include <netinet/in.h>
-#include <sys/socket.h>
-
-#include <string>
-#include <map>
-#include <list>
-#include <set>
-#include <vector>
-#include <exception>
-#include <typeinfo>
-
-#include <boost/utility/enable_if.hpp>
-#include <boost/type_traits/is_convertible.hpp>
-
-#include "TLogging.h"
-
-/**
- * Helper macros to allow function overloading even when using
- * boost::shared_ptr.
- *
- * shared_ptr makes overloading really annoying, since shared_ptr defines
- * constructor methods to allow one shared_ptr type to be constructed from any
- * other shared_ptr type.  (Even if it would be a compile error to actually try
- * to instantiate the constructor.)  These macros add an extra argument to the
- * function to cause it to only be instantiated if a pointer of type T is
- * convertible to a pointer of type U.
- *
- * THRIFT_OVERLOAD_IF should be used in function declarations.
- * THRIFT_OVERLOAD_IF_DEFN should be used in the function definition, if it is
- * defined separately from where it is declared.
- */
-#define THRIFT_OVERLOAD_IF_DEFN(T, Y) \
-  typename ::boost::enable_if<typename ::boost::is_convertible<T*, Y*>::type, \
-                              void*>::type
-
-#define THRIFT_OVERLOAD_IF(T, Y) \
-  THRIFT_OVERLOAD_IF_DEFN(T, Y) = NULL
-
-namespace apache { namespace thrift {
-
-class TEnumIterator : public std::iterator<std::forward_iterator_tag, std::pair<int, const char*> > {
- public:
-  TEnumIterator(int n,
-                int* enums,
-                const char** names) :
-      ii_(0), n_(n), enums_(enums), names_(names) {
-  }
-
-  int operator ++() {
-    return ++ii_;
-  }
-
-  bool operator !=(const TEnumIterator& end) {
-    assert(end.n_ == -1);
-    return (ii_ != n_);
-  }
-
-  std::pair<int, const char*> operator*() const {
-    return std::make_pair(enums_[ii_], names_[ii_]);
-  }
-
- private:
-  int ii_;
-  const int n_;
-  int* enums_;
-  const char** names_;
-};
-
-class TOutput {
- public:
-  TOutput() : f_(&errorTimeWrapper) {}
-
-  inline void setOutputFunction(void (*function)(const char *)){
-    f_ = function;
-  }
-
-  inline void operator()(const char *message){
-    f_(message);
-  }
-
-  // It is important to have a const char* overload here instead of
-  // just the string version, otherwise errno could be corrupted
-  // if there is some problem allocating memory when constructing
-  // the string.
-  void perror(const char *message, int errno_copy);
-  inline void perror(const std::string &message, int errno_copy) {
-    perror(message.c_str(), errno_copy);
-  }
-
-  void printf(const char *message, ...);
-
-  inline static void errorTimeWrapper(const char* msg) {
-    time_t now;
-    char dbgtime[26];
-    time(&now);
-    ctime_r(&now, dbgtime);
-    dbgtime[24] = 0;
-    fprintf(stderr, "Thrift: %s %s\n", dbgtime, msg);
-  }
-
-  /** Just like strerror_r but returns a C++ string object. */
-  static std::string strerror_s(int errno_copy);
-
- private:
-  void (*f_)(const char *);
-};
-
-extern TOutput GlobalOutput;
-
-class TException : public std::exception {
- public:
-  TException():
-    message_() {}
-
-  TException(const std::string& message) :
-    message_(message) {}
-
-  virtual ~TException() throw() {}
-
-  virtual const char* what() const throw() {
-    if (message_.empty()) {
-      return "Default TException.";
-    } else {
-      return message_.c_str();
-    }
-  }
-
- protected:
-  std::string message_;
-
-};
-
-
-// Forward declare this structure used by TDenseProtocol
-namespace reflection { namespace local {
-struct TypeSpec;
-}}
-
-class TDelayedException {
- public:
-  template <class E> static TDelayedException* delayException(const E& e);
-  virtual void throw_it() = 0;
-  virtual ~TDelayedException() {};
-};
-
-template <class E> class TExceptionWrapper : public TDelayedException {
- public:
-  TExceptionWrapper(const E& e) : e_(e) {}
-  virtual void throw_it() {
-    E temp(e_);
-    delete this;
-    throw temp;
-  }
- private:
-  E e_;
-};
-
-template <class E>
-TDelayedException* TDelayedException::delayException(const E& e) {
-  return new TExceptionWrapper<E>(e);
-}
-
-#if T_GLOBAL_DEBUG_VIRTUAL > 1
-void profile_virtual_call(const std::type_info& info);
-void profile_generic_protocol(const std::type_info& template_type,
-                              const std::type_info& prot_type);
-void profile_print_info(FILE *f);
-void profile_print_info();
-void profile_write_pprof(FILE* gen_calls_f, FILE* virtual_calls_f);
-#endif
-
-}} // apache::thrift
-
-#endif // #ifndef _THRIFT_THRIFT_H_
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#ifndef _THRIFT_THRIFT_H_
+#define _THRIFT_THRIFT_H_ 1
+
+#ifdef _WIN32
+#include "windows/config.h"
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include <stdio.h>
+#include <assert.h>
+
+#include <sys/types.h>
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_INTTYPES_H
+#include <inttypes.h>
+#endif
+
+/**
+ * CONTRAIL-CUSTOM
+ */
+
+#ifndef _WINDOWS
+#include <netinet/in.h>
+#include <sys/socket.h>
+#endif
+
+#include <string>
+#include <map>
+#include <list>
+#include <set>
+#include <vector>
+#include <exception>
+#include <typeinfo>
+
+#include <boost/utility/enable_if.hpp>
+#include <boost/type_traits/is_convertible.hpp>
+
+#include "TLogging.h"
+
+/**
+ * Helper macros to allow function overloading even when using
+ * boost::shared_ptr.
+ *
+ * shared_ptr makes overloading really annoying, since shared_ptr defines
+ * constructor methods to allow one shared_ptr type to be constructed from any
+ * other shared_ptr type.  (Even if it would be a compile error to actually try
+ * to instantiate the constructor.)  These macros add an extra argument to the
+ * function to cause it to only be instantiated if a pointer of type T is
+ * convertible to a pointer of type U.
+ *
+ * THRIFT_OVERLOAD_IF should be used in function declarations.
+ * THRIFT_OVERLOAD_IF_DEFN should be used in the function definition, if it is
+ * defined separately from where it is declared.
+ */
+#define THRIFT_OVERLOAD_IF_DEFN(T, Y) \
+  typename ::boost::enable_if<typename ::boost::is_convertible<T*, Y*>::type, \
+                              void*>::type
+
+#define THRIFT_OVERLOAD_IF(T, Y) \
+  THRIFT_OVERLOAD_IF_DEFN(T, Y) = NULL
+
+namespace apache { namespace thrift {
+
+class TEnumIterator : public std::iterator<std::forward_iterator_tag, std::pair<int, const char*> > {
+ public:
+  TEnumIterator(int n,
+                int* enums,
+                const char** names) :
+      ii_(0), n_(n), enums_(enums), names_(names) {
+  }
+
+  int operator ++() {
+    return ++ii_;
+  }
+
+  bool operator !=(const TEnumIterator& end) {
+    assert(end.n_ == -1);
+    return (ii_ != n_);
+  }
+
+  std::pair<int, const char*> operator*() const {
+    return std::make_pair(enums_[ii_], names_[ii_]);
+  }
+
+ private:
+  int ii_;
+  const int n_;
+  int* enums_;
+  const char** names_;
+};
+
+class TOutput {
+ public:
+  TOutput() : f_(&errorTimeWrapper) {}
+
+  inline void setOutputFunction(void (*function)(const char *)){
+    f_ = function;
+  }
+
+  inline void operator()(const char *message){
+    f_(message);
+  }
+
+  // It is important to have a const char* overload here instead of
+  // just the string version, otherwise errno could be corrupted
+  // if there is some problem allocating memory when constructing
+  // the string.
+  void perror(const char *message, int errno_copy);
+  inline void perror(const std::string &message, int errno_copy) {
+    perror(message.c_str(), errno_copy);
+  }
+
+  void printf(const char *message, ...);
+
+  inline static void errorTimeWrapper(const char* msg) {
+    time_t now;
+    char dbgtime[26];
+    time(&now);
+    ctime_r(&now, dbgtime);
+    dbgtime[24] = 0;
+    fprintf(stderr, "Thrift: %s %s\n", dbgtime, msg);
+  }
+
+  /** Just like strerror_r but returns a C++ string object. */
+  static std::string strerror_s(int errno_copy);
+
+ private:
+  void (*f_)(const char *);
+};
+
+extern TOutput GlobalOutput;
+
+class TException : public std::exception {
+ public:
+  TException():
+    message_() {}
+
+  TException(const std::string& message) :
+    message_(message) {}
+
+  virtual ~TException() throw() {}
+
+  virtual const char* what() const throw() {
+    if (message_.empty()) {
+      return "Default TException.";
+    } else {
+      return message_.c_str();
+    }
+  }
+
+ protected:
+  std::string message_;
+
+};
+
+
+// Forward declare this structure used by TDenseProtocol
+namespace reflection { namespace local {
+struct TypeSpec;
+}}
+
+class TDelayedException {
+ public:
+  template <class E> static TDelayedException* delayException(const E& e);
+  virtual void throw_it() = 0;
+  virtual ~TDelayedException() {};
+};
+
+template <class E> class TExceptionWrapper : public TDelayedException {
+ public:
+  TExceptionWrapper(const E& e) : e_(e) {}
+  virtual void throw_it() {
+    E temp(e_);
+    delete this;
+    throw temp;
+  }
+ private:
+  E e_;
+};
+
+template <class E>
+TDelayedException* TDelayedException::delayException(const E& e) {
+  return new TExceptionWrapper<E>(e);
+}
+
+#if T_GLOBAL_DEBUG_VIRTUAL > 1
+void profile_virtual_call(const std::type_info& info);
+void profile_generic_protocol(const std::type_info& template_type,
+                              const std::type_info& prot_type);
+void profile_print_info(FILE *f);
+void profile_print_info();
+void profile_write_pprof(FILE* gen_calls_f, FILE* virtual_calls_f);
+#endif
+
+}} // apache::thrift
+
+#endif // #ifndef _THRIFT_THRIFT_H_
--- compiler/cpp/src/thrifty.yy	Sat Nov 26 11:00:48 2011
+++ compiler/cpp/src/thrifty.yy	Wed Oct 11 15:45:33 2017
@@ -1,1188 +1,1188 @@
-%{
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements. See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership. The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-/**
- * Thrift parser.
- *
- * This parser is used on a thrift definition file.
- *
- */
-
-#define __STDC_LIMIT_MACROS
-#define __STDC_FORMAT_MACROS
-#include <stdio.h>
-#include <inttypes.h>
-#include <limits.h>
-#include "main.h"
-#include "globals.h"
-#include "parse/t_program.h"
-#include "parse/t_scope.h"
-
-/**
- * This global variable is used for automatic numbering of field indices etc.
- * when parsing the members of a struct. Field values are automatically
- * assigned starting from -1 and working their way down.
- */
-int y_field_val = -1;
-int g_arglist = 0;
-const int struct_is_struct = 0;
-const int struct_is_union = 1;
-
-%}
-
-/**
- * This structure is used by the parser to hold the data types associated with
- * various parse nodes.
- */
-%union {
-  char*          id;
-  int64_t        iconst;
-  double         dconst;
-  bool           tbool;
-  t_doc*         tdoc;
-  t_type*        ttype;
-  t_base_type*   tbase;
-  t_typedef*     ttypedef;
-  t_enum*        tenum;
-  t_enum_value*  tenumv;
-  t_const*       tconst;
-  t_const_value* tconstv;
-  t_struct*      tstruct;
-  t_service*     tservice;
-  t_function*    tfunction;
-  t_field*       tfield;
-  char*          dtext;
-  t_field::e_req ereq;
-  t_annotation*  tannot;
-  t_field_id     tfieldid;
-}
-
-/**
- * Strings identifier
- */
-%token<id>     tok_identifier
-%token<id>     tok_literal
-%token<dtext>  tok_doctext
-%token<id>     tok_st_identifier
-
-/**
- * Constant values
- */
-%token<iconst> tok_int_constant
-%token<dconst> tok_dub_constant
-
-/**
- * Header keywords
- */
-%token tok_include
-%token tok_namespace
-%token tok_cpp_namespace
-%token tok_cpp_include
-%token tok_cpp_type
-%token tok_php_namespace
-%token tok_py_module
-%token tok_perl_package
-%token tok_java_package
-%token tok_xsd_all
-%token tok_xsd_optional
-%token tok_xsd_nillable
-%token tok_xsd_namespace
-%token tok_xsd_attrs
-%token tok_ruby_namespace
-%token tok_smalltalk_category
-%token tok_smalltalk_prefix
-%token tok_cocoa_prefix
-%token tok_csharp_namespace
-%token tok_delphi_namespace
-
-/**
- * Base datatype keywords
- */
-%token tok_void
-%token tok_bool
-%token tok_byte
-%token tok_string
-%token tok_binary
-%token tok_slist
-%token tok_senum
-%token tok_i16
-%token tok_i32
-%token tok_i64
-%token tok_double
-
-/**
- * Complex type keywords
- */
-%token tok_map
-%token tok_list
-%token tok_set
-
-/**
- * Function modifiers
- */
-%token tok_oneway
-
-/**
- * Thrift language keywords
- */
-%token tok_typedef
-%token tok_struct
-%token tok_xception
-%token tok_throws
-%token tok_extends
-%token tok_service
-%token tok_enum
-%token tok_const
-%token tok_required
-%token tok_optional
-%token tok_union
-
-/**
- * Grammar nodes
- */
-
-%type<ttype>     BaseType
-%type<ttype>     SimpleBaseType
-%type<ttype>     ContainerType
-%type<ttype>     SimpleContainerType
-%type<ttype>     MapType
-%type<ttype>     SetType
-%type<ttype>     ListType
-
-%type<tdoc>      Definition
-%type<ttype>     TypeDefinition
-
-%type<ttypedef>  Typedef
-
-%type<ttype>     TypeAnnotations
-%type<ttype>     TypeAnnotationList
-%type<tannot>    TypeAnnotation
-
-%type<tfield>    Field
-%type<tfieldid>  FieldIdentifier
-%type<ereq>      FieldRequiredness
-%type<ttype>     FieldType
-%type<tconstv>   FieldValue
-%type<tstruct>   FieldList
-
-%type<tenum>     Enum
-%type<tenum>     EnumDefList
-%type<tenumv>    EnumDef
-
-%type<ttypedef>  Senum
-%type<tbase>     SenumDefList
-%type<id>        SenumDef
-
-%type<tconst>    Const
-%type<tconstv>   ConstValue
-%type<tconstv>   ConstList
-%type<tconstv>   ConstListContents
-%type<tconstv>   ConstMap
-%type<tconstv>   ConstMapContents
-
-%type<iconst>    StructHead
-%type<tstruct>   Struct
-%type<tstruct>   Xception
-%type<tservice>  Service
-
-%type<tfunction> Function
-%type<ttype>     FunctionType
-%type<tservice>  FunctionList
-
-%type<tstruct>   Throws
-%type<tservice>  Extends
-%type<tbool>     Oneway
-%type<tbool>     XsdAll
-%type<tbool>     XsdOptional
-%type<tbool>     XsdNillable
-%type<tstruct>   XsdAttributes
-%type<id>        CppType
-
-%type<dtext>     CaptureDocText
-
-%%
-
-/**
- * Thrift Grammar Implementation.
- *
- * For the most part this source file works its way top down from what you
- * might expect to find in a typical .thrift file, i.e. type definitions and
- * namespaces up top followed by service definitions using those types.
- */
-
-Program:
-  HeaderList DefinitionList
-    {
-      pdebug("Program -> Headers DefinitionList");
-      /*
-      TODO(dreiss): Decide whether full-program doctext is worth the trouble.
-      if ($1 != NULL) {
-        g_program->set_doc($1);
-      }
-      */
-      clear_doctext();
-    }
-
-CaptureDocText:
-    {
-      if (g_parse_mode == PROGRAM) {
-        $$ = g_doctext;
-        g_doctext = NULL;
-      } else {
-        $$ = NULL;
-      }
-    }
-
-/* TODO(dreiss): Try to DestroyDocText in all sorts or random places. */
-DestroyDocText:
-    {
-      if (g_parse_mode == PROGRAM) {
-        clear_doctext();
-      }
-    }
-
-/* We have to DestroyDocText here, otherwise it catches the doctext
-   on the first real element. */
-HeaderList:
-  HeaderList DestroyDocText Header
-    {
-      pdebug("HeaderList -> HeaderList Header");
-    }
-|
-    {
-      pdebug("HeaderList -> ");
-    }
-
-Header:
-  Include
-    {
-      pdebug("Header -> Include");
-    }
-| tok_namespace tok_identifier tok_identifier
-    {
-      pdebug("Header -> tok_namespace tok_identifier tok_identifier");
-      if (g_parse_mode == PROGRAM) {
-        g_program->set_namespace($2, $3);
-      }
-    }
-| tok_namespace '*' tok_identifier
-    {
-      pdebug("Header -> tok_namespace * tok_identifier");
-      if (g_parse_mode == PROGRAM) {
-        g_program->set_namespace("*", $3);
-      }
-    }
-/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
-| tok_cpp_namespace tok_identifier
-    {
-      pwarning(1, "'cpp_namespace' is deprecated. Use 'namespace cpp' instead");
-      pdebug("Header -> tok_cpp_namespace tok_identifier");
-      if (g_parse_mode == PROGRAM) {
-        g_program->set_namespace("cpp", $2);
-      }
-    }
-| tok_cpp_include tok_literal
-    {
-      pdebug("Header -> tok_cpp_include tok_literal");
-      if (g_parse_mode == PROGRAM) {
-        g_program->add_cpp_include($2);
-      }
-    }
-| tok_php_namespace tok_identifier
-    {
-      pwarning(1, "'php_namespace' is deprecated. Use 'namespace php' instead");
-      pdebug("Header -> tok_php_namespace tok_identifier");
-      if (g_parse_mode == PROGRAM) {
-        g_program->set_namespace("php", $2);
-      }
-    }
-/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
-| tok_py_module tok_identifier
-    {
-      pwarning(1, "'py_module' is deprecated. Use 'namespace py' instead");
-      pdebug("Header -> tok_py_module tok_identifier");
-      if (g_parse_mode == PROGRAM) {
-        g_program->set_namespace("py", $2);
-      }
-    }
-/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
-| tok_perl_package tok_identifier
-    {
-      pwarning(1, "'perl_package' is deprecated. Use 'namespace perl' instead");
-      pdebug("Header -> tok_perl_namespace tok_identifier");
-      if (g_parse_mode == PROGRAM) {
-        g_program->set_namespace("perl", $2);
-      }
-    }
-/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
-| tok_ruby_namespace tok_identifier
-    {
-      pwarning(1, "'ruby_namespace' is deprecated. Use 'namespace rb' instead");
-      pdebug("Header -> tok_ruby_namespace tok_identifier");
-      if (g_parse_mode == PROGRAM) {
-        g_program->set_namespace("rb", $2);
-      }
-    }
-/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
-| tok_smalltalk_category tok_st_identifier
-    {
-      pwarning(1, "'smalltalk_category' is deprecated. Use 'namespace smalltalk.category' instead");
-      pdebug("Header -> tok_smalltalk_category tok_st_identifier");
-      if (g_parse_mode == PROGRAM) {
-        g_program->set_namespace("smalltalk.category", $2);
-      }
-    }
-/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
-| tok_smalltalk_prefix tok_identifier
-    {
-      pwarning(1, "'smalltalk_prefix' is deprecated. Use 'namespace smalltalk.prefix' instead");
-      pdebug("Header -> tok_smalltalk_prefix tok_identifier");
-      if (g_parse_mode == PROGRAM) {
-        g_program->set_namespace("smalltalk.prefix", $2);
-      }
-    }
-/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
-| tok_java_package tok_identifier
-    {
-      pwarning(1, "'java_package' is deprecated. Use 'namespace java' instead");
-      pdebug("Header -> tok_java_package tok_identifier");
-      if (g_parse_mode == PROGRAM) {
-        g_program->set_namespace("java", $2);
-      }
-    }
-/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
-| tok_cocoa_prefix tok_identifier
-    {
-      pwarning(1, "'cocoa_prefix' is deprecated. Use 'namespace cocoa' instead");
-      pdebug("Header -> tok_cocoa_prefix tok_identifier");
-      if (g_parse_mode == PROGRAM) {
-        g_program->set_namespace("cocoa", $2);
-      }
-    }
-/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
-| tok_xsd_namespace tok_literal
-    {
-      pwarning(1, "'xsd_namespace' is deprecated. Use 'namespace xsd' instead");
-      pdebug("Header -> tok_xsd_namespace tok_literal");
-      if (g_parse_mode == PROGRAM) {
-        g_program->set_namespace("cocoa", $2);
-      }
-    }
-/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
-| tok_csharp_namespace tok_identifier
-   {
-     pwarning(1, "'csharp_namespace' is deprecated. Use 'namespace csharp' instead");
-     pdebug("Header -> tok_csharp_namespace tok_identifier");
-     if (g_parse_mode == PROGRAM) {
-       g_program->set_namespace("csharp", $2);
-     }
-   }
-/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
-| tok_delphi_namespace tok_identifier
-   {
-     pwarning(1, "'delphi_namespace' is deprecated. Use 'namespace delphi' instead");
-     pdebug("Header -> tok_delphi_namespace tok_identifier");
-     if (g_parse_mode == PROGRAM) {
-       g_program->set_namespace("delphi", $2);
-     }
-   }
-
-Include:
-  tok_include tok_literal
-    {
-      pdebug("Include -> tok_include tok_literal");
-      if (g_parse_mode == INCLUDES) {
-        std::string path = include_file(std::string($2));
-        if (!path.empty()) {
-          g_program->add_include(path, std::string($2));
-        }
-      }
-    }
-
-DefinitionList:
-  DefinitionList CaptureDocText Definition
-    {
-      pdebug("DefinitionList -> DefinitionList Definition");
-      if ($2 != NULL && $3 != NULL) {
-        $3->set_doc($2);
-      }
-    }
-|
-    {
-      pdebug("DefinitionList -> ");
-    }
-
-Definition:
-  Const
-    {
-      pdebug("Definition -> Const");
-      if (g_parse_mode == PROGRAM) {
-        g_program->add_const($1);
-      }
-      $$ = $1;
-    }
-| TypeDefinition
-    {
-      pdebug("Definition -> TypeDefinition");
-      if (g_parse_mode == PROGRAM) {
-        g_scope->add_type($1->get_name(), $1);
-        if (g_parent_scope != NULL) {
-          g_parent_scope->add_type(g_parent_prefix + $1->get_name(), $1);
-        }
-      }
-      $$ = $1;
-    }
-| Service
-    {
-      pdebug("Definition -> Service");
-      if (g_parse_mode == PROGRAM) {
-        g_scope->add_service($1->get_name(), $1);
-        if (g_parent_scope != NULL) {
-          g_parent_scope->add_service(g_parent_prefix + $1->get_name(), $1);
-        }
-        g_program->add_service($1);
-      }
-      $$ = $1;
-    }
-
-TypeDefinition:
-  Typedef
-    {
-      pdebug("TypeDefinition -> Typedef");
-      if (g_parse_mode == PROGRAM) {
-        g_program->add_typedef($1);
-      }
-    }
-| Enum
-    {
-      pdebug("TypeDefinition -> Enum");
-      if (g_parse_mode == PROGRAM) {
-        g_program->add_enum($1);
-      }
-    }
-| Senum
-    {
-      pdebug("TypeDefinition -> Senum");
-      if (g_parse_mode == PROGRAM) {
-        g_program->add_typedef($1);
-      }
-    }
-| Struct
-    {
-      pdebug("TypeDefinition -> Struct");
-      if (g_parse_mode == PROGRAM) {
-        g_program->add_struct($1);
-      }
-    }
-| Xception
-    {
-      pdebug("TypeDefinition -> Xception");
-      if (g_parse_mode == PROGRAM) {
-        g_program->add_xception($1);
-      }
-    }
-
-Typedef:
-  tok_typedef FieldType tok_identifier
-    {
-      pdebug("TypeDef -> tok_typedef FieldType tok_identifier");
-      t_typedef *td = new t_typedef(g_program, $2, $3);
-      $$ = td;
-    }
-
-CommaOrSemicolonOptional:
-  ','
-    {}
-| ';'
-    {}
-|
-    {}
-
-Enum:
-  tok_enum tok_identifier '{' EnumDefList '}'
-    {
-      pdebug("Enum -> tok_enum tok_identifier { EnumDefList }");
-      $$ = $4;
-      $$->set_name($2);
-      $$->resolve_values();
-      // make constants for all the enum values
-      if (g_parse_mode == PROGRAM) {
-        const std::vector<t_enum_value*>& enum_values = $$->get_constants();
-        std::vector<t_enum_value*>::const_iterator c_iter;
-        for (c_iter = enum_values.begin(); c_iter != enum_values.end(); ++c_iter) {
-          std::string const_name = $$->get_name() + "." + (*c_iter)->get_name();
-          t_const_value* const_val = new t_const_value((*c_iter)->get_value());
-          const_val->set_enum($$);
-          g_scope->add_constant(const_name, new t_const(g_type_i32, (*c_iter)->get_name(), const_val));
-          if (g_parent_scope != NULL) {
-            g_parent_scope->add_constant(g_parent_prefix + const_name, new t_const(g_type_i32, (*c_iter)->get_name(), const_val));
-          }
-        }
-      }
-    }
-
-EnumDefList:
-  EnumDefList EnumDef
-    {
-      pdebug("EnumDefList -> EnumDefList EnumDef");
-      $$ = $1;
-      $$->append($2);
-    }
-|
-    {
-      pdebug("EnumDefList -> ");
-      $$ = new t_enum(g_program);
-    }
-
-EnumDef:
-  CaptureDocText tok_identifier '=' tok_int_constant CommaOrSemicolonOptional
-    {
-      pdebug("EnumDef -> tok_identifier = tok_int_constant");
-      if ($4 < 0) {
-        pwarning(1, "Negative value supplied for enum %s.\n", $2);
-      }
-      if ($4 > INT_MAX) {
-        pwarning(1, "64-bit value supplied for enum %s.\n", $2);
-      }
-      $$ = new t_enum_value($2, $4);
-      if ($1 != NULL) {
-        $$->set_doc($1);
-      }
-    }
-|
-  CaptureDocText tok_identifier CommaOrSemicolonOptional
-    {
-      pdebug("EnumDef -> tok_identifier");
-      $$ = new t_enum_value($2);
-      if ($1 != NULL) {
-        $$->set_doc($1);
-      }
-    }
-
-Senum:
-  tok_senum tok_identifier '{' SenumDefList '}'
-    {
-      pdebug("Senum -> tok_senum tok_identifier { SenumDefList }");
-      $$ = new t_typedef(g_program, $4, $2);
-    }
-
-SenumDefList:
-  SenumDefList SenumDef
-    {
-      pdebug("SenumDefList -> SenumDefList SenumDef");
-      $$ = $1;
-      $$->add_string_enum_val($2);
-    }
-|
-    {
-      pdebug("SenumDefList -> ");
-      $$ = new t_base_type("string", t_base_type::TYPE_STRING);
-      $$->set_string_enum(true);
-    }
-
-SenumDef:
-  tok_literal CommaOrSemicolonOptional
-    {
-      pdebug("SenumDef -> tok_literal");
-      $$ = $1;
-    }
-
-Const:
-  tok_const FieldType tok_identifier '=' ConstValue CommaOrSemicolonOptional
-    {
-      pdebug("Const -> tok_const FieldType tok_identifier = ConstValue");
-      if (g_parse_mode == PROGRAM) {
-        g_scope->resolve_const_value($5, $2);
-        $$ = new t_const($2, $3, $5);
-        validate_const_type($$);
-
-        g_scope->add_constant($3, $$);
-        if (g_parent_scope != NULL) {
-          g_parent_scope->add_constant(g_parent_prefix + $3, $$);
-        }
-      } else {
-        $$ = NULL;
-      }
-    }
-
-ConstValue:
-  tok_int_constant
-    {
-      pdebug("ConstValue => tok_int_constant");
-      $$ = new t_const_value();
-      $$->set_integer($1);
-      if (!g_allow_64bit_consts && ($1 < INT32_MIN || $1 > INT32_MAX)) {
-        pwarning(1, "64-bit constant \"%"PRIi64"\" may not work in all languages.\n", $1);
-      }
-    }
-| tok_dub_constant
-    {
-      pdebug("ConstValue => tok_dub_constant");
-      $$ = new t_const_value();
-      $$->set_double($1);
-    }
-| tok_literal
-    {
-      pdebug("ConstValue => tok_literal");
-      $$ = new t_const_value($1);
-    }
-| tok_identifier
-    {
-      pdebug("ConstValue => tok_identifier");
-      $$ = new t_const_value();
-      $$->set_identifier($1);
-    }
-| ConstList
-    {
-      pdebug("ConstValue => ConstList");
-      $$ = $1;
-    }
-| ConstMap
-    {
-      pdebug("ConstValue => ConstMap");
-      $$ = $1;
-    }
-
-ConstList:
-  '[' ConstListContents ']'
-    {
-      pdebug("ConstList => [ ConstListContents ]");
-      $$ = $2;
-    }
-
-ConstListContents:
-  ConstListContents ConstValue CommaOrSemicolonOptional
-    {
-      pdebug("ConstListContents => ConstListContents ConstValue CommaOrSemicolonOptional");
-      $$ = $1;
-      $$->add_list($2);
-    }
-|
-    {
-      pdebug("ConstListContents =>");
-      $$ = new t_const_value();
-      $$->set_list();
-    }
-
-ConstMap:
-  '{' ConstMapContents '}'
-    {
-      pdebug("ConstMap => { ConstMapContents }");
-      $$ = $2;
-    }
-
-ConstMapContents:
-  ConstMapContents ConstValue ':' ConstValue CommaOrSemicolonOptional
-    {
-      pdebug("ConstMapContents => ConstMapContents ConstValue CommaOrSemicolonOptional");
-      $$ = $1;
-      $$->add_map($2, $4);
-    }
-|
-    {
-      pdebug("ConstMapContents =>");
-      $$ = new t_const_value();
-      $$->set_map();
-    }
-
-StructHead:
-  tok_struct
-    {
-      $$ = struct_is_struct;
-    }
-| tok_union
-    {
-      $$ = struct_is_union;
-    }
-
-Struct:
-  StructHead tok_identifier XsdAll '{' FieldList '}' TypeAnnotations
-    {
-      pdebug("Struct -> tok_struct tok_identifier { FieldList }");
-      $5->set_xsd_all($3);
-      $5->set_union($1 == struct_is_union);
-      $$ = $5;
-      $$->set_name($2);
-      if ($7 != NULL) {
-        $$->annotations_ = $7->annotations_;
-        delete $7;
-      }
-    }
-    
-XsdAll:
-  tok_xsd_all
-    {
-      $$ = true;
-    }
-|
-    {
-      $$ = false;
-    }
-
-XsdOptional:
-  tok_xsd_optional
-    {
-      $$ = true;
-    }
-|
-    {
-      $$ = false;
-    }
-
-XsdNillable:
-  tok_xsd_nillable
-    {
-      $$ = true;
-    }
-|
-    {
-      $$ = false;
-    }
-
-XsdAttributes:
-  tok_xsd_attrs '{' FieldList '}'
-    {
-      $$ = $3;
-    }
-|
-    {
-      $$ = NULL;
-    }
-
-Xception:
-  tok_xception tok_identifier '{' FieldList '}'
-    {
-      pdebug("Xception -> tok_xception tok_identifier { FieldList }");
-      $4->set_name($2);
-      $4->set_xception(true);
-      $$ = $4;
-    }
-
-Service:
-  tok_service tok_identifier Extends '{' FlagArgs FunctionList UnflagArgs '}'
-    {
-      pdebug("Service -> tok_service tok_identifier { FunctionList }");
-      $$ = $6;
-      $$->set_name($2);
-      $$->set_extends($3);
-    }
-
-FlagArgs:
-    {
-       g_arglist = 1;
-    }
-
-UnflagArgs:
-    {
-       g_arglist = 0;
-    }
-
-Extends:
-  tok_extends tok_identifier
-    {
-      pdebug("Extends -> tok_extends tok_identifier");
-      $$ = NULL;
-      if (g_parse_mode == PROGRAM) {
-        $$ = g_scope->get_service($2);
-        if ($$ == NULL) {
-          yyerror("Service \"%s\" has not been defined.", $2);
-          exit(1);
-        }
-      }
-    }
-|
-    {
-      $$ = NULL;
-    }
-
-FunctionList:
-  FunctionList Function
-    {
-      pdebug("FunctionList -> FunctionList Function");
-      $$ = $1;
-      $1->add_function($2);
-    }
-|
-    {
-      pdebug("FunctionList -> ");
-      $$ = new t_service(g_program);
-    }
-
-Function:
-  CaptureDocText Oneway FunctionType tok_identifier '(' FieldList ')' Throws CommaOrSemicolonOptional
-    {
-      $6->set_name(std::string($4) + "_args");
-      $$ = new t_function($3, $4, $6, $8, $2);
-      if ($1 != NULL) {
-        $$->set_doc($1);
-      }
-    }
-
-Oneway:
-  tok_oneway
-    {
-      $$ = true;
-    }
-|
-    {
-      $$ = false;
-    }
-
-Throws:
-  tok_throws '(' FieldList ')'
-    {
-      pdebug("Throws -> tok_throws ( FieldList )");
-      $$ = $3;
-      if (g_parse_mode == PROGRAM && !validate_throws($$)) {
-        yyerror("Throws clause may not contain non-exception types");
-        exit(1);
-      }
-    }
-|
-    {
-      $$ = new t_struct(g_program);
-    }
-
-FieldList:
-  FieldList Field
-    {
-      pdebug("FieldList -> FieldList , Field");
-      $$ = $1;
-      if (!($$->append($2))) {
-        yyerror("Field identifier %d for \"%s\" has already been used", $2->get_key(), $2->get_name().c_str());
-        exit(1);
-      }
-    }
-|
-    {
-      pdebug("FieldList -> ");
-      y_field_val = -1;
-      $$ = new t_struct(g_program);
-    }
-
-Field:
-  CaptureDocText FieldIdentifier FieldRequiredness FieldType tok_identifier FieldValue XsdOptional XsdNillable XsdAttributes TypeAnnotations CommaOrSemicolonOptional
-    {
-      pdebug("tok_int_constant : Field -> FieldType tok_identifier");
-      if ($2.auto_assigned) {
-        pwarning(1, "No field key specified for %s, resulting protocol may have conflicts or not be backwards compatible!\n", $5);
-        if (g_strict >= 192) {
-          yyerror("Implicit field keys are deprecated and not allowed with -strict");
-          exit(1);
-        }
-      }
-      $$ = new t_field($4, $5, $2.value);
-      $$->set_req($3);
-      if ($6 != NULL) {
-        g_scope->resolve_const_value($6, $4);
-        validate_field_value($$, $6);
-        $$->set_value($6);
-      }
-      $$->set_xsd_optional($7);
-      $$->set_xsd_nillable($8);
-      if ($1 != NULL) {
-        $$->set_doc($1);
-      }
-      if ($9 != NULL) {
-        $$->set_xsd_attrs($9);
-      }
-      if ($10 != NULL) {
-        $$->annotations_ = $10->annotations_;
-        delete $10;
-      }
-    }
-
-FieldIdentifier:
-  tok_int_constant ':'
-    {
-      if ($1 <= 0) {
-        if (g_allow_neg_field_keys) {
-          /*
-           * g_allow_neg_field_keys exists to allow users to add explicitly
-           * specified key values to old .thrift files without breaking
-           * protocol compatibility.
-           */
-          if ($1 != y_field_val) {
-            /*
-             * warn if the user-specified negative value isn't what
-             * thrift would have auto-assigned.
-             */
-            pwarning(1, "Negative field key (%d) differs from what would be "
-                     "auto-assigned by thrift (%d).\n", $1, y_field_val);
-          }
-          /*
-           * Leave $1 as-is, and update y_field_val to be one less than $1.
-           * The FieldList parsing will catch any duplicate key values.
-           */
-          y_field_val = $1 - 1;
-          $$.value = $1;
-          $$.auto_assigned = false;
-        } else {
-          pwarning(1, "Nonpositive value (%d) not allowed as a field key.\n",
-                   $1);
-          $$.value = y_field_val--;
-          $$.auto_assigned = true;
-        }
-      } else {
-        $$.value = $1;
-        $$.auto_assigned = false;
-      }
-    }
-|
-    {
-      $$.value = y_field_val--;
-      $$.auto_assigned = true;
-    }
-
-FieldRequiredness:
-  tok_required
-    {
-      $$ = t_field::T_REQUIRED;
-    }
-| tok_optional
-    {
-      if (g_arglist) {
-        if (g_parse_mode == PROGRAM) {
-          pwarning(1, "optional keyword is ignored in argument lists.\n");
-        }
-        $$ = t_field::T_OPT_IN_REQ_OUT;
-      } else {
-        $$ = t_field::T_OPTIONAL;
-      }
-    }
-|
-    {
-      $$ = t_field::T_OPT_IN_REQ_OUT;
-    }
-
-FieldValue:
-  '=' ConstValue
-    {
-      if (g_parse_mode == PROGRAM) {
-        $$ = $2;
-      } else {
-        $$ = NULL;
-      }
-    }
-|
-    {
-      $$ = NULL;
-    }
-
-FunctionType:
-  FieldType
-    {
-      pdebug("FunctionType -> FieldType");
-      $$ = $1;
-    }
-| tok_void
-    {
-      pdebug("FunctionType -> tok_void");
-      $$ = g_type_void;
-    }
-
-FieldType:
-  tok_identifier
-    {
-      pdebug("FieldType -> tok_identifier");
-      if (g_parse_mode == INCLUDES) {
-        // Ignore identifiers in include mode
-        $$ = NULL;
-      } else {
-        // Lookup the identifier in the current scope
-        $$ = g_scope->get_type($1);
-        if ($$ == NULL) {
-          yyerror("Type \"%s\" has not been defined.", $1);
-          exit(1);
-        }
-      }
-    }
-| BaseType
-    {
-      pdebug("FieldType -> BaseType");
-      $$ = $1;
-    }
-| ContainerType
-    {
-      pdebug("FieldType -> ContainerType");
-      $$ = $1;
-    }
-
-BaseType: SimpleBaseType TypeAnnotations
-    {
-      pdebug("BaseType -> SimpleBaseType TypeAnnotations");
-      if ($2 != NULL) {
-        $$ = new t_base_type(*static_cast<t_base_type*>($1));
-        $$->annotations_ = $2->annotations_;
-        delete $2;
-      } else {
-        $$ = $1;
-      }
-    }
-
-SimpleBaseType:
-  tok_string
-    {
-      pdebug("BaseType -> tok_string");
-      $$ = g_type_string;
-    }
-| tok_binary
-    {
-      pdebug("BaseType -> tok_binary");
-      $$ = g_type_binary;
-    }
-| tok_slist
-    {
-      pdebug("BaseType -> tok_slist");
-      $$ = g_type_slist;
-    }
-| tok_bool
-    {
-      pdebug("BaseType -> tok_bool");
-      $$ = g_type_bool;
-    }
-| tok_byte
-    {
-      pdebug("BaseType -> tok_byte");
-      $$ = g_type_byte;
-    }
-| tok_i16
-    {
-      pdebug("BaseType -> tok_i16");
-      $$ = g_type_i16;
-    }
-| tok_i32
-    {
-      pdebug("BaseType -> tok_i32");
-      $$ = g_type_i32;
-    }
-| tok_i64
-    {
-      pdebug("BaseType -> tok_i64");
-      $$ = g_type_i64;
-    }
-| tok_double
-    {
-      pdebug("BaseType -> tok_double");
-      $$ = g_type_double;
-    }
-
-ContainerType: SimpleContainerType TypeAnnotations
-    {
-      pdebug("ContainerType -> SimpleContainerType TypeAnnotations");
-      $$ = $1;
-      if ($2 != NULL) {
-        $$->annotations_ = $2->annotations_;
-        delete $2;
-      }
-    }
-
-SimpleContainerType:
-  MapType
-    {
-      pdebug("SimpleContainerType -> MapType");
-      $$ = $1;
-    }
-| SetType
-    {
-      pdebug("SimpleContainerType -> SetType");
-      $$ = $1;
-    }
-| ListType
-    {
-      pdebug("SimpleContainerType -> ListType");
-      $$ = $1;
-    }
-
-MapType:
-  tok_map CppType '<' FieldType ',' FieldType '>'
-    {
-      pdebug("MapType -> tok_map <FieldType, FieldType>");
-      $$ = new t_map($4, $6);
-      if ($2 != NULL) {
-        ((t_container*)$$)->set_cpp_name(std::string($2));
-      }
-    }
-
-SetType:
-  tok_set CppType '<' FieldType '>'
-    {
-      pdebug("SetType -> tok_set<FieldType>");
-      $$ = new t_set($4);
-      if ($2 != NULL) {
-        ((t_container*)$$)->set_cpp_name(std::string($2));
-      }
-    }
-
-ListType:
-  tok_list '<' FieldType '>' CppType
-    {
-      pdebug("ListType -> tok_list<FieldType>");
-      $$ = new t_list($3);
-      if ($5 != NULL) {
-        ((t_container*)$$)->set_cpp_name(std::string($5));
-      }
-    }
-
-CppType:
-  tok_cpp_type tok_literal
-    {
-      $$ = $2;
-    }
-|
-    {
-      $$ = NULL;
-    }
-
-TypeAnnotations:
-  '(' TypeAnnotationList ')'
-    {
-      pdebug("TypeAnnotations -> ( TypeAnnotationList )");
-      $$ = $2;
-    }
-|
-    {
-      $$ = NULL;
-    }
-
-TypeAnnotationList:
-  TypeAnnotationList TypeAnnotation
-    {
-      pdebug("TypeAnnotationList -> TypeAnnotationList , TypeAnnotation");
-      $$ = $1;
-      $$->annotations_[$2->key] = $2->val;
-      delete $2;
-    }
-|
-    {
-      /* Just use a dummy structure to hold the annotations. */
-      $$ = new t_struct(g_program);
-    }
-
-TypeAnnotation:
-  tok_identifier '=' tok_literal CommaOrSemicolonOptional
-    {
-      pdebug("TypeAnnotation -> tok_identifier = tok_literal");
-      $$ = new t_annotation;
-      $$->key = $1;
-      $$->val = $3;
-    }
-
-%%
+%{
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+/**
+ * Thrift parser.
+ *
+ * This parser is used on a thrift definition file.
+ *
+ */
+
+#define __STDC_LIMIT_MACROS
+#define __STDC_FORMAT_MACROS
+#include <stdio.h>
+#include <inttypes.h>
+#include <limits.h>
+#include "main.h"
+#include "globals.h"
+#include "parse/t_program.h"
+#include "parse/t_scope.h"
+
+/**
+ * This global variable is used for automatic numbering of field indices etc.
+ * when parsing the members of a struct. Field values are automatically
+ * assigned starting from -1 and working their way down.
+ */
+int y_field_val = -1;
+int g_arglist = 0;
+const int struct_is_struct = 0;
+const int struct_is_union = 1;
+
+%}
+
+/**
+ * This structure is used by the parser to hold the data types associated with
+ * various parse nodes.
+ */
+%union {
+  char*          id;
+  int64_t        iconst;
+  double         dconst;
+  bool           tbool;
+  t_doc*         tdoc;
+  t_type*        ttype;
+  t_base_type*   tbase;
+  t_typedef*     ttypedef;
+  t_enum*        tenum;
+  t_enum_value*  tenumv;
+  t_const*       tconst;
+  t_const_value* tconstv;
+  t_struct*      tstruct;
+  t_service*     tservice;
+  t_function*    tfunction;
+  t_field*       tfield;
+  char*          dtext;
+  t_field::e_req ereq;
+  t_annotation*  tannot;
+  t_field_id     tfieldid;
+}
+
+/**
+ * Strings identifier
+ */
+%token<id>     tok_identifier
+%token<id>     tok_literal
+%token<dtext>  tok_doctext
+%token<id>     tok_st_identifier
+
+/**
+ * Constant values
+ */
+%token<iconst> tok_int_constant
+%token<dconst> tok_dub_constant
+
+/**
+ * Header keywords
+ */
+%token tok_include
+%token tok_namespace
+%token tok_cpp_namespace
+%token tok_cpp_include
+%token tok_cpp_type
+%token tok_php_namespace
+%token tok_py_module
+%token tok_perl_package
+%token tok_java_package
+%token tok_xsd_all
+%token tok_xsd_optional
+%token tok_xsd_nillable
+%token tok_xsd_namespace
+%token tok_xsd_attrs
+%token tok_ruby_namespace
+%token tok_smalltalk_category
+%token tok_smalltalk_prefix
+%token tok_cocoa_prefix
+%token tok_csharp_namespace
+%token tok_delphi_namespace
+
+/**
+ * Base datatype keywords
+ */
+%token tok_void
+%token tok_bool
+%token tok_byte
+%token tok_string
+%token tok_binary
+%token tok_slist
+%token tok_senum
+%token tok_i16
+%token tok_i32
+%token tok_i64
+%token tok_double
+
+/**
+ * Complex type keywords
+ */
+%token tok_map
+%token tok_list
+%token tok_set
+
+/**
+ * Function modifiers
+ */
+%token tok_oneway
+
+/**
+ * Thrift language keywords
+ */
+%token tok_typedef
+%token tok_struct
+%token tok_xception
+%token tok_throws
+%token tok_extends
+%token tok_service
+%token tok_enum
+%token tok_const
+%token tok_required
+%token tok_optional
+%token tok_union
+
+/**
+ * Grammar nodes
+ */
+
+%type<ttype>     BaseType
+%type<ttype>     SimpleBaseType
+%type<ttype>     ContainerType
+%type<ttype>     SimpleContainerType
+%type<ttype>     MapType
+%type<ttype>     SetType
+%type<ttype>     ListType
+
+%type<tdoc>      Definition
+%type<ttype>     TypeDefinition
+
+%type<ttypedef>  Typedef
+
+%type<ttype>     TypeAnnotations
+%type<ttype>     TypeAnnotationList
+%type<tannot>    TypeAnnotation
+
+%type<tfield>    Field
+%type<tfieldid>  FieldIdentifier
+%type<ereq>      FieldRequiredness
+%type<ttype>     FieldType
+%type<tconstv>   FieldValue
+%type<tstruct>   FieldList
+
+%type<tenum>     Enum
+%type<tenum>     EnumDefList
+%type<tenumv>    EnumDef
+
+%type<ttypedef>  Senum
+%type<tbase>     SenumDefList
+%type<id>        SenumDef
+
+%type<tconst>    Const
+%type<tconstv>   ConstValue
+%type<tconstv>   ConstList
+%type<tconstv>   ConstListContents
+%type<tconstv>   ConstMap
+%type<tconstv>   ConstMapContents
+
+%type<iconst>    StructHead
+%type<tstruct>   Struct
+%type<tstruct>   Xception
+%type<tservice>  Service
+
+%type<tfunction> Function
+%type<ttype>     FunctionType
+%type<tservice>  FunctionList
+
+%type<tstruct>   Throws
+%type<tservice>  Extends
+%type<tbool>     Oneway
+%type<tbool>     XsdAll
+%type<tbool>     XsdOptional
+%type<tbool>     XsdNillable
+%type<tstruct>   XsdAttributes
+%type<id>        CppType
+
+%type<dtext>     CaptureDocText
+
+%%
+
+/**
+ * Thrift Grammar Implementation.
+ *
+ * For the most part this source file works its way top down from what you
+ * might expect to find in a typical .thrift file, i.e. type definitions and
+ * namespaces up top followed by service definitions using those types.
+ */
+
+Program:
+  HeaderList DefinitionList
+    {
+      pdebug("Program -> Headers DefinitionList");
+      /*
+      TODO(dreiss): Decide whether full-program doctext is worth the trouble.
+      if ($1 != NULL) {
+        g_program->set_doc($1);
+      }
+      */
+      clear_doctext();
+    }
+
+CaptureDocText:
+    {
+      if (g_parse_mode == PROGRAM) {
+        $$ = g_doctext;
+        g_doctext = NULL;
+      } else {
+        $$ = NULL;
+      }
+    }
+
+/* TODO(dreiss): Try to DestroyDocText in all sorts or random places. */
+DestroyDocText:
+    {
+      if (g_parse_mode == PROGRAM) {
+        clear_doctext();
+      }
+    }
+
+/* We have to DestroyDocText here, otherwise it catches the doctext
+   on the first real element. */
+HeaderList:
+  HeaderList DestroyDocText Header
+    {
+      pdebug("HeaderList -> HeaderList Header");
+    }
+|
+    {
+      pdebug("HeaderList -> ");
+    }
+
+Header:
+  Include
+    {
+      pdebug("Header -> Include");
+    }
+| tok_namespace tok_identifier tok_identifier
+    {
+      pdebug("Header -> tok_namespace tok_identifier tok_identifier");
+      if (g_parse_mode == PROGRAM) {
+        g_program->set_namespace($2, $3);
+      }
+    }
+| tok_namespace '*' tok_identifier
+    {
+      pdebug("Header -> tok_namespace * tok_identifier");
+      if (g_parse_mode == PROGRAM) {
+        g_program->set_namespace("*", $3);
+      }
+    }
+/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
+| tok_cpp_namespace tok_identifier
+    {
+      pwarning(1, "'cpp_namespace' is deprecated. Use 'namespace cpp' instead");
+      pdebug("Header -> tok_cpp_namespace tok_identifier");
+      if (g_parse_mode == PROGRAM) {
+        g_program->set_namespace("cpp", $2);
+      }
+    }
+| tok_cpp_include tok_literal
+    {
+      pdebug("Header -> tok_cpp_include tok_literal");
+      if (g_parse_mode == PROGRAM) {
+        g_program->add_cpp_include($2);
+      }
+    }
+| tok_php_namespace tok_identifier
+    {
+      pwarning(1, "'php_namespace' is deprecated. Use 'namespace php' instead");
+      pdebug("Header -> tok_php_namespace tok_identifier");
+      if (g_parse_mode == PROGRAM) {
+        g_program->set_namespace("php", $2);
+      }
+    }
+/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
+| tok_py_module tok_identifier
+    {
+      pwarning(1, "'py_module' is deprecated. Use 'namespace py' instead");
+      pdebug("Header -> tok_py_module tok_identifier");
+      if (g_parse_mode == PROGRAM) {
+        g_program->set_namespace("py", $2);
+      }
+    }
+/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
+| tok_perl_package tok_identifier
+    {
+      pwarning(1, "'perl_package' is deprecated. Use 'namespace perl' instead");
+      pdebug("Header -> tok_perl_namespace tok_identifier");
+      if (g_parse_mode == PROGRAM) {
+        g_program->set_namespace("perl", $2);
+      }
+    }
+/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
+| tok_ruby_namespace tok_identifier
+    {
+      pwarning(1, "'ruby_namespace' is deprecated. Use 'namespace rb' instead");
+      pdebug("Header -> tok_ruby_namespace tok_identifier");
+      if (g_parse_mode == PROGRAM) {
+        g_program->set_namespace("rb", $2);
+      }
+    }
+/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
+| tok_smalltalk_category tok_st_identifier
+    {
+      pwarning(1, "'smalltalk_category' is deprecated. Use 'namespace smalltalk.category' instead");
+      pdebug("Header -> tok_smalltalk_category tok_st_identifier");
+      if (g_parse_mode == PROGRAM) {
+        g_program->set_namespace("smalltalk.category", $2);
+      }
+    }
+/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
+| tok_smalltalk_prefix tok_identifier
+    {
+      pwarning(1, "'smalltalk_prefix' is deprecated. Use 'namespace smalltalk.prefix' instead");
+      pdebug("Header -> tok_smalltalk_prefix tok_identifier");
+      if (g_parse_mode == PROGRAM) {
+        g_program->set_namespace("smalltalk.prefix", $2);
+      }
+    }
+/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
+| tok_java_package tok_identifier
+    {
+      pwarning(1, "'java_package' is deprecated. Use 'namespace java' instead");
+      pdebug("Header -> tok_java_package tok_identifier");
+      if (g_parse_mode == PROGRAM) {
+        g_program->set_namespace("java", $2);
+      }
+    }
+/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
+| tok_cocoa_prefix tok_identifier
+    {
+      pwarning(1, "'cocoa_prefix' is deprecated. Use 'namespace cocoa' instead");
+      pdebug("Header -> tok_cocoa_prefix tok_identifier");
+      if (g_parse_mode == PROGRAM) {
+        g_program->set_namespace("cocoa", $2);
+      }
+    }
+/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
+| tok_xsd_namespace tok_literal
+    {
+      pwarning(1, "'xsd_namespace' is deprecated. Use 'namespace xsd' instead");
+      pdebug("Header -> tok_xsd_namespace tok_literal");
+      if (g_parse_mode == PROGRAM) {
+        g_program->set_namespace("cocoa", $2);
+      }
+    }
+/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
+| tok_csharp_namespace tok_identifier
+   {
+     pwarning(1, "'csharp_namespace' is deprecated. Use 'namespace csharp' instead");
+     pdebug("Header -> tok_csharp_namespace tok_identifier");
+     if (g_parse_mode == PROGRAM) {
+       g_program->set_namespace("csharp", $2);
+     }
+   }
+/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
+| tok_delphi_namespace tok_identifier
+   {
+     pwarning(1, "'delphi_namespace' is deprecated. Use 'namespace delphi' instead");
+     pdebug("Header -> tok_delphi_namespace tok_identifier");
+     if (g_parse_mode == PROGRAM) {
+       g_program->set_namespace("delphi", $2);
+     }
+   }
+
+Include:
+  tok_include tok_literal
+    {
+      pdebug("Include -> tok_include tok_literal");
+      if (g_parse_mode == INCLUDES) {
+        std::string path = include_file(std::string($2));
+        if (!path.empty()) {
+          g_program->add_include(path, std::string($2));
+        }
+      }
+    }
+
+DefinitionList:
+  DefinitionList CaptureDocText Definition
+    {
+      pdebug("DefinitionList -> DefinitionList Definition");
+      if ($2 != NULL && $3 != NULL) {
+        $3->set_doc($2);
+      }
+    }
+|
+    {
+      pdebug("DefinitionList -> ");
+    }
+
+Definition:
+  Const
+    {
+      pdebug("Definition -> Const");
+      if (g_parse_mode == PROGRAM) {
+        g_program->add_const($1);
+      }
+      $$ = $1;
+    }
+| TypeDefinition
+    {
+      pdebug("Definition -> TypeDefinition");
+      if (g_parse_mode == PROGRAM) {
+        g_scope->add_type($1->get_name(), $1);
+        if (g_parent_scope != NULL) {
+          g_parent_scope->add_type(g_parent_prefix + $1->get_name(), $1);
+        }
+      }
+      $$ = $1;
+    }
+| Service
+    {
+      pdebug("Definition -> Service");
+      if (g_parse_mode == PROGRAM) {
+        g_scope->add_service($1->get_name(), $1);
+        if (g_parent_scope != NULL) {
+          g_parent_scope->add_service(g_parent_prefix + $1->get_name(), $1);
+        }
+        g_program->add_service($1);
+      }
+      $$ = $1;
+    }
+
+TypeDefinition:
+  Typedef
+    {
+      pdebug("TypeDefinition -> Typedef");
+      if (g_parse_mode == PROGRAM) {
+        g_program->add_typedef($1);
+      }
+    }
+| Enum
+    {
+      pdebug("TypeDefinition -> Enum");
+      if (g_parse_mode == PROGRAM) {
+        g_program->add_enum($1);
+      }
+    }
+| Senum
+    {
+      pdebug("TypeDefinition -> Senum");
+      if (g_parse_mode == PROGRAM) {
+        g_program->add_typedef($1);
+      }
+    }
+| Struct
+    {
+      pdebug("TypeDefinition -> Struct");
+      if (g_parse_mode == PROGRAM) {
+        g_program->add_struct($1);
+      }
+    }
+| Xception
+    {
+      pdebug("TypeDefinition -> Xception");
+      if (g_parse_mode == PROGRAM) {
+        g_program->add_xception($1);
+      }
+    }
+
+Typedef:
+  tok_typedef FieldType tok_identifier
+    {
+      pdebug("TypeDef -> tok_typedef FieldType tok_identifier");
+      t_typedef *td = new t_typedef(g_program, $2, $3);
+      $$ = td;
+    }
+
+CommaOrSemicolonOptional:
+  ','
+    {}
+| ';'
+    {}
+|
+    {}
+
+Enum:
+  tok_enum tok_identifier '{' EnumDefList '}'
+    {
+      pdebug("Enum -> tok_enum tok_identifier { EnumDefList }");
+      $$ = $4;
+      $$->set_name($2);
+      $$->resolve_values();
+      // make constants for all the enum values
+      if (g_parse_mode == PROGRAM) {
+        const std::vector<t_enum_value*>& enum_values = $$->get_constants();
+        std::vector<t_enum_value*>::const_iterator c_iter;
+        for (c_iter = enum_values.begin(); c_iter != enum_values.end(); ++c_iter) {
+          std::string const_name = $$->get_name() + "." + (*c_iter)->get_name();
+          t_const_value* const_val = new t_const_value((*c_iter)->get_value());
+          const_val->set_enum($$);
+          g_scope->add_constant(const_name, new t_const(g_type_i32, (*c_iter)->get_name(), const_val));
+          if (g_parent_scope != NULL) {
+            g_parent_scope->add_constant(g_parent_prefix + const_name, new t_const(g_type_i32, (*c_iter)->get_name(), const_val));
+          }
+        }
+      }
+    }
+
+EnumDefList:
+  EnumDefList EnumDef
+    {
+      pdebug("EnumDefList -> EnumDefList EnumDef");
+      $$ = $1;
+      $$->append($2);
+    }
+|
+    {
+      pdebug("EnumDefList -> ");
+      $$ = new t_enum(g_program);
+    }
+
+EnumDef:
+  CaptureDocText tok_identifier '=' tok_int_constant CommaOrSemicolonOptional
+    {
+      pdebug("EnumDef -> tok_identifier = tok_int_constant");
+      if ($4 < 0) {
+        pwarning(1, "Negative value supplied for enum %s.\n", $2);
+      }
+      if ($4 > INT_MAX) {
+        pwarning(1, "64-bit value supplied for enum %s.\n", $2);
+      }
+      $$ = new t_enum_value($2, $4);
+      if ($1 != NULL) {
+        $$->set_doc($1);
+      }
+    }
+|
+  CaptureDocText tok_identifier CommaOrSemicolonOptional
+    {
+      pdebug("EnumDef -> tok_identifier");
+      $$ = new t_enum_value($2);
+      if ($1 != NULL) {
+        $$->set_doc($1);
+      }
+    }
+
+Senum:
+  tok_senum tok_identifier '{' SenumDefList '}'
+    {
+      pdebug("Senum -> tok_senum tok_identifier { SenumDefList }");
+      $$ = new t_typedef(g_program, $4, $2);
+    }
+
+SenumDefList:
+  SenumDefList SenumDef
+    {
+      pdebug("SenumDefList -> SenumDefList SenumDef");
+      $$ = $1;
+      $$->add_string_enum_val($2);
+    }
+|
+    {
+      pdebug("SenumDefList -> ");
+      $$ = new t_base_type("string", t_base_type::TYPE_STRING);
+      $$->set_string_enum(true);
+    }
+
+SenumDef:
+  tok_literal CommaOrSemicolonOptional
+    {
+      pdebug("SenumDef -> tok_literal");
+      $$ = $1;
+    }
+
+Const:
+  tok_const FieldType tok_identifier '=' ConstValue CommaOrSemicolonOptional
+    {
+      pdebug("Const -> tok_const FieldType tok_identifier = ConstValue");
+      if (g_parse_mode == PROGRAM) {
+        g_scope->resolve_const_value($5, $2);
+        $$ = new t_const($2, $3, $5);
+        validate_const_type($$);
+
+        g_scope->add_constant($3, $$);
+        if (g_parent_scope != NULL) {
+          g_parent_scope->add_constant(g_parent_prefix + $3, $$);
+        }
+      } else {
+        $$ = NULL;
+      }
+    }
+
+ConstValue:
+  tok_int_constant
+    {
+      pdebug("ConstValue => tok_int_constant");
+      $$ = new t_const_value();
+      $$->set_integer($1);
+      if (!g_allow_64bit_consts && ($1 < INT32_MIN || $1 > INT32_MAX)) {
+        pwarning(1, "64-bit constant \"%" PRIi64 "\" may not work in all languages.\n", $1);
+      }
+    }
+| tok_dub_constant
+    {
+      pdebug("ConstValue => tok_dub_constant");
+      $$ = new t_const_value();
+      $$->set_double($1);
+    }
+| tok_literal
+    {
+      pdebug("ConstValue => tok_literal");
+      $$ = new t_const_value($1);
+    }
+| tok_identifier
+    {
+      pdebug("ConstValue => tok_identifier");
+      $$ = new t_const_value();
+      $$->set_identifier($1);
+    }
+| ConstList
+    {
+      pdebug("ConstValue => ConstList");
+      $$ = $1;
+    }
+| ConstMap
+    {
+      pdebug("ConstValue => ConstMap");
+      $$ = $1;
+    }
+
+ConstList:
+  '[' ConstListContents ']'
+    {
+      pdebug("ConstList => [ ConstListContents ]");
+      $$ = $2;
+    }
+
+ConstListContents:
+  ConstListContents ConstValue CommaOrSemicolonOptional
+    {
+      pdebug("ConstListContents => ConstListContents ConstValue CommaOrSemicolonOptional");
+      $$ = $1;
+      $$->add_list($2);
+    }
+|
+    {
+      pdebug("ConstListContents =>");
+      $$ = new t_const_value();
+      $$->set_list();
+    }
+
+ConstMap:
+  '{' ConstMapContents '}'
+    {
+      pdebug("ConstMap => { ConstMapContents }");
+      $$ = $2;
+    }
+
+ConstMapContents:
+  ConstMapContents ConstValue ':' ConstValue CommaOrSemicolonOptional
+    {
+      pdebug("ConstMapContents => ConstMapContents ConstValue CommaOrSemicolonOptional");
+      $$ = $1;
+      $$->add_map($2, $4);
+    }
+|
+    {
+      pdebug("ConstMapContents =>");
+      $$ = new t_const_value();
+      $$->set_map();
+    }
+
+StructHead:
+  tok_struct
+    {
+      $$ = struct_is_struct;
+    }
+| tok_union
+    {
+      $$ = struct_is_union;
+    }
+
+Struct:
+  StructHead tok_identifier XsdAll '{' FieldList '}' TypeAnnotations
+    {
+      pdebug("Struct -> tok_struct tok_identifier { FieldList }");
+      $5->set_xsd_all($3);
+      $5->set_union($1 == struct_is_union);
+      $$ = $5;
+      $$->set_name($2);
+      if ($7 != NULL) {
+        $$->annotations_ = $7->annotations_;
+        delete $7;
+      }
+    }
+    
+XsdAll:
+  tok_xsd_all
+    {
+      $$ = true;
+    }
+|
+    {
+      $$ = false;
+    }
+
+XsdOptional:
+  tok_xsd_optional
+    {
+      $$ = true;
+    }
+|
+    {
+      $$ = false;
+    }
+
+XsdNillable:
+  tok_xsd_nillable
+    {
+      $$ = true;
+    }
+|
+    {
+      $$ = false;
+    }
+
+XsdAttributes:
+  tok_xsd_attrs '{' FieldList '}'
+    {
+      $$ = $3;
+    }
+|
+    {
+      $$ = NULL;
+    }
+
+Xception:
+  tok_xception tok_identifier '{' FieldList '}'
+    {
+      pdebug("Xception -> tok_xception tok_identifier { FieldList }");
+      $4->set_name($2);
+      $4->set_xception(true);
+      $$ = $4;
+    }
+
+Service:
+  tok_service tok_identifier Extends '{' FlagArgs FunctionList UnflagArgs '}'
+    {
+      pdebug("Service -> tok_service tok_identifier { FunctionList }");
+      $$ = $6;
+      $$->set_name($2);
+      $$->set_extends($3);
+    }
+
+FlagArgs:
+    {
+       g_arglist = 1;
+    }
+
+UnflagArgs:
+    {
+       g_arglist = 0;
+    }
+
+Extends:
+  tok_extends tok_identifier
+    {
+      pdebug("Extends -> tok_extends tok_identifier");
+      $$ = NULL;
+      if (g_parse_mode == PROGRAM) {
+        $$ = g_scope->get_service($2);
+        if ($$ == NULL) {
+          yyerror("Service \"%s\" has not been defined.", $2);
+          exit(1);
+        }
+      }
+    }
+|
+    {
+      $$ = NULL;
+    }
+
+FunctionList:
+  FunctionList Function
+    {
+      pdebug("FunctionList -> FunctionList Function");
+      $$ = $1;
+      $1->add_function($2);
+    }
+|
+    {
+      pdebug("FunctionList -> ");
+      $$ = new t_service(g_program);
+    }
+
+Function:
+  CaptureDocText Oneway FunctionType tok_identifier '(' FieldList ')' Throws CommaOrSemicolonOptional
+    {
+      $6->set_name(std::string($4) + "_args");
+      $$ = new t_function($3, $4, $6, $8, $2);
+      if ($1 != NULL) {
+        $$->set_doc($1);
+      }
+    }
+
+Oneway:
+  tok_oneway
+    {
+      $$ = true;
+    }
+|
+    {
+      $$ = false;
+    }
+
+Throws:
+  tok_throws '(' FieldList ')'
+    {
+      pdebug("Throws -> tok_throws ( FieldList )");
+      $$ = $3;
+      if (g_parse_mode == PROGRAM && !validate_throws($$)) {
+        yyerror("Throws clause may not contain non-exception types");
+        exit(1);
+      }
+    }
+|
+    {
+      $$ = new t_struct(g_program);
+    }
+
+FieldList:
+  FieldList Field
+    {
+      pdebug("FieldList -> FieldList , Field");
+      $$ = $1;
+      if (!($$->append($2))) {
+        yyerror("Field identifier %d for \"%s\" has already been used", $2->get_key(), $2->get_name().c_str());
+        exit(1);
+      }
+    }
+|
+    {
+      pdebug("FieldList -> ");
+      y_field_val = -1;
+      $$ = new t_struct(g_program);
+    }
+
+Field:
+  CaptureDocText FieldIdentifier FieldRequiredness FieldType tok_identifier FieldValue XsdOptional XsdNillable XsdAttributes TypeAnnotations CommaOrSemicolonOptional
+    {
+      pdebug("tok_int_constant : Field -> FieldType tok_identifier");
+      if ($2.auto_assigned) {
+        pwarning(1, "No field key specified for %s, resulting protocol may have conflicts or not be backwards compatible!\n", $5);
+        if (g_strict >= 192) {
+          yyerror("Implicit field keys are deprecated and not allowed with -strict");
+          exit(1);
+        }
+      }
+      $$ = new t_field($4, $5, $2.value);
+      $$->set_req($3);
+      if ($6 != NULL) {
+        g_scope->resolve_const_value($6, $4);
+        validate_field_value($$, $6);
+        $$->set_value($6);
+      }
+      $$->set_xsd_optional($7);
+      $$->set_xsd_nillable($8);
+      if ($1 != NULL) {
+        $$->set_doc($1);
+      }
+      if ($9 != NULL) {
+        $$->set_xsd_attrs($9);
+      }
+      if ($10 != NULL) {
+        $$->annotations_ = $10->annotations_;
+        delete $10;
+      }
+    }
+
+FieldIdentifier:
+  tok_int_constant ':'
+    {
+      if ($1 <= 0) {
+        if (g_allow_neg_field_keys) {
+          /*
+           * g_allow_neg_field_keys exists to allow users to add explicitly
+           * specified key values to old .thrift files without breaking
+           * protocol compatibility.
+           */
+          if ($1 != y_field_val) {
+            /*
+             * warn if the user-specified negative value isn't what
+             * thrift would have auto-assigned.
+             */
+            pwarning(1, "Negative field key (%d) differs from what would be "
+                     "auto-assigned by thrift (%d).\n", $1, y_field_val);
+          }
+          /*
+           * Leave $1 as-is, and update y_field_val to be one less than $1.
+           * The FieldList parsing will catch any duplicate key values.
+           */
+          y_field_val = $1 - 1;
+          $$.value = $1;
+          $$.auto_assigned = false;
+        } else {
+          pwarning(1, "Nonpositive value (%d) not allowed as a field key.\n",
+                   $1);
+          $$.value = y_field_val--;
+          $$.auto_assigned = true;
+        }
+      } else {
+        $$.value = $1;
+        $$.auto_assigned = false;
+      }
+    }
+|
+    {
+      $$.value = y_field_val--;
+      $$.auto_assigned = true;
+    }
+
+FieldRequiredness:
+  tok_required
+    {
+      $$ = t_field::T_REQUIRED;
+    }
+| tok_optional
+    {
+      if (g_arglist) {
+        if (g_parse_mode == PROGRAM) {
+          pwarning(1, "optional keyword is ignored in argument lists.\n");
+        }
+        $$ = t_field::T_OPT_IN_REQ_OUT;
+      } else {
+        $$ = t_field::T_OPTIONAL;
+      }
+    }
+|
+    {
+      $$ = t_field::T_OPT_IN_REQ_OUT;
+    }
+
+FieldValue:
+  '=' ConstValue
+    {
+      if (g_parse_mode == PROGRAM) {
+        $$ = $2;
+      } else {
+        $$ = NULL;
+      }
+    }
+|
+    {
+      $$ = NULL;
+    }
+
+FunctionType:
+  FieldType
+    {
+      pdebug("FunctionType -> FieldType");
+      $$ = $1;
+    }
+| tok_void
+    {
+      pdebug("FunctionType -> tok_void");
+      $$ = g_type_void;
+    }
+
+FieldType:
+  tok_identifier
+    {
+      pdebug("FieldType -> tok_identifier");
+      if (g_parse_mode == INCLUDES) {
+        // Ignore identifiers in include mode
+        $$ = NULL;
+      } else {
+        // Lookup the identifier in the current scope
+        $$ = g_scope->get_type($1);
+        if ($$ == NULL) {
+          yyerror("Type \"%s\" has not been defined.", $1);
+          exit(1);
+        }
+      }
+    }
+| BaseType
+    {
+      pdebug("FieldType -> BaseType");
+      $$ = $1;
+    }
+| ContainerType
+    {
+      pdebug("FieldType -> ContainerType");
+      $$ = $1;
+    }
+
+BaseType: SimpleBaseType TypeAnnotations
+    {
+      pdebug("BaseType -> SimpleBaseType TypeAnnotations");
+      if ($2 != NULL) {
+        $$ = new t_base_type(*static_cast<t_base_type*>($1));
+        $$->annotations_ = $2->annotations_;
+        delete $2;
+      } else {
+        $$ = $1;
+      }
+    }
+
+SimpleBaseType:
+  tok_string
+    {
+      pdebug("BaseType -> tok_string");
+      $$ = g_type_string;
+    }
+| tok_binary
+    {
+      pdebug("BaseType -> tok_binary");
+      $$ = g_type_binary;
+    }
+| tok_slist
+    {
+      pdebug("BaseType -> tok_slist");
+      $$ = g_type_slist;
+    }
+| tok_bool
+    {
+      pdebug("BaseType -> tok_bool");
+      $$ = g_type_bool;
+    }
+| tok_byte
+    {
+      pdebug("BaseType -> tok_byte");
+      $$ = g_type_byte;
+    }
+| tok_i16
+    {
+      pdebug("BaseType -> tok_i16");
+      $$ = g_type_i16;
+    }
+| tok_i32
+    {
+      pdebug("BaseType -> tok_i32");
+      $$ = g_type_i32;
+    }
+| tok_i64
+    {
+      pdebug("BaseType -> tok_i64");
+      $$ = g_type_i64;
+    }
+| tok_double
+    {
+      pdebug("BaseType -> tok_double");
+      $$ = g_type_double;
+    }
+
+ContainerType: SimpleContainerType TypeAnnotations
+    {
+      pdebug("ContainerType -> SimpleContainerType TypeAnnotations");
+      $$ = $1;
+      if ($2 != NULL) {
+        $$->annotations_ = $2->annotations_;
+        delete $2;
+      }
+    }
+
+SimpleContainerType:
+  MapType
+    {
+      pdebug("SimpleContainerType -> MapType");
+      $$ = $1;
+    }
+| SetType
+    {
+      pdebug("SimpleContainerType -> SetType");
+      $$ = $1;
+    }
+| ListType
+    {
+      pdebug("SimpleContainerType -> ListType");
+      $$ = $1;
+    }
+
+MapType:
+  tok_map CppType '<' FieldType ',' FieldType '>'
+    {
+      pdebug("MapType -> tok_map <FieldType, FieldType>");
+      $$ = new t_map($4, $6);
+      if ($2 != NULL) {
+        ((t_container*)$$)->set_cpp_name(std::string($2));
+      }
+    }
+
+SetType:
+  tok_set CppType '<' FieldType '>'
+    {
+      pdebug("SetType -> tok_set<FieldType>");
+      $$ = new t_set($4);
+      if ($2 != NULL) {
+        ((t_container*)$$)->set_cpp_name(std::string($2));
+      }
+    }
+
+ListType:
+  tok_list '<' FieldType '>' CppType
+    {
+      pdebug("ListType -> tok_list<FieldType>");
+      $$ = new t_list($3);
+      if ($5 != NULL) {
+        ((t_container*)$$)->set_cpp_name(std::string($5));
+      }
+    }
+
+CppType:
+  tok_cpp_type tok_literal
+    {
+      $$ = $2;
+    }
+|
+    {
+      $$ = NULL;
+    }
+
+TypeAnnotations:
+  '(' TypeAnnotationList ')'
+    {
+      pdebug("TypeAnnotations -> ( TypeAnnotationList )");
+      $$ = $2;
+    }
+|
+    {
+      $$ = NULL;
+    }
+
+TypeAnnotationList:
+  TypeAnnotationList TypeAnnotation
+    {
+      pdebug("TypeAnnotationList -> TypeAnnotationList , TypeAnnotation");
+      $$ = $1;
+      $$->annotations_[$2->key] = $2->val;
+      delete $2;
+    }
+|
+    {
+      /* Just use a dummy structure to hold the annotations. */
+      $$ = new t_struct(g_program);
+    }
+
+TypeAnnotation:
+  tok_identifier '=' tok_literal CommaOrSemicolonOptional
+    {
+      pdebug("TypeAnnotation -> tok_identifier = tok_literal");
+      $$ = new t_annotation;
+      $$->key = $1;
+      $$->val = $3;
+    }
+
+%%
